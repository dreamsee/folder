JSON 성능 최적화 패턴

============================================
패턴명: 중복 저장 제거 및 배열 직접 비교
============================================

문제 상황:
- 같은 데이터를 두 가지 형태로 중복 저장
- 한글 텍스트 형태: "시가하락-6% + 50% + 손절-12.0% + 일괄18.0%"
- 배열 압축 형태: ["시가하락-6%", 6.0, 1, 0.5, -12.0, 1, "18.0", 1]
- 매칭 시 텍스트 파싱 후 속성 변환하여 비교하는 이중 작업

Before (비효율적):
```
저장: 한글텍스트 + 압축배열 (중복)
매칭: 한글텍스트 → 파싱 → 속성변환 → 비교
용량: 100% + 40% = 140%
성능: 파싱 오버헤드 + 메모리 사용량 증가
```

After (최적화):
```
저장: 압축배열만 저장 (단일)
매칭: 배열 → 직접 비교
용량: 40% (60% 절약)
성능: 파싱 과정 제거 + 메모리 효율성
```

============================================
구현 방법
============================================

1단계: 중복 저장 제거
```python
# Before: 두 파일 모두 저장
with open('탈락전략.json', 'w') as f:
    json.dump(한글_형태_데이터, f)
with open('탈락전략_압축.json', 'w') as f:
    json.dump(압축_배열_데이터, f)

# After: 압축 파일만 저장
# 탈락전략.json 파일 생성 제거 - 압축파일만 사용하여 용량 절약 및 성능 향상
with open('탈락전략_압축.json', 'w') as f:
    json.dump(압축_배열_데이터, f)
```

2단계: 직접 배열 비교 함수 생성
```python
def _전략배열_일치확인(self, 배열1, 배열2, 허용오차=0.01):
    """두 전략 배열이 일치하는지 확인 - 성능 최적화"""
    if not 배열1 or not 배열2 or len(배열1) < 7 or len(배열2) < 7:
        return False
    
    # 배열 직접 비교 (탈락횟수 제외한 처음 7개 요소)
    try:
        if 배열1[0] != 배열2[0]:  # 매수전략타입
            return False
        if abs(float(배열1[1]) - float(배열2[1])) > 허용오차:  # 매수하락률
            return False
        # ... 나머지 요소들도 직접 비교
        return True
    except (ValueError, IndexError):
        return False
```

3단계: 기존 속성 변환 함수는 레거시 호환용으로 유지
```python
def _전략속성_일치확인(self, 전략속성1, 전략속성2, 허용오차=0.01):
    """레거시 호환용 - 점진적 마이그레이션"""
    # 기존 코드와 호환성 유지
```

============================================
성능 개선 효과
============================================

용량 절약:
- 탈락전략.json 제거: ~60% 용량 절약
- 단일 파일로 통합: 관리 복잡도 감소

처리 속도:
- 텍스트 파싱 과정 제거: ~30-50% 성능 향상
- 메모리 사용량 감소: ~40% 메모리 절약
- 직접 배열 비교: 속성 변환 오버헤드 제거

코드 복잡도:
- 이중 저장 로직 제거
- 단순화된 비교 로직
- 유지보수성 향상

============================================
적용 가능한 상황
============================================

1. 동일 데이터를 여러 형태로 저장하는 경우
2. 사람이 읽기 쉬운 형태와 기계 처리용 형태가 분리된 경우
3. 매칭/비교 작업이 빈번한 경우
4. 메모리나 저장 공간이 제한적인 경우

============================================
주의사항
============================================

1. 레거시 호환성: 기존 코드와의 호환성 유지
2. 디버깅: 사람이 읽기 어려운 형태가 될 수 있음
3. structure 정의: 배열 인덱스의 의미를 명확히 문서화
4. 타입 안정성: 배열 요소의 타입 검증 필요

============================================
확장 패턴
============================================

1. 스키마 버전 관리
```json
{
  "version": "3.0",
  "structure": ["필드1", "필드2", ...],
  "strategies": [[값1, 값2, ...]]
}
```

2. 타입 매핑
```json
{
  "매도타입_맵": {"1": "일괄", "2": "적극고무줄", ...}
}
```

3. 압축 레벨별 처리
- Level 1: 배열화
- Level 2: 타입 매핑
- Level 3: 바이너리 압축

============================================
측정 가능한 지표
============================================

- 파일 크기: Before vs After 비교
- 처리 시간: 매칭 작업 벤치마크
- 메모리 사용량: 로딩 시 메모리 점유율
- 에러율: 파싱 실패 감소율

이 패턴은 특히 대량의 구조화된 데이터를 다루는 시스템에서 효과적입니다.

최적화 완료일: 2025-08-27
성능 향상 예상: 용량 60% 절약, 처리속도 30-50% 향상