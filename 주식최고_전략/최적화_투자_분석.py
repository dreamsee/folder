import random
import time
import json
import os
import math
from datetime import datetime

try:
    import numpy as np
    NUMPY_AVAILABLE = True
except ImportError:
    NUMPY_AVAILABLE = False
    print("[경고] numpy가 설치되지 않았습니다. 기본 수학 라이브러리를 사용합니다.")

class 최적화투자분석:
    def __init__(self, 초기가격=100):
        self.주간데이터 = []
        self.일간데이터 = []
        self.시간데이터 = []
        self.초기가격 = 초기가격
        self.현재가격 = 초기가격
        self.과거데이터 = []  # 이동평균용 과거 120일 데이터
        self._과거데이터_생성()
        self.가격기록 = []  # 시간별 가격 기록
        
        # JSON 파일 경로 설정 (제작파일/주식최고_전략 폴더)
        self.기본경로 = r"C:\Users\ksj\OneDrive\바탕 화면\gemini\제작파일\주식최고_전략"
        self.탈락전략_파일 = os.path.join(self.기본경로, "탈락전략.json")
        self.최고전략_파일 = os.path.join(self.기본경로, "최고전략_히스토리.json")
        self.영구제외_파일 = os.path.join(self.기본경로, "영구제외_전략_히스토리_압축.json")
        self.포트폴리오_파일 = os.path.join(self.기본경로, "전략포트폴리오.json")
        
        # 성능 최적화를 위한 캐시 시스템
        self.위험전략_캐시 = {}  # 옐로우카드 11개 전략 캐시
        self.전략_해시_캐시 = {}  # 전략 해시 캐시
        self.종합랭킹_파일 = os.path.join(self.기본경로, "종합전략랭킹.json")
        self.시장성과_파일 = os.path.join(self.기본경로, "시장상황별_전략성과.json")
        self.포트폴리오구성_파일 = os.path.join(self.기본경로, "포트폴리오_구성.json")
        
        # 거래비용 설정
        self.거래비용설정 = {
            '매매수수료': 0.00015,  # 0.015% (증권사 수수료)
            '증권거래세': 0.0023,   # 0.23% (매도시만)
            '농특세': 0.00046,      # 0.046% (매도시만, 증권거래세의 20%)
            '슬리피지': 0.0002,     # 0.02% (시장충격비용, 매수/매도 모두)
            '거래비용반영': True     # 거래비용 적용 여부 
        }
    
    def _과거데이터_생성(self):
        """이동평균 계산용 과거 120일 데이터 생성"""
        print("과거 120일 주가 데이터 생성 중...")
        
        # 현재 초기가격(100원)에서 역산하여 자연스러운 과거 데이터 생성
        과거가격들 = []
        현재가격 = self.초기가격
        
        # 120일 전부터 현재까지의 가격 데이터 생성
        for 일차 in range(120, 0, -1):  # 120일 전부터 역순으로
            # 일일 변동률 (-3% ~ +3% 정도의 현실적 범위)
            일일변동률 = random.uniform(-3, 3)
            # 과거일수록 현재가격과 차이가 날 수 있도록 약간의 추세 반영
            추세보정 = (일차 / 120) * random.uniform(-0.5, 0.5)  # 장기간일수록 변동 가능성 증가
            최종변동률 = 일일변동률 + 추세보정
            
            현재가격 = 현재가격 * (1 + 최종변동률/100)
            현재가격 = max(50, min(200, 현재가격))  # 50~200원 범위 제한
            
        # 이제 정방향으로 120일 데이터 다시 생성
        시작가격 = 현재가격
        과거가격들 = [시작가격]
        
        for 일차 in range(1, 120):
            일일변동률 = random.uniform(-2.5, 2.5)  # 현실적 일일 변동률
            새가격 = 과거가격들[-1] * (1 + 일일변동률/100)
            새가격 = max(50, min(200, 새가격))  # 범위 제한
            과거가격들.append(새가격)
        
        # 마지막 가격이 초기가격(100)에 가깝도록 보정
        마지막가격 = 과거가격들[-1]
        보정비율 = self.초기가격 / 마지막가격
        self.과거데이터 = [가격 * 보정비율 for 가격 in 과거가격들]
        
        print(f"   과거 데이터 생성 완료: {self.과거데이터[0]:.1f}원 → {self.과거데이터[-1]:.1f}원")
        print(f"   20일 평균: {sum(self.과거데이터[-20:])/20:.1f}원")
        print(f"   60일 평균: {sum(self.과거데이터[-60:])/60:.1f}원") 
        print(f"   120일 평균: {sum(self.과거데이터)/120:.1f}원")
        
    def 랜덤_일별_데이터_생성(self):
        """현실적인 일간 변동률 우선 생성 후 주간 집계"""
        print("=== 135일간 일간 변동률 우선 생성 ===")
        
        # 135일간 다양한 변동폭의 일간 변동률 생성
        일간변동률들 = []
        누적가격 = self.초기가격
        
        print("\n일별 변동률 (다양한 변동폭):")
        
        # 시장 분위기 결정 (전체 기간에 영향)
        시장분위기 = random.choices(
            ['안정장', '보통장', '변동장', '급변장'],
            weights=[25, 40, 25, 10],
            k=1
        )[0]
        
        print(f"시장 분위기: {시장분위기}")
        print("   안정 보통 활발 급변동 극단\n")
        
        for 일차 in range(135):
            # 시장분위기에 따른 가중치 조정
            if 시장분위기 == '안정장':
                가중치 = [50, 35, 10, 4, 1]  # 안정적 변동 선호
            elif 시장분위기 == '보통장':
                가중치 = [25, 45, 20, 8, 2]  # 보통 변동 중심
            elif 시장분위기 == '변동장':
                가중치 = [15, 25, 35, 20, 5]  # 활발한 변동
            else:  # 급변장
                가중치 = [10, 15, 25, 35, 15]  # 급변동 자주 발생
            
            # 변동폭 타입 선택
            변동타입 = random.choices(
                ['안정', '보통', '활발', '급변동', '극단'],
                weights=가중치,
                k=1
            )[0]
            
            # 변동타입별 범위 설정
            if 변동타입 == '안정':
                일간변동 = random.uniform(-2, 2)  # 안정적 시장
                타입표시 = "안정"
            elif 변동타입 == '보통':
                일간변동 = random.uniform(-5, 5)  # 일반적 시장
                타입표시 = "보통"
            elif 변동타입 == '활발':
                일간변동 = random.uniform(-10, 10)  # 활발한 시장
                타입표시 = "활발"
            elif 변동타입 == '급변동':
                일간변동 = random.uniform(-20, 20)  # 급격한 시장
                타입표시 = "급변"
            else:  # 극단
                # 극단적 변동은 방향성을 가지도록 (폭락 또는 폭등)
                방향 = random.choice(['폭락', '폭등'])
                if 방향 == '폭락':
                    일간변동 = random.uniform(-30, -15)  # 대폭 하락
                    타입표시 = "폭락"
                else:
                    일간변동 = random.uniform(15, 30)   # 대폭 상승
                    타입표시 = "폭등"
                
            일간변동률들.append(일간변동)
            
            # 누적 가격 계산
            누적가격 = 누적가격 * (1 + 일간변동/100)
            
            # 주차 계산 (5일 단위)
            주차 = (일차 // 5) + 1
            주내일차 = (일차 % 5) + 1
            
            print(f"  {주차}주 {주내일차}일: {타입표시} {일간변동:+.2f}% [{변동타입}] (누적: {누적가격:.1f}원)")
        
        self.일간데이터 = 일간변동률들
        return 일간변동률들
    
    def 주간_집계_계산(self, 일간데이터):
        """일간 데이터를 기반으로 주간 변동률 집계"""
        print("\n=== 일간 → 주간 집계 계산 ===")
        
        self.주간데이터 = []
        누적가격 = self.초기가격
        
        print("\n주간 집계 결과:")
        
        # 27주간 데이터 처리
        for 주차 in range(27):
            주시작_인덱스 = 주차 * 5
            주종료_인덱스 = 주시작_인덱스 + 5
            
            주간_일별데이터 = 일간데이터[주시작_인덱스:주종료_인덱스]
            
            # 주 시작 가격
            주시작가격 = 누적가격
            
            # 해당 주의 일별 변동 복리 계산
            주간누적배수 = 1
            for 일변동 in 주간_일별데이터:
                주간누적배수 *= (1 + 일변동/100)
                누적가격 *= (1 + 일변동/100)
            
            # 주간 총 변동률 계산
            주간변동률 = (주간누적배수 - 1) * 100
            self.주간데이터.append(주간변동률)
            
            # 초기가격 대비 총 변동률
            총변동률 = ((누적가격 - self.초기가격) / self.초기가격) * 100
            
            print(f"  {주차+1}주차: {[f'{x:+.1f}' for x in 주간_일별데이터]} → 주간: {주간변동률:+.1f}% (누적: {총변동률:+.1f}%)")
        
        print(f"\n주간 변동률 집계: {[f'{x:+.1f}%' for x in self.주간데이터]}")
        print(f"최종 가격: {self.초기가격:.1f}원 → {누적가격:.1f}원 ({((누적가격-self.초기가격)/self.초기가격*100):+.1f}%)")
        
        # 시장 상황 판단을 위한 최종가격 저장
        self.최종가격 = 누적가격
        
        # 시간별 변동률 생성 (7시간 기반)
        self._시간별_변동률_생성()
    
    def _시간별_변동률_생성(self):
        """일간데이터에 맞춰 자연스러운 시간별 변동률 생성"""
        print("\n=== 일간 목표에 맞춘 시간별 변동률 생성 ===")
        
        self.시간데이터 = []
        
        # 각 일간 변동률을 7시간에 현실적으로 분산
        for 일차, 목표일변동 in enumerate(self.일간데이터):
            목표배수 = 1 + 목표일변동/100
            
            # 변동성 패턴 결정
            변동성타입 = self._변동성_패턴_결정(목표일변동)
            
            if 변동성타입 == '급변형':
                # 1-2시간에 큰 변동 집중, 나머지에서 조정
                시간변동들 = self._급변형_시간분산(목표일변동)
            elif 변동성타입 == '롤러코스터':
                # 여러 번 급변동과 회복
                시간변동들 = self._롤러코스터_시간분산(목표일변동)
            else:
                # 기존 안정형 (균등 분산)
                시간변동들 = self._안정형_시간분산(목표일변동)
            
            # 누적 배수 계산
            누적배수 = 1
            for 시간변동 in 시간변동들:
                누적배수 *= (1 + 시간변동/100)
            
            # 7시간째 필요한 변동률 계산
            필요변동 = ((목표배수 / 누적배수) - 1) * 100
            
            # 마지막 시간의 급격한 변동 방지 (±6%로 확대) 및 완전 재분산
            if abs(필요변동) > 6:
                # 마지막 시간을 제한하고 부족분을 모든 시간에 재분산
                if 필요변동 > 6:
                    마지막변동 = 6
                    초과분 = 필요변동 - 6
                else:
                    마지막변동 = -6  
                    초과분 = 필요변동 + 6  # 음수값
                
                # 부족분을 7시간 모두에 균등 분산 (마지막 포함)
                시간변동들.append(마지막변동)
                분산량 = 초과분 / 7
                
                # 모든 시간에 분산량 추가
                for i in range(len(시간변동들)):
                    시간변동들[i] += 분산량
                    # 개별 시간 제한 적용 (±5%로 약간 관대하게)
                    if 시간변동들[i] > 5:
                        초과량 = 시간변동들[i] - 5
                        시간변동들[i] = 5
                        # 초과량을 다른 시간들에 재분산
                        for j in range(len(시간변동들)):
                            if j != i and j < len(시간변동들) and 시간변동들[j] < 5:
                                추가량 = min(초과량 / 7, 5 - 시간변동들[j])
                                시간변동들[j] += 추가량
                                초과량 -= 추가량
                    elif 시간변동들[i] < -5:
                        부족량 = -5 - 시간변동들[i]  # 양수값
                        시간변동들[i] = -5
                        # 부족량을 다른 시간들에 재분산
                        for j in range(len(시간변동들)):
                            if j != i and j < len(시간변동들) and 시간변동들[j] > -5:
                                조정량 = min(부족량 / 7, 시간변동들[j] + 5)
                                시간변동들[j] -= 조정량
                                부족량 -= 조정량
            else:
                # 마지막 시간이 제한 범위 내면 그대로 사용
                시간변동들.append(필요변동)
            
            # 실제 달성률 검증
            실제누적 = 1
            for 변동 in 시간변동들:
                실제누적 *= (1 + 변동/100)
            실제일변동 = (실제누적 - 1) * 100
            
            # 목표와 실제의 차이가 1% 이상이면 경고
            if abs(실제일변동 - 목표일변동) > 1:
                print(f"[경고] 목표 달성 실패: 목표 {목표일변동:+.1f}% vs 실제 {실제일변동:+.1f}% (차이: {abs(실제일변동 - 목표일변동):.1f}%)")
            
            self.시간데이터.extend(시간변동들)
        
        # 검증 및 표시
        print("일간 목표 vs 시간별 실제 결과:")
        print(f"DEBUG: 총 시간데이터 길이: {len(self.시간데이터)}, 일간데이터 길이: {len(self.일간데이터)}")
        print(f"DEBUG: 예상 시간데이터 길이: {len(self.일간데이터) * 7}")
        현재가격 = self.초기가격
        
        for 일차 in range(135):
            주차 = (일차 // 5) + 1
            주내일차 = (일차 % 5) + 1
            
            # 해당 일의 7시간 데이터
            시작인덱스 = 일차 * 7
            끝인덱스 = (일차 + 1) * 7
            일일시간데이터 = self.시간데이터[시작인덱스:끝인덱스]
            
            # 디버그: 빈 데이터 체크
            if len(일일시간데이터) == 0:
                print(f"WARNING: {일차+1}일차 시간데이터 없음 - 시작인덱스:{시작인덱스}, 끝인덱스:{끝인덱스}, 전체데이터길이:{len(self.시간데이터)}")
                continue
            
            # 실제 누적 변동 계산
            일이상가격 = 현재가격
            for 시간변동 in 일일시간데이터:
                일이상가격 = 일이상가격 * (1 + 시간변동/100)
            
            실제일변동 = ((일이상가격 - 현재가격) / 현재가격) * 100
            목표일변동 = self.일간데이터[일차]
            현재가격 = 일이상가격
            
            # 급변동 표시 및 패턴 타입 표시
            if abs(목표일변동) >= 5 and len(일일시간데이터) > 0:
                # 패턴 판별 (시간별 변동의 특성으로)
                최대변동 = max(abs(x) for x in 일일시간데이터)
                변동편차 = sum(abs(x - 실제일변동/len(일일시간데이터)) for x in 일일시간데이터) / len(일일시간데이터)
                
                if 최대변동 > abs(실제일변동) * 0.8 and 변동편차 > 2:
                    패턴타입 = "급변형" if 최대변동 > abs(실제일변동) else "롤러코스터"
                else:
                    패턴타입 = "안정형"
                
                변동표시 = f" [목표: {목표일변동:+.1f}%, {패턴타입}]"
            else:
                변동표시 = ""
            
            print(f"  {주차}주 {주내일차}일: {[f'{x:+.1f}' for x in 일일시간데이터]} → {실제일변동:+.1f}%{변동표시}")
        
        print(f"\n시간별 변동률 생성 완료: {len(self.시간데이터)}개")
        print(f"평균 시간별 변동폭: {sum(abs(x) for x in self.시간데이터) / len(self.시간데이터):.2f}%")
    
    def _거래비용_계산(self, 거래유형, 거래금액):
        """거래비용 계산"""
        if not self.거래비용설정['거래비용반영']:
            return 0
            
        비용 = 0
        설정 = self.거래비용설정
        
        if 거래유형 == '매수':
            비용 += 거래금액 * 설정['매매수수료']  # 수수료
            비용 += 거래금액 * 설정['슬리피지']    # 슬리피지
        elif 거래유형 == '매도':
            비용 += 거래금액 * 설정['매매수수료']  # 수수료
            비용 += 거래금액 * 설정['증권거래세']  # 증권거래세
            비용 += 거래금액 * 설정['농특세']      # 농특세
            비용 += 거래금액 * 설정['슬리피지']    # 슬리피지
            
        return 비용
    
    def _실제매수가_계산(self, 목표가격, 수량):
        """거래비용을 포함한 실제 매수 필요금액 계산"""
        if not self.거래비용설정['거래비용반영']:
            return 목표가격 * 수량
            
        거래금액 = 목표가격 * 수량
        매수비용 = self._거래비용_계산('매수', 거래금액)
        return 거래금액 + 매수비용
    
    def _실제매도금_계산(self, 목표가격, 수량):
        """거래비용을 차감한 실제 매도 수령금액 계산"""
        if not self.거래비용설정['거래비용반영']:
            return 목표가격 * 수량
            
        거래금액 = 목표가격 * 수량  
        매도비용 = self._거래비용_계산('매도', 거래금액)
        return 거래금액 - 매도비용
    
    def _거래비용_요약(self, 전략):
        """전략의 총 거래비용 요약"""
        if not self.거래비용설정['거래비용반영']:
            return {'총거래비용': 0, '거래비용률': 0}
            
        총거래비용 = 0
        거래내역 = 전략.get('거래내역', [])
        
        for 거래타입, 일차, 시간, 가격, 수량 in 거래내역:
            거래금액 = 가격 * 수량
            
            if 거래타입 == '매수':
                비용 = self._거래비용_계산('매수', 거래금액)
            elif 거래타입 in ['매도', '손절', '절반매도', '전량매도', '기간매도'] or '고무줄' in 거래타입:
                비용 = self._거래비용_계산('매도', 거래금액)
            else:
                비용 = 0
                
            총거래비용 += 비용
        
        # 총 투자금액 대비 거래비용 비율
        거래비용률 = (총거래비용 / 100000) * 100
        
        return {
            '총거래비용': 총거래비용,
            '거래비용률': 거래비용률,
            '거래횟수': len(거래내역)
        }
    
    def _변동성_패턴_결정(self, 목표일변동):
        """변동성 패턴 타입 결정"""
        변동폭 = abs(목표일변동)
        
        if 변동폭 >= 8:  # ±8% 이상
            # 70% 확률로 급변형, 20% 롤러코스터, 10% 안정형
            return random.choices(['급변형', '롤러코스터', '안정형'], 
                                weights=[70, 20, 10], k=1)[0]
        elif 변동폭 >= 4:  # ±4~8%
            # 40% 급변형, 30% 롤러코스터, 30% 안정형
            return random.choices(['급변형', '롤러코스터', '안정형'], 
                                weights=[40, 30, 30], k=1)[0]
        else:  # ±4% 미만
            # 10% 급변형, 20% 롤러코스터, 70% 안정형
            return random.choices(['급변형', '롤러코스터', '안정형'], 
                                weights=[10, 20, 70], k=1)[0]
    
    def _안정형_시간분산(self, 목표일변동):
        """기존 안정형 균등 분산 (7시간용)"""
        시간변동들 = []
        for i in range(6):  # 7시간 중 첫 6시간
            변동폭 = min(3.0, abs(목표일변동) * 0.8)
            
            if random.random() < 0.6 and 목표일변동 != 0:
                방향편향 = 1 if 목표일변동 > 0 else -1
                시간변동 = random.uniform(0, 변동폭) * 방향편향
            else:
                시간변동 = random.uniform(-변동폭, 변동폭)
            
            시간변동들.append(시간변동)
        return 시간변동들
    
    def _급변형_시간분산(self, 목표일변동):
        """1-2시간에 큰 변동 집중 (7시간용)"""
        시간변동들 = [0] * 6  # 7시간 중 첫 6시간
        
        # 급변동 시간 선택 (1-2개)
        급변동수 = 1 if abs(목표일변동) < 10 else 2
        급변동시간들 = random.sample(range(6), 급변동수)
        
        # 목표의 120-180%를 급변동 시간에 집중
        집중비율 = random.uniform(1.2, 1.8)
        집중변동 = 목표일변동 * 집중비율
        
        # 급변동 시간에 분배
        for i, 시간인덱스 in enumerate(급변동시간들):
            if 급변동수 == 1:
                시간변동들[시간인덱스] = 집중변동
            else:
                # 2개 시간에 분배 (70:30 또는 60:40)
                비율 = 0.7 if i == 0 else 0.3
                시간변동들[시간인덱스] = 집중변동 * 비율
        
        # 나머지 시간에는 반대 방향으로 조정
        남은시간들 = [i for i in range(6) if i not in 급변동시간들]
        조정필요량 = 집중변동 - 목표일변동  # 초과분
        
        for 시간인덱스 in 남은시간들:
            조정량 = 조정필요량 / len(남은시간들) * -1  # 반대 방향
            # 자연스러운 노이즈 추가
            노이즈 = random.uniform(-1.5, 1.5)
            시간변동들[시간인덱스] = 조정량 + 노이즈
        
        return 시간변동들
    
    def _롤러코스터_시간분산(self, 목표일변동):
        """여러 번 급변동과 회복 패턴"""
        시간변동들 = []
        
        # 목표의 150-250%를 2-3번에 걸쳐 급변동
        총집중비율 = random.uniform(1.5, 2.5)
        변동횟수 = 2 if abs(목표일변동) < 8 else 3
        
        # 급변동 패턴: 상승->하락->상승 또는 하락->상승->하락
        방향 = 1 if 목표일변동 > 0 else -1
        패턴방향들 = []
        
        for i in range(변동횟수):
            if i % 2 == 0:
                패턴방향들.append(방향)  # 목표 방향
            else:
                패턴방향들.append(-방향)  # 반대 방향
        
        # 각 급변동의 크기 결정
        기본크기 = abs(목표일변동) * 총집중비율 / 변동횟수
        
        for i in range(변동횟수):
            크기변동 = random.uniform(0.7, 1.3)  # ±30% 변동
            변동크기 = 기본크기 * 크기변동 * 패턴방향들[i]
            시간변동들.append(변동크기)
        
        # 남은 시간에는 조정 변동 (7시간 중 6시간 기준)
        남은시간수 = 6 - 변동횟수  # 7시간 중 마지막 시간 제외
        총조정필요 = sum(시간변동들) - 목표일변동
        
        for i in range(남은시간수):
            조정량 = 총조정필요 / 남은시간수 * -1
            노이즈 = random.uniform(-1.0, 1.0)
            시간변동들.append(조정량 + 노이즈)
        
        # 순서를 랜덤하게 섞기
        random.shuffle(시간변동들)
        return 시간변동들
    
    def 랜덤_주별_데이터_생성(self, 주수=5):
        """랜덤하게 주별 데이터를 생성"""
        주별데이터 = []
        for _ in range(주수):
            # -10% ~ +10% 범위의 랜덤 주간 변동률
            주변동 = random.uniform(-10, 10)
            주별데이터.append(주변동)
        return 주별데이터
    
    def 계층적_변동률_생성(self, 주별데이터):
        """기존 방식 호환 - 주간 목표 기반 일간 데이터 생성 (특수 시나리오용)"""
        print(f"\n특수 시나리오용 주간 목표 기반 생성")
        
        self.주간데이터 = 주별데이터.copy()
        print(f"주간 변동률: {[f'{x:+.1f}%' for x in self.주간데이터]}")
        
        # 일간 변동률 생성 (5일 복리 계산이 주 변동률과 같게)
        self.일간데이터 = []
        
        for 주변동 in self.주간데이터:
            목표배수 = 1 + 주변동/100
            
            # 랜덤 일간 변동 생성
            일변동들 = []
            for i in range(4):  # 처음 4일은 랜덤
                일변동 = random.uniform(-6, 6)  # 범위 약간 줄임
                일변동들.append(일변동)
            
            # 마지막 날은 목표에 맞춰 계산 (기존 로직)
            누적배수 = 1
            for 일변동 in 일변동들:
                누적배수 *= (1 + 일변동/100)
            
            필요변동 = ((목표배수 / 누적배수) - 1) * 100
            
            # 극단값 제한을 좀 더 관대하게
            if 필요변동 < -12:
                필요변동 = -12
            elif 필요변동 > 12:
                필요변동 = 12
            
            일변동들.append(필요변동)
            
            # 검증
            실제누적 = 1
            for 일변동 in 일변동들:
                실제누적 *= (1 + 일변동/100)
            실제주변동 = (실제누적 - 1) * 100
            
            print(f"  주 {주변동:+.1f}% → 일간: {[f'{x:+.1f}' for x in 일변동들]} → 실제: {실제주변동:+.1f}%")
            
            self.일간데이터.extend(일변동들)
        
        print(f"일간 변동률 생성 완료: {len(self.일간데이터)}개")
        
        # 시간별 변동률 생성 (6시간 복리 계산이 일 변동률과 같게)
        self.시간데이터 = []
        
        for 일변동 in self.일간데이터:
            # 목표: 6시간의 복리 변동이 일변동과 같도록
            목표배수 = 1 + 일변동/100
            
            # 랜덤 시간 변동 생성 (목표 지향적)
            시간변동들 = []
            for i in range(5):  # 처음 5시간은 랜덤
                # 목표에 따라 변동 범위 조정
                if abs(일변동) > 5:
                    시간변동 = random.uniform(-4, 4)  # 큰 목표일 때 더 큰 범위
                else:
                    시간변동 = random.uniform(-3, 3)  # 기본 범위 확대
                시간변동들.append(시간변동)
            
            # 마지막 시간은 목표에 맞춰 계산
            누적배수 = 1
            for 시간변동 in 시간변동들:
                누적배수 *= (1 + 시간변동/100)
            
            # 6시간째 필요한 변동률 계산
            필요변동 = ((목표배수 / 누적배수) - 1) * 100
            
            # 마지막 시간의 급격한 변동 방지 (±4% 제한) 및 재분산
            if abs(필요변동) > 4:
                # 마지막 시간을 제한하고 부족분을 모든 시간에 재분산
                if 필요변동 > 4:
                    마지막변동 = 4
                    초과분 = 필요변동 - 4
                else:
                    마지막변동 = -4  
                    초과분 = 필요변동 + 4  # 음수값
                
                # 부족분을 6시간 모두에 균등 분산 (마지막 포함)
                시간변동들.append(마지막변동)
                분산량 = 초과분 / 6
                
                # 모든 시간에 분산량 추가
                for i in range(len(시간변동들)):
                    시간변동들[i] += 분산량
                    # 개별 시간 제한 적용 (±5%로 약간 관대하게)
                    if 시간변동들[i] > 5:
                        초과량 = 시간변동들[i] - 5
                        시간변동들[i] = 5
                        # 초과량을 다른 시간들에 재분산 (6시간 기준)
                        for j in range(len(시간변동들)):
                            if j != i and j < len(시간변동들) and 시간변동들[j] < 5:
                                추가량 = min(초과량 / 6, 5 - 시간변동들[j])
                                시간변동들[j] += 추가량
                                초과량 -= 추가량
                    elif 시간변동들[i] < -5:
                        부족량 = -5 - 시간변동들[i]  # 양수값
                        시간변동들[i] = -5
                        # 부족량을 다른 시간들에 재분산 (6시간 기준)
                        for j in range(len(시간변동들)):
                            if j != i and j < len(시간변동들) and 시간변동들[j] > -5:
                                조정량 = min(부족량 / 6, 시간변동들[j] + 5)
                                시간변동들[j] -= 조정량
                                부족량 -= 조정량
            else:
                # 마지막 시간이 제한 범위 내면 그대로 사용
                시간변동들.append(필요변동)
            
            self.시간데이터.extend(시간변동들)
        
        # 검증 출력
        print(f"\n검증: 첫째 주 첫날 시간별 변동")
        첫날시간 = self.시간데이터[:6]
        누적 = 100
        for i, 변동 in enumerate(첫날시간):
            누적 = 누적 * (1 + 변동/100)
            # 소수점 1자리까지만 표시 (버림)
            누적 = int(누적 * 10) / 10
            print(f"  {i+1}시간: {변동:+.2f}% → 가격: {누적:.1f}")
        
        첫날변동 = ((누적 - 100) / 100) * 100
        print(f"  첫날 총 변동: {첫날변동:+.1f}% (목표: {self.일간데이터[0]:+.1f}%)")
        
        print(f"\n시간별 변동률 생성 완료: {len(self.시간데이터)}개")
        print()
    
    def 전략_비교_시뮬레이션(self):
        """다양한 전략을 자동 비교하며 점진적 필터링"""
        print(f"\n=== 전략 비교 시뮬레이션 ===")
        print(f"초기 주식 가격: {self.초기가격}원")
        print("="*60)
        
        # 기존 탈락 전략 로드
        탈락전략목록 = self._탈락전략_로드()
        
        # 다양한 전략 조합 생성 (탈락 전략 제외)
        전략조합 = self._전략조합_생성(탈락전략목록)
        print(f"\n실제 시뮬레이션 투입: {len(전략조합)}개 전략")
        
        # 탈락 전략 통계 출력 (한 번만)
        영구제외수 = len(탈락전략목록.get('영구제외', [])) if isinstance(탈락전략목록, dict) else len(탈락전략목록) if 탈락전략목록 else 0
        임시탈락수 = len(탈락전략목록.get('임시기록', {})) if isinstance(탈락전략목록, dict) else 0
        
        if 영구제외수 > 0 or 임시탈락수 > 0:
            # 5회 탈락 통계 계산
            오회탈락수 = 0
            for 기록 in 탈락전략목록.get('영구제외', []):
                if 기록.get('탈락횟수', 0) == 5:
                    오회탈락수 += 1
            
            print(f"탈락 전략 현황:")
            print(f"  5회+ 탈락: {영구제외수}개")
            print(f"  임시탈락: {임시탈락수}개")
        
        # 일별 점진적 필터링
        생존전략 = 전략조합.copy()
        탈락기록 = []
        
        for 일차 in range(135):  # 27주 = 135일
            주차 = (일차 // 5) + 1
            주내일차 = (일차 % 5) + 1
            
            # 주간 단위로만 출력 (매주 월요일 = 주내일차 1일 때)
            if 주내일차 == 1:
                print(f"\n{'='*60}")
                print(f"{주차}주차 시뮬레이션 시작")
                print(f"현재 생존 전략: {len(생존전략)}개")
            
            # 각 전략별 시뮬레이션 실행
            일일결과 = []
            for 전략 in 생존전략:
                결과 = self._일일_시뮬레이션(전략, 일차)
                일일결과.append(결과)
            
            # 성과 기준 정렬 (총수익률 기준)
            일일결과.sort(key=lambda x: x['수익률'], reverse=True)
            
            # 자산 기준 탈락: 평가자산이 60,000원(60%) 이하인 전략 탈락 (40% 손실)
            # 옐로우카드 시스템 (점진적 경고 방식)
            생존전략 = []
            탈락자 = []
            옐로우카드발급 = []
            
            # 주차별 체크 (매주 금요일: 4, 9, 14, 19, 24, 29...)
            주차 = (일차 // 5) + 1
            
            for 결과 in 일일결과:
                전략 = 결과['전략']
                현재평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                현재수익률 = ((현재평가자산 - 100000) / 100000) * 100
                
                # 개선된 옐로우카드 관리 (매주 체크, 12개 누적시 탈락)
                # 옐로우카드는 전략 생성시 이미 복원됨
                if '옐로우카드' not in 전략:
                    전략['옐로우카드'] = {'개수': 0, '마지막카드주차': 0}  # 새 전략인 경우만
                
                # 주차별 수익률 요구사항 체크 - 주차가 바뀔 때마다
                if 주차 > 전략['옐로우카드']['마지막카드주차']:
                    # 주차별 요구 수익률 계산 (1주차: 0%, 2주차: 1%, 3주차: 2%, ...)
                    요구수익률 = max(0, (주차 - 1))  # 2주차부터 1%씩 증가
                    
                    # 기존 -5% 조건과 주차별 요구사항 모두 체크
                    카드발급사유 = []
                    if 현재수익률 <= -5:  # 기존 -5% 기준
                        카드발급사유.append(f"-5%손실")
                    if 주차 >= 2 and 현재수익률 < 요구수익률:  # 주차별 요구사항
                        카드발급사유.append(f"{주차}주차 {요구수익률}% 미달({현재수익률:.1f}%)")
                    
                    if 카드발급사유:
                        전략['옐로우카드']['개수'] += len(카드발급사유)  # 여러 사유시 여러 카드
                        전략['옐로우카드']['마지막카드주차'] = 주차
                        옐로우카드발급.append({
                            '전략': 전략, 
                            '주차': 주차, 
                            '수익률': 현재수익률, 
                            '카드개수': 전략['옐로우카드']['개수'],
                            '사유': ' + '.join(카드발급사유)
                        })
                
                # 개선된 탈락 판정: 옐로우카드 12개 OR 극심한 손실 (50% 이하)
                if 전략['옐로우카드']['개수'] >= 12:
                    탈락자.append(전략)
                elif 현재수익률 <= -30:  # -30% 이하 = 극심한 손실로 즉시 탈락
                    탈락자.append(전략)  
                else:
                    생존전략.append(전략)
            
            # 매일 간단한 진행상황 출력 (성능 최적화)
            # dict는 set에 넣을 수 없으므로 id 기반으로 최적화
            생존전략_ids = {id(전략) for 전략 in 생존전략}
            생존전략수익률 = [결과['수익률'] for 결과 in 일일결과 if id(결과['전략']) in 생존전략_ids]
            평균수익률 = sum(생존전략수익률)/len(생존전략수익률) if 생존전략수익률 else 0
            print(f"{일차+1}일차: 생존 {len(생존전략):,}개 전략 (평균 누적수익률 {평균수익률:+.1f}%)")
            
            # 상태 출력 (간단히) - 생존 정보 이후에 표시
            if 옐로우카드발급:
                print(f"   [!!] 옐로우카드 {len(옐로우카드발급)}개")
            
            # 탈락 출력 (옐로우카드 이후에 표시)
            # 생존전략 기준 옐로우카드 현황 확인
            최대옐로우카드 = max([전략['옐로우카드']['개수'] for 전략 in 생존전략]) if 생존전략 else 0

            if 탈락자:
                옐로우탈락 = sum(1 for t in 탈락자 if t['옐로우카드']['개수'] >= 12)
                극심탈락 = len(탈락자) - 옐로우탈락
                print(f"   탈락: {len(탈락자)}개")

            # 탈락 기록 (모든 탈락자 저장)
            for 전략 in 탈락자:
                # 탈락 횟수 누적
                if '탈락횟수' not in 전략:
                    전략['탈락횟수'] = 0  
                전략['탈락횟수'] += 1
                
                # 실시간 영구 제외 조건 확인 및 저장
                self._실시간_영구제외_확인(전략, 일차+1)
                
                # 극심손실 체크 및 영구제외 처리
                현재가격 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
                평가자산 = 전략['자본'] + 전략['주식수'] * 현재가격
                수익률 = ((평가자산 - 100000) / 100000) * 100
                
                if 수익률 <= -30.0:
                    탈락사유 = "극심한손실(-30%)"
                    self._극심손실_영구제외_처리(전략, 수익률, 일차+1)
                elif 전략['옐로우카드']['개수'] >= 12:
                    탈락사유 = "옐로우카드12개(12주부진)"
                else:
                    # 예상치 못한 탈락 조건 - 로그 기록
                    탈락사유 = "기타탈락조건"
                    print(f"   ⚠️ 예상치 못한 탈락: 수익률={수익률:.1f}%, 옐로우카드={전략['옐로우카드']['개수']}개")
                
                # 탈락 기록 저장 (배열 형태로 직접 저장)
                매수전략타입 = 전략.get('매수기준', 'Unknown')
                매수하락률 = 전략.get('매수하락률', 0.0)
                구매방식 = int(전략.get('구매방식', '1'))
                
                # 매수수량 처리
                if isinstance(전략.get('매수수량'), dict):
                    매수수량 = 전략['매수수량']['수량']
                    if 구매방식 == 1 and 매수수량 > 1:  # 퍼센트를 소수로 변환
                        매수수량 = 매수수량 / 100
                else:
                    매수수량 = 전략.get('매수수량', 0.5)
                    if 구매방식 == 1 and 매수수량 > 1:
                        매수수량 = 매수수량 / 100
                
                손절라인 = 전략.get('손절라인', 0.0)
                매도타입 = 전략.get('매도전략', '1')
                if isinstance(매도타입, str) and '일괄' in 매도타입:
                    매도타입 = 1
                elif isinstance(매도타입, str):
                    매도타입 = 1  # 기본값
                
                매도파라미터 = str(전략.get('수익라인', 0.0))
                
                탈락기록.append([
                    매수전략타입,
                    매수하락률, 
                    구매방식,
                    매수수량,
                    손절라인,
                    매도타입,
                    매도파라미터,
                    1  # 탈락횟수
                ])
            
            # 극심탈락자 수가 적을 때만 상세 출력
            극심탈락자 = [t for t in 탈락자 if t['옐로우카드']['개수'] < 12]
            if 극심탈락자 and len(극심탈락자) <= 3:
                self._일일결과_출력(일일결과, 일차)
                
                # 생존 전략 중 상위 2개 표시 (최적화된 버전)
                try:
                    print(f"\n생존 전략 중 상위 2개 누적 통계:")
                    
                    # 생존전략에서 직접 수익률 계산하여 상위 2개 선택 (O(n log n) - 훨씬 효율적)
                    def 수익률_계산(전략):
                        try:
                            현재가 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
                            평가자산 = 전략['자본'] + 전략['주식수'] * 현재가
                            return ((평가자산 - 100000) / 100000) * 100
                        except:
                            return -100
                    
                    # 생존전략 중 상위 2개 선택
                    상위전략들 = sorted(생존전략, key=수익률_계산, reverse=True)[:2]
                    
                    for i, 전략 in enumerate(상위전략들):
                        try:
                            총거래내역 = 전략['거래내역']
                            총매수 = len([t for t in 총거래내역 if t[0] == '매수'])
                            총매도 = len([t for t in 총거래내역 if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '트레일링스탑', '기간매도'] or '고무줄' in t[0]])
                            총손절 = len([t for t in 총거래내역 if t[0] == '손절'])
                            
                            전략설명 = self._전략설명_생성(전략)
                            현재가 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
                            평가자산 = 전략['자본'] + 전략['주식수'] * 현재가
                            수익률 = 수익률_계산(전략)
                            보유상태 = f"보유{전략['주식수']:.1f}주@{현재가:.1f}원" if 전략['주식수'] > 0 else "현금상태"
                            
                            print(f"{i+1}. [{전략설명}] (매수{총매수} 매도{총매도} 손절{총손절})")
                            print(f"   총수익률: {수익률:+.1f}%, 평가자산{평가자산:,.0f}원, {보유상태}")
                        except Exception as e:
                            print(f"{i+1}. [전략정보 오류] (매수? 매도? 손절?) - 오류: {e}")
                    print()
                except Exception as e:
                    print(f"\n생존 전략 출력 오류: {e}")
                    print()
            
            # 생존 전략이 5개 이하면 종료
            if len(생존전략) <= 5:
                print(f"\n최종 {len(생존전략)}개 전략만 남음. 시뮬레이션 종료")
                break
            
            # 주간 요약 출력
            if 일차 < 134 and (일차 % 5 == 4):  # 금요일
                주차 = (일차 // 5) + 1
                print(f"\n{주차}주차 요약")
                print(f"   생존 전략: {len(생존전략)}개")
                if 탈락기록:
                    print(f"   탈락: {len(탈락기록)}개")
        
        # 모든 탈락 전략을 누적 횟수 기반으로 저장
        if 탈락기록:
            self._탈락전략_저장(탈락기록)
            print(f"\n탈락 기록 저장 완료: {len(탈락기록)}개")
            print(f"   (누적 5회 탈락시 영구 제외, 극심손실은 즉시 영구 제외)")
        else:
            print(f"\n모든 전략이 생존했습니다. 탈락 없음.")
        
        # 최종 결과 분석 및 최고 전략 저장
        최고전략 = self._최종결과_분석(생존전략, 탈락기록)
        
        # 결과 반환 (5사이클용)
        return {
            '생존전략': 생존전략,
            '탈락기록': 탈락기록,
            '최고전략': 최고전략
        }
    
    def 전략_비교_시뮬레이션_조용함(self):
        """5사이클 시뮬레이션 (중복 출력 방지)"""
        # 탈락 전략이 이미 로드되어 있으면 재사용, 없으면 로드
        if not hasattr(self, '_cached_탈락전략목록'):
            self._cached_탈락전략목록 = self._탈락전략_로드()
        탈락전략목록 = self._cached_탈락전략목록
        
        # 전략 조합 생성 (탈락 전략 제외)
        전략조합 = self._전략조합_생성(탈락전략목록)
        
        생존전략 = 전략조합.copy()
        탈락기록 = []
        
        # 135일간 시뮬레이션 (조용히)
        for 일차 in range(135):
            if len(생존전략) <= 5:
                break
                
            # 일일 시뮬레이션 실행 (출력 없음)
            일일결과 = []
            for i, 전략 in enumerate(생존전략):
                결과 = self._일일_시뮬레이션(전략, 일차)
                일일결과.append(결과)
            
            # 옐로우카드 및 탈락 체크
            생존전략 = []
            탈락자 = []
            주차 = (일차 // 5) + 1
            
            for 결과 in 일일결과:
                전략 = 결과['전략']
                현재평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                현재수익률 = ((현재평가자산 - 100000) / 100000) * 100
                
                # 옐로우카드 관리 (전략 생성시 이미 복원됨)
                if '옐로우카드' not in 전략:
                    전략['옐로우카드'] = {'개수': 0, '마지막음성주차': 0}  # 새 전략인 경우만
                
                # 6주 단위 체크
                if 주차 % 6 == 0 and 주차 > 전략['옐로우카드']['마지막음성주차']:
                    if 현재수익률 <= -5:
                        전략['옐로우카드']['개수'] += 1
                        전략['옐로우카드']['마지막음성주차'] = 주차
                
                # 탈락 판정
                if 전략['옐로우카드']['개수'] >= 2:
                    탈락자.append(전략)
                elif 현재평가자산 <= 50000:
                    탈락자.append(전략)
                else:
                    생존전략.append(전략)
            
            # 탈락 기록 저장
            for 전략 in 탈락자:
                # 탈락 횟수 누적
                # 탈락 횟수 증가 (전략 생성시 이미 복원됨)
                if '탈락횟수' not in 전략:
                    전략['탈락횟수'] = 0  # 새 전략인 경우만 0으로 초기화
                전략['탈락횟수'] += 1
                
                # 실시간 영구 제외 조건 확인 및 저장
                self._실시간_영구제외_확인(전략, 일차+1)
                
                # 극심손실 체크 및 영구제외 처리
                현재가격 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
                평가자산 = 전략['자본'] + 전략['주식수'] * 현재가격
                수익률 = ((평가자산 - 100000) / 100000) * 100
                
                if 수익률 <= -30.0:
                    탈락사유 = "극심한손실(-30%)"
                    # 극심손실인 경우 영구제외 처리 (시장 상황별)
                    self._극심손실_영구제외_처리(전략, 수익률, 일차+1)
                elif 전략['옐로우카드']['개수'] >= 12:
                    탈락사유 = "옐로우카드12개(12주부진)"
                else:
                    # 예상치 못한 탈락 조건 - 로그 기록
                    탈락사유 = "기타탈락조건"
                    print(f"   ⚠️ 예상치 못한 탈락: 수익률={수익률:.1f}%, 옐로우카드={전략['옐로우카드']['개수']}개")
                # 탈락 기록 저장 (배열 형태로 직접 저장)
                매수전략타입 = 전략.get('매수기준', 'Unknown')
                매수하락률 = 전략.get('매수하락률', 0.0)
                구매방식 = int(전략.get('구매방식', '1'))
                
                # 매수수량 처리
                if isinstance(전략.get('매수수량'), dict):
                    매수수량 = 전략['매수수량']['수량']
                    if 구매방식 == 1 and 매수수량 > 1:  # 퍼센트를 소수로 변환
                        매수수량 = 매수수량 / 100
                else:
                    매수수량 = 전략.get('매수수량', 0.5)
                    if 구매방식 == 1 and 매수수량 > 1:
                        매수수량 = 매수수량 / 100
                
                손절라인 = 전략.get('손절라인', 0.0)
                매도타입 = 전략.get('매도전략', '1')
                if isinstance(매도타입, str) and '일괄' in 매도타입:
                    매도타입 = 1
                elif isinstance(매도타입, str):
                    매도타입 = 1  # 기본값
                
                매도파라미터 = str(전략.get('수익라인', 0.0))
                
                탈락기록.append([
                    매수전략타입,
                    매수하락률, 
                    구매방식,
                    매수수량,
                    손절라인,
                    매도타입,
                    매도파라미터,
                    전략.get('탈락횟수', 1)  # 누적 탈락횟수 사용
                ])
        
        # 탈락 전략 저장
        if 탈락기록:
            self._탈락전략_저장(탈락기록)
        
        # 최고전략 분석
        최고전략 = None
        if 생존전략:
            최고전략 = max(생존전략, key=lambda x: ((x['자본'] + x['주식수'] * (x['이동평균'][-1] if x['이동평균'] else self.초기가격)) - 100000) / 100000 * 100)
            if 최고전략:
                self._최고전략_히스토리_저장(생존전략, '5사이클자동')
        
        return {
            '생존전략': 생존전략,
            '탈락기록': 탈락기록,
            '최고전략': 최고전략
        }
        
        # 시장 상황 분석 및 전략 성과 저장
        try:
            현재상황 = self.시장상황_분석()
            print(f"\n시장 상황 분석 결과:")
            print(f"   시장 체제: {현재상황['market_regime']}")
            print(f"   변동성: {현재상황['volatility_pattern']}")
            print(f"   추세: {현재상황['trend_pattern']}")
            print(f"   모멘텀: {현재상황['price_momentum']}")
        except AttributeError:
            print(f"\n시장 상황 분석을 건너뜁니다 (메소드 오류)")
            현재상황 = {
                'market_regime': '분석불가',
                'volatility_pattern': '분석불가',
                'trend_pattern': '분석불가',
                'price_momentum': '분석불가'
            }
        
        # 생존 전략들을 저장 형식으로 변환 (전략 설명 추가)
        저장용전략들 = []
        for 전략 in 생존전략:
            평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            수익률 = ((평가자산 - 100000) / 100000) * 100
            거래횟수 = len(전략['거래내역'])
            
            저장용전략들.append({
                '전략설명': self._전략설명_생성(전략),
                '수익률': 수익률,
                '거래횟수': 거래횟수,
                '최종자산': 평가자산,
                '전략상세': {
                    '매수기준': 전략.get('매수기준명', ''),
                    '매수하락률': 전략.get('매수하락률', 0),
                    '구매방식': 전략.get('구매방식명', ''),
                    '손절라인': 전략.get('손절라인', 0),
                    '매도전략': 전략.get('매도전략명', '')
                }
            })
        
        # 전략 성과를 상황별로 저장
        self.전략성과_저장(현재상황, 저장용전략들)
        
        # 유사 상황의 과거 전략 추천
        print(f"\n유사 상황 기반 전략 추천:")
        추천전략들 = self.유사상황_전략추천(현재상황)
        
        # 최고 성과 전략 히스토리에 저장 (기존 로직 유지)
        if 최고전략:
            self._최고전략_히스토리_저장([최고전략], '일반시뮬레이션')
        
        # 최종 검증 제안
        if len(생존전략) <= 10:
            print(f"\n2단계 극한 검증을 실행하시겠습니까?")
            print(f"현재 {len(생존전략)}개 후보 전략을 다양한 극한 환경에서 테스트합니다.")
            극한검증 = input("극한 검증 실행? (y/n): ")
            if 극한검증.lower() == 'y':
                self._극한검증_시뮬레이션(생존전략)
    
    def _탈락전략_로드(self):
        """신버전 압축 탈락 기록 로드 (신버전 전용)"""
        # 캐싱: 이미 로드했으면 재사용
        if hasattr(self, '_cached_탈락전략_데이터'):
            return self._cached_탈락전략_데이터
            
        압축파일경로 = self.탈락전략_파일.replace('.json', '_압축.json')
        
        # 압축 파일 로드
        if os.path.exists(압축파일경로):
            결과 = self._압축된_탈락전략_로드(압축파일경로)
            self._cached_탈락전략_데이터 = 결과
            return 결과
        
        # 파일이 없으면 빈 구조 반환
        print(f"탈락전략 압축파일이 없습니다: {압축파일경로}")
        print("새로운 시뮬레이션으로 빈 탈락전략으로 시작합니다.")
        결과 = {'영구제외': [], '임시기록': {}}
        self._cached_탈락전략_데이터 = 결과
        return 결과
    
    def _압축된_탈락전략_로드(self, 압축파일경로):
        """신버전 3.0 압축 탈락전략 로드 (신버전 전용)"""
        try:
            with open(압축파일경로, 'r', encoding='utf-8') as f:
                압축데이터 = json.load(f)
            
            # 신버전 데이터 구조 확인
            if 'strategies' not in 압축데이터:
                print("신버전 압축 데이터 형식 오류: strategies 키 없음")
                return {'영구제외': [], '임시기록': {}}
            
            전략들 = 압축데이터.get('strategies', [])
            버전 = 압축데이터.get('version', '3.0')
            
            # 신버전이 아니면 경고
            if 버전 != '3.0':
                print(f"경고: 구버전 파일 감지 ({버전}). 신버전 3.0 전용 시스템입니다.")
                print("파일을 다시 생성하세요.")
                return {'영구제외': [], '임시기록': {}}
            
            영구제외 = []
            임시탈락기록 = {}
            
            for 전략배열 in 전략들:
                # 신버전: [매수전략타입, 매수하락률, 구매방식, 매수수량, 손절라인, 매도타입, 매도파라미터, 탈락횟수]
                if len(전략배열) < 8:
                    continue
                
                매수전략타입 = 전략배열[0]
                매수하락률 = 전략배열[1]
                구매방식 = 전략배열[2]
                매수수량 = 전략배열[3]
                손절라인 = 전략배열[4]
                매도타입 = 전략배열[5]
                매도파라미터 = 전략배열[6]
                탈락횟수 = 전략배열[7]
                
                # 신버전 키 생성
                속성키 = f"{매수전략타입}_{매수하락률:.1f}_{구매방식}_{매수수량}_{손절라인}_{매도타입}_{매도파라미터}"
                
                전략정보 = {
                    '매수전략타입': 매수전략타입,
                    '매수하락률': 매수하락률,
                    '구매방식': 구매방식,
                    '매수수량': 매수수량,
                    '손절라인': 손절라인,
                    '매도타입': 매도타입,
                    '매도파라미터': 매도파라미터,
                    '탈락횟수': 탈락횟수
                }
                
                if 탈락횟수 >= 5:
                    영구제외.append(전략정보)
                else:
                    임시탈락기록[속성키] = 전략정보
            
            return {'영구제외': 영구제외, '임시기록': 임시탈락기록}
            
        except Exception as e:
            print(f"신버전 압축 탈락전략 로드 실패: {e}")
            return {'영구제외': [], '임시기록': {}}
    
    def _신버전_압축파일_업데이트(self, 전체탈락기록):
        """신버전 3.0 압축파일을 업데이트 - 배열 직접 저장"""
        try:
            압축파일경로 = self.탈락전략_파일.replace('.json', '_압축.json')
            
            # 기존 압축 데이터 로드
            압축데이터 = {
                "version": "3.0",
                "description": "매수전략타입 포함 신버전 탈락전략 데이터",
                "structure": ["매수전략타입", "매수하락률", "구매방식", "매수수량", "손절라인", "매도타입", "매도파라미터", "탈락횟수"],
                "매도타입_맵": {
                    "1": "일괄", "2": "적극고무줄", "3": "대기고무줄", 
                    "4": "급진고무줄", "5": "일존버"
                },
                "strategies": []
            }
            
            if os.path.exists(압축파일경로):
                try:
                    with open(압축파일경로, 'r', encoding='utf-8') as f:
                        기존데이터 = json.load(f)
                        압축데이터["strategies"] = 기존데이터.get("strategies", [])
                except:
                    pass  # 기존 파일 오류시 새로 시작
            
            # 새로운 탈락 기록 추가 (이미 배열 형태)
            for 기록 in 전체탈락기록:
                if isinstance(기록, list) and len(기록) >= 8:
                    # 중복 확인
                    중복 = False
                    for 기존기록 in 압축데이터["strategies"]:
                        if (기존기록[0] == 기록[0] and  # 매수전략타입
                            기존기록[1] == 기록[1] and  # 매수하락률
                            기존기록[2] == 기록[2] and  # 구매방식
                            기존기록[3] == 기록[3] and  # 매수수량
                            기존기록[4] == 기록[4] and  # 손절라인
                            기존기록[5] == 기록[5] and  # 매도타입
                            기존기록[6] == 기록[6]):    # 매도파라미터
                            # 탈락횟수 증가
                            기존기록[7] = 기존기록[7] + 기록[7]
                            중복 = True
                            break
                    
                    if not 중복:
                        압축데이터["strategies"].append(기록)
            
            # 압축파일 저장
            with open(압축파일경로, 'w', encoding='utf-8') as f:
                json.dump(압축데이터, f, ensure_ascii=False, separators=(',', ':'))
                
            print(f"   신버전 압축파일 업데이트: {len(압축데이터['strategies'])}개 전략")
            
        except Exception as e:
            print(f"신버전 압축파일 업데이트 실패: {e}")
    
    def _탈락전략_저장(self, 새탈락전략_정보):
        """배열 형태 탈락전략 직접 저장"""
        # 배열 형태로 직접 압축파일에 저장
        self._신버전_압축파일_업데이트(새탈락전략_정보)
        print(f"탈락 전략 {len(새탈락전략_정보)}개 저장 완료 (배열 형태)")
    
    def _전략을_키로_변환(self, 전략):
        """전략을 고유 키로 변환 (임시탈락기록과 호환되는 속성 기반 키 생성)"""
        # 최적화된 구조: strategy_key 직접 사용
        if 'strategy_key' in 전략:
            return 전략['strategy_key']
        
        # 속성 기반 키 생성 (임시탈락기록 형식과 일치: "구매방식_매수수량_손절라인_매도타입_매도파라미터")
        try:
            # 전략 속성 추출
            전략속성 = self._전략을_속성으로_변환(전략)
            if not 전략속성:
                return f"UNKNOWN_{id(전략)}"
            
            구매방식 = 전략속성.get('구매방식', 1)
            매수수량 = 전략속성.get('매수수량', 0)
            손절라인 = 전략속성.get('손절라인', 0)
            수익라인 = 전략속성.get('수익라인', 0)
            
            # 매도전략 타입 결정
            매도전략 = 전략.get('매도전략', '2')
            if isinstance(매도전략, dict):
                매도타입 = 매도전략.get('전략', '2')
            else:
                매도타입 = str(매도전략)
            
            # 매도 파라미터 결정
            if 매도타입 == '2':  # 일괄매도
                매도파라미터 = str(수익라인)
            elif 매도타입 == '4':  # 고무줄매도
                매도파라미터 = f"{수익라인},2.0"  # 기본 단계 2.0
            else:
                매도파라미터 = str(수익라인)
            
            # 매수전략타입 추가 (핵심 수정!)
            매수전략타입 = 전략.get('매수기준명', 'Unknown')  # 텍스트 이름 사용
            매수하락률 = 전략.get('매수하락률', 0.0)
            
            # 새로운 고유 키 생성: "매수전략타입_매수하락률_구매방식_매수수량_손절라인_매도타입_매도파라미터"
            키 = f"{매수전략타입}_{매수하락률:.1f}_{구매방식}_{매수수량}_{손절라인}_{매도타입}_{매도파라미터}"
            return 키
            
        except Exception as e:
            # 오류 발생시 기본 키 반환
            return f"UNKNOWN_{id(전략)}"
    
    def _전략을_속성으로_변환(self, 전략):
        """전략을 속성 기반 검색을 위한 속성 딕셔너리로 변환"""
        try:
            # 구매방식 변환 - 다양한 구조 지원
            if '매수수량' in 전략 and isinstance(전략['매수수량'], dict):
                # 딕셔너리 형태: {'방식': '1', '수량': 0.5} (이미 소수점 형태)
                if 전략['매수수량']['방식'] == '1':
                    구매방식 = 1  # 퍼센트 방식
                    매수수량 = 전략['매수수량']['수량']  # 이미 소수점 형태이므로 그대로 사용
                else:
                    구매방식 = 2  # 고정주식수 방식
                    매수수량 = 전략['매수수량']['수량']
            elif '구매방식' in 전략 and '매수수량' in 전략:
                # 분리된 형태: '구매방식': '1', '매수수량': 50 (정수 퍼센트) 또는 0.5 (소수점 형태)
                구매방식 = int(전략['구매방식'])
                if 구매방식 == 1:
                    # 값이 1보다 크면 정수 퍼센트 (50 → 0.5), 작으면 이미 소수점 (0.5 → 0.5)
                    if 전략['매수수량'] > 1:
                        매수수량 = 전략['매수수량'] / 100  # 정수 퍼센트를 소수로
                    else:
                        매수수량 = 전략['매수수량']  # 이미 소수점 형태
                else:
                    매수수량 = 전략['매수수량']
            else:
                return None
            
            # 손절라인
            손절라인 = 전략['손절라인']
            
            # 수익라인 (매도전략에 따라)
            수익라인 = 전략.get('수익라인', 0)  # 직접 수익라인 사용
            
            # 수익라인이 없으면 매도전략에서 추출 시도
            if 수익라인 == 0:
                매도전략 = 전략.get('매도전략', '')
                if isinstance(매도전략, str):
                    if '일괄' in 매도전략:
                        # "일괄4.5%" 형태에서 숫자 추출
                        import re
                        수익률매치 = re.search(r'일괄(\d+\.?\d*)%', 매도전략)
                        if 수익률매치:
                            수익라인 = float(수익률매치.group(1))
                    elif '고무줄' in 매도전략:
                        # 고무줄 전략의 시작 수익률 추출 시도
                        수익률매치 = re.search(r'(\d+\.?\d*)%', 매도전략)
                        if 수익률매치:
                            수익라인 = float(수익률매치.group(1))
            
            # 매수전략타입과 매수하락률 추가 (핵심 수정!)
            매수전략타입 = 전략.get('매수기준', 'Unknown')
            매수하락률 = 전략.get('매수하락률', 0.0)
            
            return {
                '매수전략타입': 매수전략타입,
                '매수하락률': 매수하락률,
                '구매방식': 구매방식,
                '매수수량': 매수수량,
                '손절라인': 손절라인,
                '수익라인': 수익라인
            }
        except Exception as e:
            return None
    
    def _전략배열_일치확인(self, 배열1, 배열2, 허용오차=0.01):
        """두 전략 배열이 일치하는지 확인 (부동소수점 오차 허용) - 성능 최적화"""
        if not 배열1 or not 배열2 or len(배열1) < 7 or len(배열2) < 7:
            return False
        
        # 배열 직접 비교 (탈락횟수 제외한 처음 7개 요소)
        try:
            # 문자열 비교
            if 배열1[0] != 배열2[0]:  # 매수전략타입
                return False
            
            # 숫자 비교 (부동소수점 오차 허용)
            if abs(float(배열1[1]) - float(배열2[1])) > 허용오차:  # 매수하락률
                return False
            if 배열1[2] != 배열2[2]:  # 구매방식
                return False
            if abs(float(배열1[3]) - float(배열2[3])) > 허용오차:  # 매수수량
                return False
            if abs(float(배열1[4]) - float(배열2[4])) > 허용오차:  # 손절라인
                return False
            if 배열1[5] != 배열2[5]:  # 매도타입
                return False
            if str(배열1[6]) != str(배열2[6]):  # 매도파라미터
                return False
                
            return True
        except (ValueError, IndexError):
            return False

    def _전략속성_일치확인(self, 전략속성1, 전략속성2, 허용오차=0.01):
        """두 전략의 속성이 일치하는지 확인 (부동소수점 오차 허용) - 레거시 호환"""
        if not 전략속성1 or not 전략속성2:
            return False
            
        # 매수전략타입과 구매방식은 정확히 일치해야 함 (핵심 수정!)
        if 전략속성1.get('매수전략타입') != 전략속성2.get('매수전략타입'):
            return False
        if 전략속성1.get('구매방식') != 전략속성2.get('구매방식'):
            return False
        
        # 매수하락률 비교 (부동소수점 오차 허용)
        if abs(전략속성1.get('매수하락률', 0) - 전략속성2.get('매수하락률', 0)) > 허용오차:
            return False
        
        # 매수수량 비교 (부동소수점 오차 허용)
        if abs(전략속성1.get('매수수량', 0) - 전략속성2.get('매수수량', 0)) > 허용오차:
            return False
        
        # 손절라인 비교 (부동소수점 오차 허용)
        if abs(전략속성1.get('손절라인', 0) - 전략속성2.get('손절라인', 0)) > 허용오차:
            return False
        
        # 수익라인 비교 (부동소수점 오차 허용)
        if abs(전략속성1.get('수익라인', 0) - 전략속성2.get('수익라인', 0)) > 허용오차:
            return False
            
        return True
    
    def _전략조합_생성(self, 탈락전략목록=None):
        """다양한 전략 조합 자동 생성"""
        전략조합 = []
        
        # 탈락 기록 로드 (탈락 횟수 복원용)
        탈락기록 = self._탈락전략_로드()
        임시탈락기록 = 탈락기록['임시기록']
        print(f"  → 임시탈락기록 로드: {len(임시탈락기록)}개")
        
        # 탈락횟수별 통계
        탈락횟수별통계 = {}
        for 기록 in 임시탈락기록.values():
            횟수 = 기록.get('탈락횟수', 0)
            탈락횟수별통계[횟수] = 탈락횟수별통계.get(횟수, 0) + 1
        print(f"  → 탈락횟수별 분포: {dict(sorted(탈락횟수별통계.items()))}")
        
        
        # 매수 전략 옵션 (탈락 패턴 분석 기반 최적화)
        매수전략들 = [
            # 시가하락 전략 강화 (평균 탈락 3.0회로 가장 우수)
            {'기준': '1', '이름': '시가하락', 
             '하락률': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 25, 30]},
            
            # 전일하락 전략 축소 (평균 탈락 3.3회로 가장 나쁨)  
            {'기준': '2', '이름': '전일하락',
             '하락률': [2.0, 3.0, 4.0, 5.0]},  # 16개 → 4개로 축소
            
            # 20일선하락 전략 적당히 유지 (평균 탈락 3.2회)
            {'기준': '3', '이름': '20일선하락',
             '하락률': [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 12.0, 15.0]},  # 21개 → 10개로 축소
            
            # 모멘텀매수 전략만 유지 (평균 탈락 3.2회로 양호)
            {'기준': '9', '이름': '모멘텀매수',
             '모멘텀기준': [2.0, 3.0, 4.0]},  # 6개 → 3개로 축소
        ]
        
        # 매수 수량 옵션
        매수수량들 = [
            {'방식': '1', '이름': '10%', '수량': 0.1},
            {'방식': '1', '이름': '30%', '수량': 0.3},
            {'방식': '1', '이름': '50%', '수량': 0.5},
            {'방식': '2', '이름': '5주', '수량': 5},
            {'방식': '2', '이름': '10주', '수량': 10}
        ]
        
        # 손절 옵션 (탈락 패턴 분석 기반 최적화)
        # 작은 손절라인(-0.5~-1.5%)은 제거, 중간~큰 손절라인 강화
        손절라인들 = [-2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0, -10.0, -12.0, -15.0]  # 17개 → 11개로 축소
        
        # 고무줄 매도 전략 옵션
        매도전략들 = []
        
        # 1. 기본 일괄 매도 전략들
        일괄수익라인들 = [1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 12.0, 15.0, 18.0, 20.0]
        for 수익라인 in 일괄수익라인들:
            매도전략들.append({'전략': '2', '이름': f'일괄{수익라인}%', '수익라인': 수익라인})
        
        # 고무줄매도 전략 제거 (평균 탈락 3.3회로 가장 나쁨)
        
        # 3. 기간별 존버 전략들 (정해진 기간에만 매도)
        존버전략들 = [
            {'전략': '3', '이름': '15일존버', '수익라인': 999, '매도기간': 14},  # 15일차에 매도 (3주)
            {'전략': '3', '이름': '30일존버', '수익라인': 999, '매도기간': 29},  # 30일차에 매도 (6주)
            {'전략': '3', '이름': '45일존버', '수익라인': 999, '매도기간': 44},  # 45일차에 매도 (9주)
            {'전략': '3', '이름': '90일존버', '수익라인': 999, '매도기간': 89},  # 90일차에 매도 (18주)
            {'전략': '3', '이름': '120일존버', '수익라인': 999, '매도기간': 119}, # 120일차에 매도 (24주)
            {'전략': '3', '이름': '최종존버', '수익라인': 999, '매도기간': 134}   # 135일차에 매도 (27주)
        ]
        
        for 존버 in 존버전략들:
            매도전략들.append(존버)
        
        # 영구 제외 전략 키 세트 생성 (탈락전략.json에서)
        영구제외키들 = set()
        if 탈락전략목록:
            # 탈락전략목록이 새로운 형식인지 확인
            if isinstance(탈락전략목록, dict) and '영구제외' in 탈락전략목록:
                영구제외전략들 = 탈락전략목록['영구제외']
            else:
                # 기존 형식 호환성
                영구제외전략들 = 탈락전략목록
            
            for 탈락전략 in 영구제외전략들:
                키 = self._전략을_키로_변환(탈락전략)
                영구제외키들.add(키)
        
        # 1. 5회+ 탈락 전략들을 영구제외_전략_히스토리.json에 추가 (재시장분별을 위해)
        완전제외키들 = set()  # 3시장 모두 탈락한 전략들만
        
        # 2. 시장별 제외 전략 로딩 (압축된 영구제외 파일)
        시장별제외키들 = {}  # 기존 키 기반 시장별 제외
        시장별제외전략들 = {}  # 압축된 속성 기반 시장별 제외: {'상승장': [], '하락장': [], '횡보장': []}
        완전제외전략들 = []  # 속성 기반 완전제외 전략 목록
        완전제외_중복확인 = set()  # 중복 제거용
        
        try:
            if os.path.exists(self.영구제외_파일):
                # 압축된 배열 파일 로드
                with open(self.영구제외_파일, 'r', encoding='utf-8') as f:
                    압축데이터 = json.load(f)
                    
                시장매핑 = {1: '상승장', 2: '하락장', 3: '횡보장'}
                전략들 = 압축데이터.get('strategies', [])
                영구제외_중복제거수 = 0
                
                for 전략배열 in 전략들:
                    if len(전략배열) < 6:
                        continue
                    
                    # 전략배열: [구매방식, 매수수량, 손절라인, 수익라인, 시장배열, 완전제외]
                    전략속성 = {
                        '구매방식': 전략배열[0],
                        '매수수량': 전략배열[1],
                        '손절라인': 전략배열[2],
                        '수익라인': 전략배열[3],
                        '탈락시장들': [시장매핑[시장번호] for 시장번호 in 전략배열[4] if 시장번호 in 시장매핑],
                        '완전제외': 전략배열[5]
                    }
                    
                    if 전략속성['완전제외']:
                        # 중복 확인용 키 생성 (완전제외 전략)
                        전략키 = (전략배열[0], 전략배열[1], 전략배열[2], 전략배열[3])
                        
                        if 전략키 in 완전제외_중복확인:
                            영구제외_중복제거수 += 1
                            continue  # 중복이므로 건너뛰기
                        
                        # 중복이 아니면 추가
                        완전제외_중복확인.add(전략키)
                        완전제외전략들.append(전략속성)
                    else:
                        # 시장별 제외 전략
                        for 시장 in 전략속성['탈락시장들']:
                            if 시장 not in 시장별제외전략들:
                                시장별제외전략들[시장] = []
                            시장별제외전략들[시장].append(전략속성)
                
                # 통계 출력 (필요시만)
                if len(전략들) > 0:
                    pass  # 불필요한 로드 출력 제거
                
            else:
                # 파일이 없으면 빈 구조로 초기화
                pass
                        
        except Exception as e:
            print(f"시장별 제외 전략 로드 실패: {e}")
        
        # 현재 시장 상황 예측
        현재시장상황 = self._현재_시뮬레이션의_시장상황_예측()
        
        print(f"제외 전략 현황: ({현재시장상황} 표시)")
        print(f"  - 완전제외: {len(완전제외키들)} (5회+ 탈락 + 3시장 모두탈락) + {len(완전제외전략들)} (압축)")
        if 현재시장상황 in 시장별제외키들:
            print(f"  - {현재시장상황} 제외: {len(시장별제외키들[현재시장상황])} (키)")
        if 현재시장상황 in 시장별제외전략들:
            print(f"  - {현재시장상황} 제외: {len(시장별제외전략들[현재시장상황])} (압축)")
        
        # 모든 조합 생성 (탈락 전략 제외)
        생성수 = 0
        제외수 = 0
        완전제외카운트 = 0
        시장별제외카운트 = 0
        
        for 매수전략 in 매수전략들:
            # 전략 타입에 따라 다른 매개변수 처리
            if '하락률' in 매수전략:  # 하락매수 전략들 (기존)
                매개변수들 = 매수전략['하락률']
                매개변수명 = '매수하락률'
            elif '상승률' in 매수전략:  # 상승매수 전략들 (신규)
                매개변수들 = 매수전략['상승률']
                매개변수명 = '매수상승률'
            elif '연속횟수' in 매수전략:  # 연속상승 전략 (신규)
                매개변수들 = 매수전략['연속횟수']
                매개변수명 = '연속횟수'
            elif '모멘텀기준' in 매수전략:  # 모멘텀 전략 (신규)
                매개변수들 = 매수전략['모멘텀기준']
                매개변수명 = '모멘텀기준'
            else:
                continue  # 알 수 없는 전략 타입은 건너뛰기
                
            for 매개변수값 in 매개변수들:
                for 매수수량 in 매수수량들:
                    for 손절 in 손절라인들:
                        for 매도전략 in 매도전략들:
                            # 임시 전략 객체 생성 (동적 매개변수명 사용)
                            임시전략 = {
                                '매수기준': 매수전략['기준'],
                                매개변수명: 매개변수값,  # 동적으로 설정
                                '구매방식': 매수수량['방식'],
                                '매수수량': 매수수량['수량'],
                                '손절라인': 손절,
                                '매도전략': 매도전략['전략'],
                                '수익라인': 매도전략['수익라인']
                            }
                            
                            # 하락률은 하위 호환성을 위해 유지
                            if 매개변수명 == '매수하락률':
                                임시전략['매수하락률'] = 매개변수값
                            else:
                                # 매수하락률이 없는 경우 전략에 맞는 기본값 설정
                                if '매수하락률' not in 임시전략:
                                    # 상승매수 전략의 경우 적절한 기본값 설정
                                    if 매수전략['기준'] in ['6', '7']:  # 시가상승, 20일선상승
                                        임시전략['매수하락률'] = -매개변수값  # 상승률을 음수 하락률로 변환
                                    else:
                                        임시전략['매수하락률'] = 1.0  # 기타 전략 기본값
                            
                            # 제외 전략 확인 (우선순위: 완전제외 > 현재시장제외)
                            키 = self._전략을_키로_변환(임시전략)
                            
                            # 1. 완전제외 확인 (속성 기반 매칭)
                            전략속성 = self._전략을_속성으로_변환(임시전략)
                            완전제외여부 = False
                            
                            # 기존 키 기반 완전제외 확인 (5회+탈락 + 3시장모두탈락)
                            if 키 in 완전제외키들:
                                완전제외여부 = True
                            
                            # 압축된 완전제외 전략과 속성 매칭
                            if not 완전제외여부 and 전략속성:
                                for 완전제외전략속성 in 완전제외전략들:
                                    if self._전략속성_일치확인(전략속성, 완전제외전략속성):
                                        완전제외여부 = True
                                        break
                            
                            if 완전제외여부:
                                제외수 += 1
                                완전제외카운트 += 1
                                continue
                            
                            # 2. 현재 시장별 제외 확인
                            # - 상승장 제외 → 하락장, 횡보장에서만 투입
                            # - 하락장 제외 → 상승장, 횡보장에서만 투입
                            # - 횡보장 제외 → 상승장, 하락장에서만 투입
                            시장별제외여부 = False
                            
                            # 기존 키 기반 시장별 제외 확인
                            if 현재시장상황 in 시장별제외키들 and 키 in 시장별제외키들[현재시장상황]:
                                시장별제외여부 = True
                            
                            # 압축된 시장별 제외 전략과 속성 매칭
                            if not 시장별제외여부 and 전략속성 and 현재시장상황 in 시장별제외전략들:
                                for 시장별제외전략속성 in 시장별제외전략들[현재시장상황]:
                                    if self._전략속성_일치확인(전략속성, 시장별제외전략속성):
                                        시장별제외여부 = True
                                        break
                            
                            if 시장별제외여부:
                                제외수 += 1
                                시장별제외카운트 += 1
                                continue
                            
                            # 정상 전략 추가
                            # 동적 매개변수 추가
                            
                            # 구매방식 2인 경우 초기 자본과 초기 가격으로 실제 주식수 계산
                            실제매수수량 = 매수수량['수량']
                            if 매수수량['방식'] == '2':
                                # 초기자본 100,000원과 초기가격으로 계산
                                # 예: 5주 설정 시 → 초기가격이 10,000원이면 50,000원 필요
                                #     10주 설정 시 → 초기가격이 10,000원이면 100,000원 필요
                                # 자본이 부족하면 최대 구매 가능 수량으로 조정
                                필요자본 = self.초기가격 * 매수수량['수량']
                                if 필요자본 > 100000:
                                    # 자본 부족 시 최대 구매 가능 수량으로 조정
                                    실제매수수량 = int(100000 / self.초기가격)
                                else:
                                    실제매수수량 = 매수수량['수량']
                            
                            전략데이터 = {
                                '매수기준': 매수전략['기준'],
                                '매수기준명': 매수전략['이름'],
                                매개변수명: 매개변수값,  # 동적으로 매개변수 추가
                                '구매방식': 매수수량['방식'],
                                '구매방식명': 매수수량['이름'],
                                '매수수량': 실제매수수량,  # 방식2인 경우 조정된 값 사용
                                '손절라인': 손절,
                                '매도전략': 매도전략['전략'],
                                '매도전략명': 매도전략['이름'],
                                '수익라인': 매도전략['수익라인'],
                                '자본': 100000,
                                '주식수': 0,
                                '매수가격': 0,
                                '최고가격': 0,
                                '절반매도완료': False,
                                '이동평균': self.과거데이터.copy(),  # 과거 120일 데이터로 초기화
                                '거래내역': [],
                            }
                            
                            # 고무줄 매도 전략인 경우 설정 추가
                            if '고무줄설정' in 매도전략:
                                전략데이터['고무줄설정'] = 매도전략['고무줄설정']
                                
                            # 하위 호환성을 위해 매수하락률도 추가 (기존 코드 동작 보장)
                            if '매수하락률' not in 전략데이터:
                                전략데이터['매수하락률'] = 0  # 기본값
                            
                            # 탈락 횟수 복원 (기존 탈락 기록에서)
                            전략키 = self._전략을_키로_변환(전략데이터)
                            
                            
                            if 전략키 in 임시탈락기록:
                                탈락횟수 = 임시탈락기록[전략키]['탈락횟수']
                                전략데이터['탈락횟수'] = 탈락횟수
                                
                                # 탈락횟수 × 2만큼 옐로우카드 부여 (패널티 적용) - 새로운 키 매칭!
                                기본옐로우카드 = 탈락횟수 * 2
                                # 개별 출력 제거 (요약에서 출력)
                                
                                기존옐로우 = 임시탈락기록[전략키].get('옐로우카드', 0)
                                if isinstance(기존옐로우, dict):
                                    추가옐로우 = 기존옐로우.get('개수', 0)
                                else:
                                    추가옐로우 = 기존옐로우
                                
                                # 총 옐로우카드 = 기본(탈락×2) + 추가 옐로우카드
                                총옐로우카드 = 기본옐로우카드 + 추가옐로우
                                전략데이터['옐로우카드'] = {'개수': 총옐로우카드, '마지막카드주차': 0}
                                
                            else:
                                전략데이터['탈락횟수'] = 0
                                전략데이터['옐로우카드'] = {'개수': 0, '마지막카드주차': 0}
                                
                            전략조합.append(전략데이터)
                            
                            생성수 += 1
        
        print(f"제외된 전략: {제외수}개 (완전제외:{완전제외카운트}개, 시장별제외:{시장별제외카운트}개), 실제 투입: {생성수}개")
        
        # 옐로우카드 적용 요약
        옐로우카드_전략수 = len([전략 for 전략 in 전략조합 if 전략.get('옐로우카드', {}).get('개수', 0) > 0])
        총_옐로우카드수 = sum(전략.get('옐로우카드', {}).get('개수', 0) for 전략 in 전략조합)
        if 옐로우카드_전략수 > 0:
            print(f"옐로우카드 적용: {옐로우카드_전략수}개 전략에 총 {총_옐로우카드수}개 카드 적용")
        
        
        return 전략조합
    
    def _일일_시뮬레이션(self, 전략, 일차):
        """하루 동안의 특정 전략 시뮬레이션"""
        # 전일 종가 계산 (이동평균에서)
        전일종가 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
        
        # 시작 가격 (전일 종가)
        현재가격 = 전일종가
        시작자본 = 전략['자본']
        시작평가 = 시작자본 + 전략['주식수'] * 현재가격
        
        거래횟수 = 0
        
        # 하루 7시간 시뮬레이션
        for 시간 in range(7):
            시간인덱스 = 일차 * 7 + 시간
            if 시간인덱스 >= len(self.시간데이터):
                break
                
            변동률 = self.시간데이터[시간인덱스]
            현재가격 = 현재가격 * (1 + 변동률/100)
            현재가격 = int(현재가격 * 10) / 10  # 소수점 1자리 버림
            
            # 매매 로직 실행 (첫 시간 제외)
            if 시간 > 0:  # 첫 번째 시간은 매수/매도 금지
                거래발생 = self._전략_매매_실행(전략, 현재가격, 전일종가, 일차, 시간)
                if 거래발생:
                    거래횟수 += 1
        
        # 이동평균 업데이트 (최대 120일 유지)
        전략['이동평균'].append(현재가격)
        if len(전략['이동평균']) > 120:
            전략['이동평균'].pop(0)
        
        # 최종 평가자산 및 수익률 계산
        최종평가 = 전략['자본'] + 전략['주식수'] * 현재가격
        
        # 일일 수익률: 하루 시작 대비 하루 종료시점 총 평가자산 변화율
        일일수익률 = ((최종평가 - 시작평가) / 시작평가) * 100 if 시작평가 > 0 else 0
        
        총수익률 = ((최종평가 - 100000) / 100000) * 100
        
        return {
            '전략': 전략,
            '수익률': 총수익률,
            '일수익률': 일일수익률,
            '평가자산': 최종평가,
            '거래횟수': 거래횟수,
            '현재가격': 현재가격
        }
    
    def _전략_매매_실행(self, 전략, 현재가격, 전일종가, 일차, 시간):
        """전략에 따른 매매 실행"""
        거래발생 = False
        
        # 손절 체크
        if 전략['주식수'] > 0 and 전략['매수가격'] > 0:
            손실률 = ((현재가격 - 전략['매수가격']) / 전략['매수가격']) * 100
            if 손실률 <= 전략['손절라인']:
                # 거래비용을 반영한 실제 매도 수령금액
                실제매도금 = self._실제매도금_계산(현재가격, 전략['주식수'])
                전략['자본'] += 실제매도금
                전략['거래내역'].append(('손절', 일차+1, 시간+1, 현재가격, 전략['주식수']))
                전략['주식수'] = 0
                전략['매수가격'] = 0  # 매수가 초기화
                전략['절반매도완료'] = False
                return True
        
        # 매수 체크
        if 전략['자본'] > 현재가격 and 전략['주식수'] == 0:
            매수신호 = False
            
            if 전략['매수기준'] == '1':  # 시가 대비 하락
                시가 = self._시가_계산(일차)
                일대비변동 = ((현재가격 - 시가) / 시가) * 100
                if 일대비변동 <= -전략['매수하락률']:
                    매수신호 = True
                        
            elif 전략['매수기준'] == '2':  # 전일 종가 대비 하락
                if 일차 > 0:  # 첫날이 아닌 경우만
                    전일대비변동 = ((현재가격 - 전일종가) / 전일종가) * 100
                    if 전일대비변동 <= -전략['매수하락률']:
                        매수신호 = True
                else:  # 첫날은 초기가격 대비로 계산
                    초기대비변동 = ((현재가격 - self.초기가격) / self.초기가격) * 100
                    if 초기대비변동 <= -전략['매수하락률']:
                        매수신호 = True
                    
            elif 전략['매수기준'] == '3':  # 20일선 이탈
                if len(전략['이동평균']) >= 20:
                    평균가 = sum(전략['이동평균'][-20:]) / 20
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '4':  # 60일선 이탈
                if len(전략['이동평균']) >= 60:
                    평균가 = sum(전략['이동평균'][-60:]) / 60
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '5':  # 120일선 이탈
                if len(전략['이동평균']) >= 120:
                    평균가 = sum(전략['이동평균'][-120:]) / 120
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '6':  # 시가 대비 상승
                시가 = self._시가_계산(일차)
                일대비변동 = ((현재가격 - 시가) / 시가) * 100
                if 일대비변동 >= 전략['매수상승률']:
                    매수신호 = True
                    
            elif 전략['매수기준'] == '7':  # 20일선 돌파 상승
                if len(전략['이동평균']) >= 20:
                    평균가 = sum(전략['이동평균'][-20:]) / 20
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 >= 전략['매수상승률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '8':  # 연속상승 매수
                if len(전략['이동평균']) >= 전략['연속횟수']:
                    연속상승 = self._연속상승_체크(전략['이동평균'], 전략['연속횟수'])
                    if 연속상승:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '9':  # 모멘텀 매수
                if len(전략['이동평균']) >= 5:  # 최근 5일 모멘텀 체크
                    모멘텀 = self._모멘텀_계산(전략['이동평균'][-5:])
                    if 모멘텀 >= 전략['모멘텀기준']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '10':  # 고무줄 시가하락 매수
                시가 = self._시가_계산(일차)
                일대비변동 = ((현재가격 - 시가) / 시가) * 100
                if 일대비변동 <= -전략['매수하락률']:
                    # 고무줄 매수 신호 - 해당 하락률에 따른 매수를 합드뇜
                    매수신호 = self._고무줄_매수_체크(전략, 일대비변동)
                        
            elif 전략['매수기준'] == '11':  # 고무줄 20일선하락 매수
                if len(전략['이동평균']) >= 20:
                    평균가 = sum(전략['이동평균'][-20:]) / 20
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        # 고무줄 매수 신호 - 해당 하락률에 따른 매수를 합드뇝
                        매수신호 = self._고무줄_매수_체크(전략, 평균대비)
            
            if 매수신호:
                # 고무줄 매수 전략인지 확인
                if 전략.get('고무줄매수', False):
                    # 고무줄 매수 실행
                    거래발생 = self._고무줄_매수_실행(전략, 현재가격, 일차, 시간)
                else:
                    # 일반 매수 실행
                    if 전략['구매방식'] == '1':  # 퍼센트 방식
                        목표매수금액 = 전략['자본'] * 전략['매수수량']
                    else:  # 초기 설정 고정 주식수 방식
                        # 초기 설정된 주식수를 절대 변경하지 않음
                        목표매수금액 = min(현재가격 * 전략['매수수량'], 전략['자본'])
                    
                    # 거래비용을 고려하여 실제 구매 가능한 주식 수 계산
                    매수주식 = int(목표매수금액 / 현재가격)  # 정수 변환
                    실제필요자본 = self._실제매수가_계산(현재가격, 매수주식)
                    
                    # 보유 자본이 충분한지 확인
                    if 실제필요자본 <= 전략['자본']:
                        # 평균 매수가 계산 (기존 보유 + 신규 매수)
                        기존총액 = 전략['주식수'] * 전략['매수가격'] if 전략['주식수'] > 0 else 0
                        신규총액 = 매수주식 * 현재가격
                        총보유주식 = 전략['주식수'] + 매수주식
                        
                        전략['주식수'] = 총보유주식
                        전략['자본'] -= 실제필요자본  # 거래비용 포함 차감
                        전략['매수가격'] = (기존총액 + 신규총액) / 총보유주식  # 평균 매수가
                        전략['거래내역'].append(('매수', 일차+1, 시간+1, 현재가격, 매수주식))
                        거래발생 = True
        
        # 매도 체크
        if 전략['주식수'] > 0 and 전략['매수가격'] > 0:
            수익률 = ((현재가격 - 전략['매수가격']) / 전략['매수가격']) * 100
            
            # 최고가 업데이트 (트레일링 스탑용)
            if 현재가격 > 전략['최고가격']:
                전략['최고가격'] = 현재가격
            
            if 전략['매도전략'] == '1' and not 전략['절반매도완료']:  # 분할 매도
                if 수익률 >= 전략['수익라인']:
                    매도주식 = 전략['주식수'] * 0.5
                    실제매도금 = self._실제매도금_계산(현재가격, 매도주식)
                    전략['주식수'] -= 매도주식
                    전략['자본'] += 실제매도금
                    전략['절반매도완료'] = True
                    전략['거래내역'].append(('절반매도', 일차+1, 시간+1, 현재가격, 매도주식))
                    거래발생 = True
                    
            elif 전략['매도전략'] == '2':  # 목표가 일괄 매도
                if 수익률 >= 전략['수익라인']:
                    실제매도금 = self._실제매도금_계산(현재가격, 전략['주식수'])
                    전략['자본'] += 실제매도금
                    전략['거래내역'].append(('전량매도', 일차+1, 시간+1, 현재가격, 전략['주식수']))
                    전략['주식수'] = 0
                    전략['매수가격'] = 0  # 매수가 초기화
                    전략['절반매도완료'] = False
                    전략['최고가격'] = 0
                    거래발생 = True
                    
            elif 전략['매도전략'] == '3':  # 존버 전략
                # 기간별 존버: 정해진 기간에 도달하면 매도
                매도기간 = 전략.get('매도기간', 134)  # 기본값: 134일차
                if 일차 == 매도기간:  # 정해진 기간에 매도
                    실제매도금 = self._실제매도금_계산(현재가격, 전략['주식수'])
                    전략['자본'] += 실제매도금
                    전략['거래내역'].append(('기간매도', 일차+1, 시간+1, 현재가격, 전략['주식수']))
                    전략['주식수'] = 0
                    거래발생 = True
                
            elif 전략['매도전략'] == '4':  # 고무줄 매도 시스템
                if '고무줄설정' in 전략:
                    거래발생 = self._고무줄_매도_처리(전략, 수익률, 현재가격, 일차, 시간)
                else:
                    # 기본값으로 처리 (혹시 설정이 없는 경우)
                    pass
        
        return 거래발생
    
    def _고무줄_매도_처리(self, 전략, 수익률, 현재가격, 일차, 시간):
        """고무줄 매도 시스템 - 수익률에 따른 차등 매도"""
        if 전략['주식수'] <= 0:
            return False
        
        설정 = 전략['고무줄설정']
        시작수익률 = 설정['시작수익률']
        단계간격 = 설정['단계간격']
        초기매도비율 = 설정['초기매도비율']
        비율증가량 = 설정['비율증가량']
        
        # 매도 레벨 별로 기록 (전략에 고무줄 상태 저장)
        if '고무줄상태' not in 전략:
            전략['고무줄상태'] = {
                '누적매도비율': 0,  # 지금까지 매도한 비율
                '다음매도레벨': 시작수익률  # 다음 매도 트리거 수익률
            }
        
        상태 = 전략['고무줄상태']
        
        # 현재 수익률이 다음 매도 레벨에 도달했는지 확인
        if 수익률 >= 상태['다음매도레벨'] and 상태['누적매도비율'] < 100:
            # 현재 레벨 계산 (0부터 시작)
            현재레벨 = int((상태['다음매도레벨'] - 시작수익률) / 단계간격)
            
            # 이번에 매도할 비율 계산
            현재매도비율 = 초기매도비율 + (비율증가량 * 현재레벨)
            현재매도비율 = min(현재매도비율, 100 - 상태['누적매도비율'])  # 100% 초과 방지
            
            # 실제 매도할 주식 수 계산 (전체 주식의 비율)
            원본주식수 = 전략['주식수'] / (1 - 상태['누적매도비율']/100) if 상태['누적매도비율'] < 100 else 전략['주식수']
            매도할주식 = 원본주식수 * (현재매도비율 / 100)
            매도할주식 = min(매도할주식, 전략['주식수'])  # 보유 주식 초과 방지
            
            if 매도할주식 > 0:
                # 매도 실행 (거래비용 반영)
                실제매도금 = self._실제매도금_계산(현재가격, 매도할주식)
                전략['주식수'] -= 매도할주식
                전략['자본'] += 실제매도금
                
                # 상태 업데이트
                상태['누적매도비율'] += 현재매도비율
                상태['다음매도레벨'] += 단계간격
                
                # 거래 기록
                매도타입 = f'고무줄{현재레벨+1}단계'
                전략['거래내역'].append((매도타입, 일차+1, 시간+1, 현재가격, 매도할주식))
                
                # 모든 주식을 매도했거나 100% 매도 완료 시 초기화
                if 전략['주식수'] <= 0.01 or 상태['누적매도비율'] >= 99:
                    전략['매수가격'] = 0
                    전략['최고가격'] = 0
                    전략['절반매도완료'] = False
                    상태['누적매도비율'] = 0
                    상태['다음매도레벨'] = 시작수익률
                    전략['주식수'] = 0  # 완전 정리
                
                return True
        
        return False
    
    def _고무줄_매수_체크(self, 전략, 하락률):
        """고무줄 매수 체크 - 하락 깊이에 따른 매수 비율 계산"""
        if '고무줄매수설정' not in 전략:
            return False
            
        설정 = 전략['고무줄매수설정']
        시작하락률 = 설정['시작하락률']
        단계간격 = 설정['단계간격']
        초기비율 = 설정['초기매수비율']
        비율증가량 = 설정['비율증가량']
        
        # 고무줄 매수 상태 초기화 (첫 번째 매수인 경우)
        if '고무줄매수상태' not in 전략:
            전략['고무줄매수상태'] = {
                '누적매수비율': 0,  # 지금까지 매수한 비율
                '매수지점들': [],  # 매수한 가격들
                '머니예약금': 전략['자본']  # 초기 자본
            }
        
        상태 = 전략['고무줄매수상태']
        
        # 하락 깊이에 따른 매수 레벨 계산
        하락절대값 = abs(하락률)
        if 하락절대값 >= 시작하락률:
            # 매수 레벨 계산 (0부터 시작)
            매수레벨 = int((하락절대값 - 시작하락률) / 단계간격)
            
            # 이번에 매수할 비율 계산
            현재매수비율 = 초기비율 + (비율증가량 * 매수레벨)
            
            # 이미 매수한 비율을 고려하여 추가 매수 비율 계산
            사용가능비율 = 100 - 상태['누적매수비율']
            실제매수비율 = min(현재매수비율, 사용가능비율)
            
            if 실제매수비율 > 0 and 상태['누적매수비율'] < 100:
                return True
                
        return False
        
    def _고무줄_매수_실행(self, 전략, 현재가격, 일차, 시간):
        """고무줄 매수 실행 - 하락 깊이에 따른 비율적 매수"""
        if '고무줄매수상태' not in 전략:
            return False
            
        상태 = 전략['고무줄매수상태']
        설정 = 전략['고무줄매수설정']
        
        # 하락률 계산 (매수기준에 따라)
        if 전략['매수기준'] == '10':  # 시가하락
            시가 = self._시가_계산(일차)
            하락률 = ((현재가격 - 시가) / 시가) * 100
        elif 전략['매수기준'] == '11':  # 20일선하락
            if len(전략['이동평균']) >= 20:
                평균가 = sum(전략['이동평균'][-20:]) / 20
                하락률 = ((현재가격 - 평균가) / 평균가) * 100
            else:
                return False
        else:
            return False
            
        하락절대값 = abs(하락률)
        시작하락률 = 설정['시작하락률']
        단계간격 = 설정['단계간격']
        초기비율 = 설정['초기매수비율']
        비율증가량 = 설정['비율증가량']
        
        # 하락 깊이에 따른 매수 비율 계산
        if 하락절대값 >= 시작하락률:
            # 매수 레벨 계산
            매수레벨 = int((하락절대값 - 시작하락률) / 단계간격)
            현재매수비율 = 초기비율 + (비율증가량 * 매수레벨)
            
            # 사용 가능한 비율 계산 (전체 예약금 대비)
            전체예약금 = 상태['머니예약금']
            이미사용금액 = 전체예약금 * (상태['누적매수비율'] / 100)
            남은예약금 = 전체예약금 - 이미사용금액
            
            # 이번에 사용할 금액
            사용할금액 = 전체예약금 * (현재매수비율 / 100)
            사용할금액 = min(사용할금액, 남은예약금)
            
            if 사용할금액 > 현재가격 and 상태['누적매수비율'] < 100:
                # 실제 매수 실행
                매수주식 = int(사용할금액 / 현재가격)  # 정수 변환
                실제필요자본 = self._실제매수가_계산(현재가격, 매수주식)
                
                # 자본이 충분한지 확인 (현재 남은 자본으로)
                if 실제필요자본 <= 전략['자본']:
                    # 평균 매수가 계산
                    기존총액 = 전략['주식수'] * 전략['매수가격'] if 전략['주식수'] > 0 else 0
                    신규총액 = 매수주식 * 현재가격
                    총보유주식 = 전략['주식수'] + 매수주식
                    
                    # 전략 데이터 업데이트
                    전략['주식수'] = 총보유주식
                    전략['자본'] -= 실제필요자본
                    전략['매수가격'] = (기존총액 + 신규총액) / 총보유주식
                    
                    # 고무줄 상태 업데이트
                    상태['누적매수비율'] += (사용할금액 / 상태['머니예약금']) * 100
                    상태['매수지점들'].append({
                        '가격': 현재가격,
                        '수량': 매수주식,
                        '하락률': 하락절대값,
                        '레벨': 매수레벨
                    })
                    
                    # 거래 내역 기록
                    전략['거래내역'].append((f'고무줄매수L{매수레벨}', 일차+1, 시간+1, 현재가격, 매수주식))
                    
                    return True
                    
        return False

    def _전략설명_생성(self, 전략):
        """전략 설명 텍스트 생성"""
        try:
            매수기준 = 전략.get('매수기준명', '기본매수')
            매수하락률 = 전략.get('매수하락률', 0) if '하락' in str(매수기준) else 0
            매수상승률 = 전략.get('매수상승률', 0) if '상승' in str(매수기준) else 0
            구매방식 = 전략.get('구매방식명', '고정구매')
            매수수량 = 전략.get('매수수량', '')
            손절라인 = abs(전략.get('손절라인', 0))
            매도전략 = 전략.get('매도전략명', '기본매도')
            수익라인 = 전략.get('수익라인', 0)
        except Exception:
            return "전략정보_오류"
        
        try:
            # 매수 조건 표시 (고무줄 매수 전략 포함)
            if 전략.get('고무줄매수'):
                매수조건 = f"{매수기준}(고무줄)"
            elif 매수하락률 > 0:
                매수조건 = f"{매수기준}-{매수하락률}%"
            elif 매수상승률 > 0:
                매수조건 = f"{매수기준}+{매수상승률}%"
            else:
                매수조건 = 매수기준
            
            # 구매 방식과 수량 표시
            # 구매방식명에 이미 % 또는 주가 포함되어 있음
            if '주' in str(구매방식):
                구매설명 = 구매방식  # 예: '5주', '10주'
            elif '%' in str(구매방식):
                구매설명 = 구매방식  # 예: '10%', '30%', '50%'
            elif 전략.get('구매방식') == '1':  # 퍼센트 방식 (구매방식명이 없는 경우)
                구매설명 = f"{int(매수수량*100)}%"
            elif 전략.get('구매방식') == '2':  # 고정주식수 방식 (구매방식명이 없는 경우)
                구매설명 = f"{int(매수수량)}주"
            else:
                구매설명 = 구매방식
            
            # 매도 전략 표시
            if '고무줄설정' in 전략:
                설정 = 전략['고무줄설정']
                매도설명 = f"{매도전략}({설정['시작수익률']}%부터 {설정['단계간격']}%씩)"
            elif '분할' in str(매도전략):
                매도설명 = f"분할{수익라인}%"
            elif '일괄' in str(매도전략):
                매도설명 = f"일괄{수익라인}%"
            elif '트레일링' in str(매도전략):
                매도설명 = f"트레일링{수익라인}%"
            elif '존버' in str(매도전략):
                if '15일' in str(매도전략):
                    매도설명 = "15일존버"
                elif '30일' in str(매도전략):
                    매도설명 = "30일존버"
                elif '45일' in str(매도전략):
                    매도설명 = "45일존버"
                elif '90일' in str(매도전략):
                    매도설명 = "90일존버" 
                elif '120일' in str(매도전략):
                    매도설명 = "120일존버"
                elif '최종' in str(매도전략):
                    매도설명 = "최종존버"
                else:
                    매도설명 = f"존버{수익라인}%"
            else:
                매도설명 = f"{매도전략}{수익라인}%"
            
            return f"{매수조건} + {구매설명} + 손절-{손절라인}% + {매도설명}"
        except Exception as e:
            return f"전략설명_오류_{str(e)[:20]}"
    
    def _시가_계산(self, 일차):
        """해당 일의 시가 계산"""
        if 일차 == 0:
            return self.초기가격
        
        # 전일 종가 기준으로 시가 계산 (간단히 전일 마지막 가격 사용)
        이전일마지막시간 = (일차 - 1) * 7 + 6
        현재가격 = self.초기가격
        
        for i in range(이전일마지막시간 + 1):
            if i < len(self.시간데이터):
                현재가격 = 현재가격 * (1 + self.시간데이터[i]/100)
                현재가격 = int(현재가격 * 10) / 10
        
        return 현재가격
    
    def _연속상승_체크(self, 이동평균, 연속횟수):
        """연속 상승 여부 체크"""
        if len(이동평균) < 연속횟수:
            return False
        
        최근가격들 = 이동평균[-연속횟수:]
        for i in range(1, len(최근가격들)):
            if 최근가격들[i] <= 최근가격들[i-1]:
                return False
        return True
    
    def _모멘텀_계산(self, 가격들):
        """가격 모멘텀 계산 (최근 5일간의 상승률)"""
        if len(가격들) < 2:
            return 0
        
        초기가 = 가격들[0]
        최종가 = 가격들[-1]
        
        모멘텀 = ((최종가 - 초기가) / 초기가) * 100
        return 모멘텀
    
    def _일일결과_출력(self, 일일결과, 일차):
        """일일 시뮬레이션 결과 요약 출력"""
        # 일일수익률 기준으로 정렬
        일일정렬 = sorted(일일결과, key=lambda x: x['일수익률'], reverse=True)
        상위3 = 일일정렬[:3]
        하위3 = 일일정렬[-3:]
        
        # 전날 대비 주가 변동률 계산
        if 일차 > 0 and len(일일결과) > 0:
            # 첫 번째 전략의 이동평균으로 주가 변동 계산
            전략 = 일일결과[0]['전략']
            if len(전략['이동평균']) >= 2:
                현재가 = 전략['이동평균'][-1]
                전일가 = 전략['이동평균'][-2]
                변동률 = ((현재가 - 전일가) / 전일가) * 100
                변동표시 = f" {변동률:+.1f}%"
            else:
                변동표시 = ""
        else:
            변동표시 = ""
        
        print(f"\n{일차+1}일차 결과 요약 (총 {len(일일결과)}개 전략){변동표시}")
        print("="*50)
        
        # 상위 3개
        print("상위 3개 전략 (일일수익률 기준):")
        for i, 결과 in enumerate(상위3):
            전략 = 결과['전략']
            # 총 거래 내역 분석
            총거래내역 = 전략['거래내역']
            총매수 = len([t for t in 총거래내역 if t[0] == '매수'])
            총매도 = len([t for t in 총거래내역 if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '트레일링스탑', '기간매도'] or '고무줄' in t[0]])
            총손절 = len([t for t in 총거래내역 if t[0] == '손절'])
            
            # 오늘 거래 분석 (일차 기준)
            오늘거래 = [t for t in 총거래내역 if t[1] == 일차+1]
            오늘매수 = len([t for t in 오늘거래 if t[0] == '매수'])
            오늘매도 = len([t for t in 오늘거래 if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '트레일링스탑', '기간매도'] or '고무줄' in t[0]])
            오늘손절 = len([t for t in 오늘거래 if t[0] == '손절'])
            
            전략설명 = self._전략설명_생성(전략)
            # 보유 상태 표시
            보유상태 = f"보유{전략['주식수']:.0f}주" if 전략['주식수'] > 0 else "현금상태"
            print(f"{i+1}. [{전략설명}] (매수{오늘매수} 매도{오늘매도} 손절{오늘손절})")
            print(f"   일일: {결과['일수익률']:+.1f}% | 누적: {결과['수익률']:+.1f}% | {보유상태}")
        
        print("\n하위 3개 전략:")
        for i, 결과 in enumerate(하위3):
            전략 = 결과['전략']
            # 총 거래 내역 분석
            총거래내역 = 전략['거래내역']
            총매수 = len([t for t in 총거래내역 if t[0] == '매수'])
            총매도 = len([t for t in 총거래내역 if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '트레일링스탑', '기간매도'] or '고무줄' in t[0]])
            총손절 = len([t for t in 총거래내역 if t[0] == '손절'])
            
            # 오늘 거래 분석 (일차 기준)
            오늘거래 = [t for t in 총거래내역 if t[1] == 일차+1]
            오늘매수 = len([t for t in 오늘거래 if t[0] == '매수'])
            오늘매도 = len([t for t in 오늘거래 if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '트레일링스탑', '기간매도'] or '고무줄' in t[0]])
            오늘손절 = len([t for t in 오늘거래 if t[0] == '손절'])
            
            전략설명 = self._전략설명_생성(전략)
            # 보유 상태 표시
            보유상태 = f"보유{전략['주식수']:.0f}주" if 전략['주식수'] > 0 else "현금상태"
            print(f"{len(일일정렬)-2+i}. [{전략설명}] (매수{오늘매수} 매도{오늘매도} 손절{오늘손절})")
            print(f"   일일: {결과['일수익률']:+.1f}% | 누적: {결과['수익률']:+.1f}% | {보유상태}")
        
        # 통계 요약
        일일수익률들 = [r['일수익률'] for r in 일일결과]
        총수익률들 = [r['수익률'] for r in 일일결과]
        print(f"\n전체 {len(일일결과)}개 전략 통계 (탈락 포함):")
        print(f"일일: 최고 {max(일일수익률들):+.1f}% | 최저 {min(일일수익률들):+.1f}% | 평균 {sum(일일수익률들)/len(일일수익률들):+.1f}%")
        print(f"누적: 최고 {max(총수익률들):+.1f}% | 최저 {min(총수익률들):+.1f}% | 평균 {sum(총수익률들)/len(총수익률들):+.1f}%")
    
    def _최종결과_분석(self, 생존전략, 탈락기록):
        """최종 생존 전략들과 탈락 분석"""
        print(f"\n{'='*80}")
        print(f"최종 결과 분석")
        print(f"{'='*80}")
        
        print(f"\n최종 생존 전략 ({len(생존전략)}개): 요약만 표시")
        
        # 탈락 분석 (간소화)
        print(f"\n탈락 분석: 총 {len(탈락기록)}개 전략 탈락")
        
        # 전략 패턴 분석 - 생략
        
        # 최고 성과 전략 상세 분석
        if 생존전략:
            최고전략 = max(생존전략, key=lambda x: ((x['자본'] + x['주식수'] * (x['이동평균'][-1] if x['이동평균'] else self.초기가격)) - 100000) / 100000 * 100)
            
            print(f"\n최고 성과 전략 상세:")
            평가자산 = 최고전략['자본'] + 최고전략['주식수'] * (최고전략['이동평균'][-1] if 최고전략['이동평균'] else self.초기가격)
            수익률 = ((평가자산 - 100000) / 100000) * 100
            
            print(f"전략: {최고전략['매수기준명']}-{최고전략['매수하락률']}% + {최고전략['구매방식명']} + 손절{최고전략['손절라인']}% + {최고전략['매도전략명']}")
            print(f"최종 수익률: {수익률:+.1f}%")
            print(f"최종 자산: {평가자산:,.0f}원")
            
            # 거래 횟수 분석
            거래내역 = 최고전략['거래내역']
            매수횟수 = len([t for t in 거래내역 if t[0] == '매수'])
            손절횟수 = len([t for t in 거래내역 if t[0] == '손절'])
            매도횟수 = len(거래내역) - 매수횟수 - 손절횟수
            
            print(f"총 거래 횟수: {len(거래내역)}회 (매수: {매수횟수}회, 매도: {매도횟수}회, 손절: {손절횟수}회)")
            
            # 거래 내역 - 생략
            
            # 거래 통계 분석 추가
            self._거래통계_분석(생존전략)
            
            # 상위 5개 전략을 히스토리에 저장
            # 5사이클 시뮬레이션 중에는 저장하지 않음 (종합랭킹에서 한번에 저장)
            # 단일 시뮬레이션일 때만 저장
            if not hasattr(self, '_is_in_5cycle') or not self._is_in_5cycle:
                self._최고전략_히스토리_저장(생존전략, "단일시뮬레이션", {
                    '생존전략수': len(생존전략),
                    '탈락전략수': len(탈락기록)
                })
            
            return 최고전략
        
        return None
    
    def _최고전략_히스토리_저장(self, 생존전략들, 시뮬레이션타입, 추가정보=None):
        """상위 5개 최고 전략을 간단하게 저장 (간소화)"""
        # 상위 5개 전략 직접 추출 (간소화)
        if not 생존전략들:
            print("저장할 생존 전략이 없습니다.")
            return
            
        정렬된전략들 = sorted(생존전략들, key=lambda x: self._전략수익률_계산(x), reverse=True)
        상위5전략 = 정렬된전략들[:5]
        print(f"상위 5개 전략 추출 완료 (총 {len(생존전략들)}개 중)")
        
        # 실제 시장환경 정보 (구체적 데이터)
        최종가격 = 상위5전략[0]['이동평균'][-1] if 상위5전략[0]['이동평균'] else self.초기가격
        시장수익률 = round(((최종가격 - self.초기가격) / self.초기가격) * 100, 2)
        현재시장상황 = self._시장상황_판정(self.초기가격, 최종가격)
        
        시장환경 = {
            '초기가격': self.초기가격,
            '최종가격': 최종가격,
            '시장수익률': 시장수익률,
            '시장상황': 현재시장상황
        }
        
        # 새로운 히스토리 데이터 생성 (간소화)
        새로운_기록 = {
            '발견날짜': time.strftime("%Y-%m-%d %H:%M:%S"),
            '시뮬레이션타입': 시뮬레이션타입,
            '시장환경': 시장환경,
            '최고전략_순위': []
        }
        
        # 상위 5개 전략을 직접 저장 (그룹화 없이)
        for 순위, 전략 in enumerate(상위5전략, 1):
            수익률 = self._전략수익률_계산(전략)
            거래내역 = 전략.get('거래내역', [])
            
            # 거래 유형별 횟수 계산
            매수횟수 = len([t for t in 거래내역 if t[0] == '매수'])
            손절횟수 = len([t for t in 거래내역 if t[0] == '손절'])
            매도횟수 = len(거래내역) - 매수횟수 - 손절횟수
            
            전략정보 = {
                '순위': 순위,
                '전략설명': self._전략설명_생성(전략),
                '수익률': round(수익률, 1),
                '총거래횟수': len(거래내역),
                '매수': 매수횟수,
                '매도': 매도횟수,
                '손절': 손절횟수
            }
            새로운_기록['최고전략_순위'].append(전략정보)
        
        # 기존 히스토리 로드
        히스토리_파일 = self.최고전략_파일
        기존히스토리 = []
        
        try:
            if os.path.exists(히스토리_파일):
                with open(히스토리_파일, 'r', encoding='utf-8') as f:
                    로드된데이터 = json.load(f)
                    # 리스트인지 확인하고 딕셔너리면 리스트로 변환
                    if isinstance(로드된데이터, list):
                        기존히스토리 = 로드된데이터
                    else:
                        기존히스토리 = []  # 딕셔너리면 새로 시작
        except:
            print("  기존 히스토리 로드 실패, 새로 시작")
        
        # 새 기록 추가
        기존히스토리.append(새로운_기록)
        
        # 저장 (최근 50개만 유지)
        if len(기존히스토리) > 50:
            기존히스토리 = 기존히스토리[-50:]
        
        try:
            self._안전한_json_저장(히스토리_파일, 기존히스토리)
            
            print(f"\n최고전략 히스토리 저장 완료")
            if 상위5전략:
                최고전략 = 상위5전략[0]  # 가장 수익률이 높은 전략
                print(f"   전략: {최고전략['매수기준명']}-{최고전략['매수하락률']}% + {최고전략['매도전략명']}")
                # 거래 내역 분석
                거래내역 = 최고전략['거래내역']
                매수횟수 = len([t for t in 거래내역 if t[0] == '매수'])
                손절횟수 = len([t for t in 거래내역 if t[0] == '손절'])
                매도횟수 = len(거래내역) - 매수횟수 - 손절횟수
                
                # 수익률 계산
                수익률 = self._전략수익률_계산(최고전략)
                print(f"   수익률: {수익률:+.1f}% | 총 거래: {매수횟수+매도횟수+손절횟수}회 (매수:{매수횟수}, 매도:{매도횟수}, 손절:{손절횟수})")
            print(f"   총 기록: {len(기존히스토리)}개")
            
        except Exception as e:
            print(f"최고전략 히스토리 저장 실패: {e}")
    
    def _시장상황_판정(self, 초기가격, 최종가격):
        """시장 상황 판정: 상승장/하락장/횡보장 (27주 기준, 최초-최종 가격만 비교)"""
        변동률 = ((최종가격 - 초기가격) / 초기가격) * 100
        
        if 변동률 >= 13:  # 13% 이상 상승
            return "상승장"
        elif 변동률 <= -13:  # 13% 이상 하락
            return "하락장"
        else:  # -13% ~ 13% 사이 (중간 변동 무시, 최초-최종만 비교)
            return "횡보장"
    
    def _현재_시뮬레이션의_시장상황_예측(self):
        """현재 시뮬레이션에서 예상되는 시장 상황 판정 (초기 데이터 기반)"""
        # 주간 데이터가 있으면 첫 주의 변동률로 예측
        if hasattr(self, '주간데이터') and len(self.주간데이터) > 0:
            첫주변동률 = self.주간데이터[0]
            if 첫주변동률 >= 13:
                return "상승장"
            elif 첫주변동률 <= -13:
                return "하락장"
            else:
                return "횡보장"
        else:
            # 기본적으로는 횡보장으로 가정 (모든 전략 허용)
            return "횡보장"
    
    def _시장상황별_제외대상인지_확인(self, 전략키, 현재시장상황):
        """특정 전략이 현재 시장 상황에서 제외 대상인지 확인 (배열 구조)"""
        try:
            if not os.path.exists(self.영구제외_파일):
                return False
                
            with open(self.영구제외_파일, 'r', encoding='utf-8') as f:
                압축데이터 = json.load(f)
            
            시장매핑 = {"상승장": 1, "하락장": 2, "횡보장": 3}
            현재시장번호 = 시장매핑.get(현재시장상황, 0)
            
            # 배열 형태에서 전략키 확인
            for 전략배열 in 압축데이터.get('strategies', []):
                if len(전략배열) >= 3:
                    전략설명 = 전략배열[0]
                    탈락시장번호들 = 전략배열[1]
                    완전제외 = 전략배열[2]
                    
                    if 전략설명 == 전략키:
                        # 완전제외인 경우 모든 시장에서 제외
                        if 완전제외:
                            return True
                        # 특정 시장에서만 탈락한 경우
                        return 현재시장번호 in 탈락시장번호들
            
            return False
            
        except Exception as e:
            print(f"시장상황별 제외 확인 실패: {e}")
            return False  # 에러시 제외하지 않음
    
    def _제외기록을_키로_변환(self, 제외기록):
        """제외 기록을 전략 키로 변환"""
        try:
            전략정보 = 제외기록.get('전략정보', {})
            return f"{전략정보.get('매수기준', '')}-{전략정보.get('매수하락률', 0)}-{전략정보.get('구매방식', '')}-{전략정보.get('손절라인', 0)}-{전략정보.get('매도전략', '')}-{전략정보.get('수익라인', 0)}"
        except:
            return ""
    
    def _실시간_영구제외_확인(self, 전략, 탈락일):
        """실시간으로 영구 제외 조건 확인 및 간소화된 JSON 저장"""
        try:
            탈락횟수 = 전략.get('탈락횟수', 0)
            
            # 5회 이상 탈락시에만 영구제외 처리
            if 탈락횟수 >= 5:
                현재시장상황 = self._시장상황_판정(self.초기가격, 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                전략키 = self._전략을_키로_변환(전략)
                
                # 영구제외 전략 JSON 파일 로드 (새 구조)
                영구제외_파일 = self.영구제외_파일
                기존기록 = {}
                
                try:
                    if os.path.exists(영구제외_파일):
                        with open(영구제외_파일, 'r', encoding='utf-8') as f:
                            기존기록 = json.load(f)
                except:
                    기존기록 = {}
                
                # 전략이 이미 기록되어 있는지 확인
                if 전략키 in 기존기록:
                    # 기존 전략 - 탈락시장 추가
                    if 현재시장상황 not in 기존기록[전략키]["탈락시장"]:
                        기존기록[전략키]["탈락시장"].append(현재시장상황)
                        # 완전제외 여부 업데이트
                        기존기록[전략키]["완전제외"] = len(기존기록[전략키]["탈락시장"]) >= 3
                else:
                    # 새로운 전략
                    기존기록[전략키] = {
                        "탈락시장": [현재시장상황],
                        "완전제외": False
                    }
                
                # 안전한 JSON 파일 저장 (원자적 쓰기)
                self._안전한_json_저장(영구제외_파일, 기존기록)
                
        except Exception as e:
            print(f"   영구제외 확인 실패: {e}")
    
    def _제외사유_생성(self, 탈락횟수, 옐로우카드수, 탈락점수, 총점수, 제외유형, 영구제외대상):
        """제외 사유 메시지 생성"""
        if 제외유형 == "정상진행":
            return None
        elif 제외유형 == "일시제외":
            return f"탈락{탈락횟수}회 (4회 이하 일시제외)"
        elif 제외유형 == "영구제외" and 영구제외대상:
            return f"탈락{탈락횟수}회 (5회 이상 영구제외)"
        else:
            return f"알수없음: {제외유형}"
    
    def _극심손실_영구제외_처리(self, 전략, 수익률, 탈락일):
        """극심손실 발생 시 영구제외 처리 (배열 방식)"""
        try:
            # 완전한 전략키 생성
            전략키 = self._전략설명_생성(전략)
            
            # 실제 시장 상황 분석
            시장상황 = self._실제_시장상황_판단()
            시장매핑 = {"상승장": 1, "하락장": 2, "횡보장": 3}
            시장번호 = 시장매핑.get(시장상황, 3)
            
            # 기존 배열 데이터 로드
            압축데이터 = {
                "version": "2.0",
                "description": "영구제외 전략 히스토리 - 배열 형태",
                "structure": ["전략설명", "탈락시장목록", "완전제외여부"],
                "시장매핑": {"상승장": 1, "하락장": 2, "횡보장": 3},
                "strategies": []
            }
            
            if os.path.exists(self.영구제외_파일):
                try:
                    with open(self.영구제외_파일, 'r', encoding='utf-8') as f:
                        압축데이터 = json.load(f)
                except:
                    pass
            
            # 기존 전략 찾기
            기존전략_인덱스 = -1
            for i, 전략배열 in enumerate(압축데이터.get('strategies', [])):
                if len(전략배열) >= 3 and 전략배열[0] == 전략키:
                    기존전략_인덱스 = i
                    break
            
            
            if 기존전략_인덱스 >= 0:
                # 기존 전략 - 탈락시장 추가
                기존전략 = 압축데이터['strategies'][기존전략_인덱스]
                탈락시장목록 = 기존전략[1] if isinstance(기존전략[1], list) else []
                
                if 시장번호 not in 탈락시장목록:
                    탈락시장목록.append(시장번호)
                
                # 완전제외 여부 업데이트 (3개 시장 모두 탈락시)
                완전제외 = len(set(탈락시장목록)) >= 3
                
                # 배열 업데이트
                압축데이터['strategies'][기존전략_인덱스] = [
                    전략키,
                    탈락시장목록,
                    완전제외
                ]
            else:
                # 새로운 전략 추가
                새전략배열 = [
                    전략키,
                    [시장번호],
                    False  # 완전제외 = False (첫 탈락)
                ]
                압축데이터['strategies'].append(새전략배열)
            
            # 배열 파일 저장
            self._안전한_json_저장(self.영구제외_파일, 압축데이터)
            
        except Exception as e:
            print(f"   극심손실 영구제외 처리 실패: {e}")
    
    def _안전한_json_저장(self, 파일경로, 데이터):
        """원자적 JSON 파일 저장 (중간 중단시에도 파일 손상 방지)"""
        import tempfile
        import shutil
        
        try:
            # 임시 파일에 먼저 저장
            임시파일 = 파일경로 + '.tmp'
            
            with open(임시파일, 'w', encoding='utf-8') as f:
                json.dump(데이터, f, ensure_ascii=False, indent=2)
            
            # JSON 유효성 검증
            with open(임시파일, 'r', encoding='utf-8') as f:
                json.load(f)  # 파싱 테스트
            
            # 원본 파일로 원자적 이동 (Windows)
            if os.path.exists(파일경로):
                shutil.copy2(파일경로, 파일경로 + '.backup')  # 백업
            
            shutil.move(임시파일, 파일경로)  # 원자적 교체
            
            # 백업 파일 정리 (성공시)
            백업파일 = 파일경로 + '.backup'
            if os.path.exists(백업파일):
                os.remove(백업파일)
                
        except Exception as e:
            # 실패시 임시 파일 정리
            if os.path.exists(임시파일):
                os.remove(임시파일)
            
            # 백업에서 복구 시도
            백업파일 = 파일경로 + '.backup'
            if os.path.exists(백업파일):
                shutil.copy2(백업파일, 파일경로)
                os.remove(백업파일)
            
            print(f"   JSON 저장 실패, 백업에서 복구: {e}")
            raise  # 상위 예외 처리로 전달
    
    def _실제_시장상황_판단(self):
        """실제 시장 데이터 기반 시장 상황 판단"""
        # 최종 가격 변동률로 판단 (가장 정확)
        if hasattr(self, '최종가격') and hasattr(self, '초기가격'):
            전체변동률 = ((self.최종가격 - self.초기가격) / self.초기가격) * 100
        else:
            # 현재 시점 기준 계산
            현재가격 = self.시간데이터[-1] if hasattr(self, '시간데이터') and self.시간데이터 else self.초기가격
            전체변동률 = ((현재가격 - self.초기가격) / self.초기가격) * 100
        
        # 시장 분류 (27주 기준)
        if 전체변동률 > 13:
            return "상승장"
        elif 전체변동률 < -13:
            return "하락장"
        else:
            return "횡보장"
    
    def _승률_계산(self, 거래내역):
        """거래 승률 계산"""
        if not 거래내역 or len(거래내역) < 2:
            return 0
        
        매수거래 = {}
        수익거래 = 0
        총매도거래 = 0
        
        for 거래 in 거래내역:
            거래유형, 일차, 시간, 가격, 수량 = 거래
            
            if 거래유형 == '매수':
                if 일차 not in 매수거래:
                    매수거래[일차] = []
                매수거래[일차].append((가격, 수량))
            elif 거래유형 == '매도':
                # 간단히 매수 평균가와 비교
                if 매수거래:
                    총매수금액 = sum(가격 * 수량 for 일차_거래 in 매수거래.values() for 가격, 수량 in 일차_거래)
                    총매수수량 = sum(수량 for 일차_거래 in 매수거래.values() for _, 수량 in 일차_거래)
                    if 총매수수량 > 0:
                        평균매수가 = 총매수금액 / 총매수수량
                        if 가격 > 평균매수가:
                            수익거래 += 1
                        총매도거래 += 1
        
        return round((수익거래 / 총매도거래 * 100) if 총매도거래 > 0 else 0, 1)
    
    def _거래통계_분석(self, 전략들):
        """전략들의 거래 통계 분석"""
        print(f"\n거래 통계 분석 ({len(전략들)}개 전략)")
        print("="*60)
        
        총매수 = 0
        총매도 = 0  
        총손절 = 0
        총존버 = 0
        거래유형별 = {}
        
        for 전략 in 전략들[:10]:  # 상위 10개만 분석
            매수횟수 = 0
            매도횟수 = 0
            손절횟수 = 0
            
            for 거래 in 전략['거래내역']:
                거래유형 = 거래[0]
                if 거래유형 == '매수':
                    매수횟수 += 1
                elif '매도' in 거래유형:
                    매도횟수 += 1
                elif '손절' in 거래유형:
                    손절횟수 += 1
                
                거래유형별[거래유형] = 거래유형별.get(거래유형, 0) + 1
            
            총매수 += 매수횟수
            총매도 += 매도횟수
            총손절 += 손절횟수
            
            if len(전략['거래내역']) == 0:
                총존버 += 1
            
            # 개별 전략 요약
            평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            수익률 = ((평가자산 - 100000) / 100000) * 100
            
            if len(전략들) <= 5:  # 5개 이하면 개별 표시
                print(f"{전략['매수기준명']}-{전략['매수하락률']}%+{전략['매도전략명']}")
                print(f"   매수:{매수횟수}회 | 매도:{매도횟수}회 | 손절:{손절횟수}회 | 수익률:{수익률:+.1f}%")
        
        print(f"\n[통계 요약]")
        print(f"총 매수: {총매수}회")
        print(f"총 매도: {총매도}회") 
        print(f"총 손절: {총손절}회")
        print(f"거래 없음: {총존버}개 전략")
        
        if 총매수 > 0:
            print(f"매도율: {총매도/총매수*100:.1f}%")
            print(f"손절율: {총손절/총매수*100:.1f}%")
        
        print(f"\n거래 유형별 세부:")
        for 유형, 횟수 in sorted(거래유형별.items()):
            print(f"  {유형}: {횟수}회")
    
    def _최고전략_히스토리_조회(self):
        """저장된 최고 전략 히스토리 조회"""
        히스토리_파일 = self.최고전략_파일
        
        try:
            if os.path.exists(히스토리_파일):
                with open(히스토리_파일, 'r', encoding='utf-8') as f:
                    히스토리 = json.load(f)
                
                if not 히스토리:
                    print("저장된 최고 전략이 없습니다.")
                    return
                
                print(f"\n{'='*80}")
                print(f"최고 전략 히스토리 ({len(히스토리)}개)")
                print(f"{'='*80}")
                
                # 시뮬레이션 타입별로 그룹화
                타입별_기록 = {}
                for 기록 in 히스토리:
                    타입 = 기록['시뮬레이션타입']
                    if 타입 not in 타입별_기록:
                        타입별_기록[타입] = []
                    타입별_기록[타입].append(기록)
                
                for 타입, 기록들 in 타입별_기록.items():
                    print(f"\n🏆 {타입} ({len(기록들)}개):")
                    
                    # 최근 5개만 표시
                    for 기록 in 기록들[-5:]:
                        전략 = 기록['전략정보']
                        성과 = 기록['성과']
                        환경 = 기록['시장환경']
                        
                        print(f"  {기록['발견날짜']}")
                        print(f"     전략: {전략['매수기준']}-{전략['매수하락률']}% + {전략['매도전략']}")
                        print(f"     수익률: {성과['수익률']:+.1f}% | 거래: {성과['거래횟수']}회 | 승률: {성과['승률']}%")
                        print(f"     시장: {환경['시장수익률']:+.1f}% | 초기: {환경['초기가격']:.0f}원 → 최종: {환경['최종가격']:.0f}원")
                        
                        if 기록.get('추가정보') and '시나리오별성과' in 기록['추가정보']:
                            시나리오성과 = 기록['추가정보']['시나리오별성과']
                            print(f"     극한테스트: {len(시나리오성과)}개 시나리오, 평균 {sum(시나리오성과.values())/len(시나리오성과):+.1f}%")
                        print()
                
                return 히스토리
            else:
                print("아직 저장된 최고 전략이 없습니다.")
                return []
                
        except Exception as e:
            print(f"히스토리 조회 실패: {e}")
            return []
    
    def _히스토리_전략_재검증(self, 환경이름="현재환경"):
        """기존 최고 전략들을 현재 시장 환경에서 재검증"""
        히스토리 = self._최고전략_히스토리_조회()
        
        if not 히스토리:
            return
        
        print(f"\n{'='*80}")
        print(f"히스토리 전략 재검증: {환경이름}")
        print(f"{'='*80}")
        
        # 히스토리에서 고유한 전략들만 추출
        고유전략들 = []
        전략키들 = set()
        
        for 기록 in 히스토리:
            전략정보 = 기록['전략정보']
            키 = f"{전략정보['매수기준']}-{전략정보['매수하락률']}-{전략정보['구매방식']}-{전략정보['손절라인']}-{전략정보['매도전략']}"
            
            if 키 not in 전략키들:
                전략키들.add(키)
                
                # 전략 객체 재구성
                재구성전략 = {
                    '매수기준': '1' if '시가' in 전략정보['매수기준'] else '2' if '전일' in 전략정보['매수기준'] else '3' if '20일' in 전략정보['매수기준'] else '4' if '60일' in 전략정보['매수기준'] else '5',
                    '매수기준명': 전략정보['매수기준'],
                    '매수하락률': 전략정보['매수하락률'],
                    '구매방식': '1',
                    '구매방식명': 전략정보['구매방식'],
                    '매수수량': 0.1 if '10%' in 전략정보['구매방식'] else 0.3 if '30%' in 전략정보['구매방식'] else 0.5,
                    '손절라인': 전략정보['손절라인'],
                    '매도전략': '1' if '수익률' in 전략정보['매도전략'] else '2',
                    '매도전략명': 전략정보['매도전략'],
                    '수익라인': 전략정보.get('수익라인', 10),
                    '자본': 100000,
                    '주식수': 0,
                    '매수가격': 0,
                    '최고가격': 0,
                    '절반매도완료': False,
                    '이동평균': self.과거데이터.copy(),
                    '거래내역': [],
                    '가격기록': [],
                    '원본기록': 기록  # 원본 히스토리 참조
                }
                고유전략들.append(재구성전략)
        
        print(f"재검증할 고유 전략: {len(고유전략들)}개")
        
        # 현재 시장 데이터로 재검증
        재검증결과 = []
        
        for 전략 in 고유전략들:
            # 5주 시뮬레이션 실행
            임시전략 = self._전략_초기화(전략)
            
            for 일차 in range(135):  # 27주 = 135일
                self._일일_시뮬레이션(임시전략, 일차)
            
            # 결과 계산
            최종평가 = 임시전략['자본'] + 임시전략['주식수'] * (임시전략['이동평균'][-1] if 임시전략['이동평균'] else self.초기가격)
            수익률 = ((최종평가 - 100000) / 100000) * 100
            
            재검증결과.append({
                '전략': 전략,
                '수익률': 수익률,
                '거래횟수': len(임시전략['거래내역']),
                '원본성과': 전략['원본기록']['성과']['수익률'],
                '성과차이': 수익률 - 전략['원본기록']['성과']['수익률']
            })
        
        # 결과 정렬 및 출력
        재검증결과.sort(key=lambda x: x['수익률'], reverse=True)
        
        print(f"\n재검증 결과:")
        print("-" * 100)
        print(f"{'순위':<4} {'전략명':<40} {'현재수익률':<10} {'원본수익률':<10} {'성과차이':<10} {'거래횟수':<8}")
        print("-" * 100)
        
        for i, 결과 in enumerate(재검증결과[:10]):  # 상위 10개만
            전략 = 결과['전략']
            print(f"{i+1:<4} {전략['매수기준명']}-{전략['매수하락률']}%+{전략['매도전략명']:<25} "
                  f"{결과['수익률']:+7.1f}% {결과['원본성과']:+9.1f}% {결과['성과차이']:+8.1f}% {결과['거래횟수']:>7}회")
        
        # 최고 재검증 전략 저장
        if 재검증결과:
            최고재검증 = 재검증결과[0]
            추가정보 = {
                '재검증환경': 환경이름,
                '원본성과': 최고재검증['원본성과'],
                '성과차이': 최고재검증['성과차이'],
                '재검증전략수': len(재검증결과)
            }
            self._최고전략_히스토리_저장([최고재검증['전략']], '재검증', 추가정보)
    
    def _극한검증_시뮬레이션(self, 후보전략들):
        """극한 환경에서 최종 검증"""
        print(f"\n{'='*80}")
        print(f"2단계 극한 검증 시뮬레이션")
        print(f"{'='*80}")
        
        # 다양한 극한 환경 시나리오
        극한시나리오들 = [
            {'이름': '극심한변동성', '설명': '주별 ±50% 변동', '주변동범위': 50},
            {'이름': '장기하락장', '설명': '전체 -40% 추세', '주변동범위': 25, '추세': -2.0},
            {'이름': '장기상승장', '설명': '전체 +50% 추세', '주변동범위': 25, '추세': +2.5},
            {'이름': '극한횡보장', '설명': '변동폭 ±3% 제한', '주변동범위': 3},
            {'이름': '급락급등장', '설명': '일별 ±15% 변동', '주변동범위': 20, '일변동': 15},
            {'이름': '패턴반복장', '설명': '주별 +10,-5,+8,-3,+6 패턴', '패턴': [10,-5,8,-3,6]}
        ]
        
        전략별점수 = {i: 0 for i in range(len(후보전략들))}
        시나리오별결과 = []
        
        for 시나리오 in 극한시나리오들:
            print(f"\n{시나리오['이름']}: {시나리오['설명']}")
            
            # 시나리오별 데이터 생성
            시나리오데이터 = self._시나리오_데이터_생성(시나리오)
            
            # 각 후보 전략 테스트
            시나리오결과 = []
            for i, 전략 in enumerate(후보전략들):
                # 전략 초기화
                테스트전략 = self._전략_초기화(전략)
                
                # 135일 (27주) 시뮬레이션
                for 일차 in range(135):
                    self._일일_시뮬레이션_시나리오(테스트전략, 일차, 시나리오데이터)
                
                # 최종 결과 계산
                최종평가 = 테스트전략['자본'] + 테스트전략['주식수'] * (테스트전략['이동평균'][-1] if 테스트전략['이동평균'] else self.초기가격)
                수익률 = ((최종평가 - 100000) / 100000) * 100
                
                시나리오결과.append({
                    '전략번호': i,
                    '전략': 전략,
                    '수익률': 수익률,
                    '최종자산': 최종평가
                })
            
            # 시나리오 결과 정렬 및 점수 부여
            시나리오결과.sort(key=lambda x: x['수익률'], reverse=True)
            for 순위, 결과 in enumerate(시나리오결과):
                점수 = len(후보전략들) - 순위  # 1등: 최고점수, 꼴등: 1점
                전략별점수[결과['전략번호']] += 점수
            
            # 시나리오별 TOP3 출력
            print("  TOP 3 결과:")
            for i, 결과 in enumerate(시나리오결과[:3]):
                전략 = 결과['전략']
                print(f"  {i+1}. [{전략['매수기준명']}-{전략['매수하락률']}%+{전략['매도전략명']}] → {결과['수익률']:+.1f}%")
            
            시나리오별결과.append(시나리오결과)
        
        # 최종 종합 순위
        print(f"\n{'='*60}")
        print(f"극한 검증 종합 순위")
        print(f"{'='*60}")
        
        종합순위 = [(전략번호, 점수) for 전략번호, 점수 in 전략별점수.items()]
        종합순위.sort(key=lambda x: x[1], reverse=True)
        
        print("순위 | 전략 | 종합점수 | 평균수익률")
        print("-"*60)
        
        for 순위, (전략번호, 종합점수) in enumerate(종합순위):
            전략 = 후보전략들[전략번호]
            
            # 평균 수익률 계산
            수익률들 = []
            for 시나리오결과 in 시나리오별결과:
                for 결과 in 시나리오결과:
                    if 결과['전략번호'] == 전략번호:
                        수익률들.append(결과['수익률'])
            평균수익률 = sum(수익률들) / len(수익률들)
            
            print(f"{순위+1:2d}위 | [{전략['매수기준명']}-{전략['매수하락률']}%+{전략['매도전략명']}] | {종합점수:2d}점 | {평균수익률:+.1f}%")
        
        # 최고 전략 상세 분석
        최고전략번호 = 종합순위[0][0]
        최고전략 = 후보전략들[최고전략번호]
        
        print(f"\n극한 검증 최고 전략:")
        print(f"전략: {최고전략['매수기준명']}-{최고전략['매수하락률']}% + {최고전략['구매방식명']} + 손절{최고전략['손절라인']}% + {최고전략['매도전략명']}")
        print(f"종합 점수: {종합순위[0][1]}점 / {len(극한시나리오들) * len(후보전략들)}점 만점")
        
        print(f"\n시나리오별 성과:")
        시나리오별성과 = {}
        for i, 시나리오 in enumerate(극한시나리오들):
            for 결과 in 시나리오별결과[i]:
                if 결과['전략번호'] == 최고전략번호:
                    시나리오별성과[시나리오['이름']] = 결과['수익률']
                    print(f"  {시나리오['이름']}: {결과['수익률']:+.1f}%")
        
        # 극한 검증 최고 전략 히스토리 저장
        추가정보 = {
            '종합점수': 종합순위[0][1],
            '만점': len(극한시나리오들) * len(후보전략들),
            '시나리오별성과': 시나리오별성과,
            '테스트시나리오': len(극한시나리오들)
        }
        self._최고전략_히스토리_저장([최고전략], '극한검증', 추가정보)
        
        # 상황별 최적 전략 분석
        상황별최적전략 = self._상황별_최적전략_분석(후보전략들, 시나리오별결과, 극한시나리오들)
        
        # 검증된 전략 세트 저장
        검증완료전략 = {
            '최종검증완료': True,
            '검증일시': time.strftime("%Y-%m-%d %H:%M:%S"),
            '종합최고전략': 최고전략,
            '상황별최적전략': 상황별최적전략,
            '전체순위': [(후보전략들[전략번호], 점수) for 전략번호, 점수 in 종합순위]
        }
        
        try:
            with open(self.포트폴리오_파일, 'w', encoding='utf-8') as f:
                # JSON 직렬화 가능한 형태로 변환
                저장데이터 = {
                    '검증일시': 검증완료전략['검증일시'],
                    '종합최고전략': self._전략_직렬화(최고전략, 종합순위[0][1]),
                    '상황별최적전략': {}
                }
                
                # 상황별 전략 저장
                for 상황, 전략정보 in 상황별최적전략.items():
                    저장데이터['상황별최적전략'][상황] = {
                        '전략': self._전략_직렬화(전략정보['전략'], 0),
                        '수익률': 전략정보['수익률'],
                        '설명': 전략정보['설명']
                    }
                
                json.dump(저장데이터, f, ensure_ascii=False, indent=2)
            print(f"\n극한 검증 완료! 전략 포트폴리오가 저장되었습니다.")
        except Exception as e:
            print(f"검증 결과 저장 실패: {e}")
    
    def _상황별_최적전략_분석(self, 후보전략들, 시나리오별결과, 극한시나리오들):
        """각 상황별로 최적 전략 찾기"""
        print(f"\n{'='*60}")
        print(f"상황별 최적 전략 분석")
        print(f"{'='*60}")
        
        상황별최적전략 = {}
        
        for i, 시나리오 in enumerate(극한시나리오들):
            시나리오결과 = 시나리오별결과[i]
            최적결과 = max(시나리오결과, key=lambda x: x['수익률'])
            최적전략 = 최적결과['전략']
            
            상황별최적전략[시나리오['이름']] = {
                '전략': 최적전략,
                '수익률': 최적결과['수익률'],
                '설명': 시나리오['설명']
            }
            
            print(f"\n{시나리오['이름']} ({시나리오['설명']}):")
            print(f"   최적전략: [{최적전략['매수기준명']}-{최적전략['매수하락률']}% + {최적전략['구매방식명']} + 손절{최적전략['손절라인']}% + {최적전략['매도전략명']}]")
            print(f"   수익률: {최적결과['수익률']:+.1f}%")
        
        # 전략 다양성 분석
        print(f"\n전략 다양성 분석:")
        전략세트 = set()
        for 상황, 전략정보 in 상황별최적전략.items():
            전략키 = self._전략을_키로_변환(전략정보['전략'])
            전략세트.add(전략키)
        
        print(f"   총 {len(상황별최적전략)}개 상황 중 {len(전략세트)}개의 서로 다른 전략 필요")
        
        if len(전략세트) == 1:
            print(f"   모든 상황에 만능인 전략 발견!")
        elif len(전략세트) <= 3:
            print(f"   소수 전략으로 모든 상황 대응 가능")
        else:
            print(f"   상황별로 다른 전략 필요 (다양성 높음)")
        
        return 상황별최적전략
    
    def _전략_직렬화(self, 전략, 점수):
        """전략을 JSON 저장 가능한 형태로 변환"""
        return {
            '매수기준': 전략['매수기준'],
            '매수기준명': 전략['매수기준명'],
            '매수하락률': 전략['매수하락률'],
            '구매방식': 전략['구매방식'],
            '구매방식명': 전략['구매방식명'],
            '매수수량': 전략['매수수량'],
            '손절라인': 전략['손절라인'],
            '매도전략': 전략['매도전략'],
            '매도전략명': 전략['매도전략명'],
            '수익라인': 전략['수익라인'],
            '점수': 점수
        }
    
    def _시나리오_데이터_생성(self, 시나리오):
        """시나리오별 특수 데이터 생성"""
        if '패턴' in 시나리오:
            # 패턴 반복 모드
            주별데이터 = 시나리오['패턴'].copy()
        else:
            # 일반 랜덤 생성
            주별데이터 = []
            for 주차 in range(5):
                if '추세' in 시나리오:
                    # 추세가 있는 경우
                    기본변동 = random.uniform(-시나리오['주변동범위'], 시나리오['주변동범위'])
                    추세변동 = 시나리오['추세'] * (주차 + 1)  # 시간에 따른 추세 강화
                    변동률 = 기본변동 + 추세변동
                else:
                    # 일반 랜덤 변동
                    변동률 = random.uniform(-시나리오['주변동범위'], 시나리오['주변동범위'])
                주별데이터.append(변동률)
        
        # 계층적 데이터 생성
        임시분석기 = 최적화투자분석(self.초기가격)
        임시분석기.계층적_변동률_생성(주별데이터)
        
        # 특수 변동 적용
        if '일변동' in 시나리오:
            # 일별 극한 변동 추가
            for i in range(len(임시분석기.일간데이터)):
                극한변동 = random.uniform(-시나리오['일변동'], 시나리오['일변동'])
                임시분석기.일간데이터[i] += 극한변동
        
        return 임시분석기.시간데이터
    
    def _전략_초기화(self, 원본전략):
        """전략 복사 및 초기화"""
        return {
            '매수기준': 원본전략['매수기준'],
            '매수기준명': 원본전략['매수기준명'],
            '매수하락률': 원본전략['매수하락률'],
            '구매방식': 원본전략['구매방식'],
            '구매방식명': 원본전략['구매방식명'],
            '매수수량': 원본전략['매수수량'],
            '손절라인': 원본전략['손절라인'],
            '매도전략': 원본전략['매도전략'],
            '매도전략명': 원본전략['매도전략명'],
            '수익라인': 원본전략['수익라인'],
            '자본': 100000,
            '주식수': 0,
            '매수가격': 0,
            '최고가격': 0,
            '절반매도완료': False,
            '이동평균': self.과거데이터.copy(),  # 과거 120일 데이터로 초기화
            '거래내역': []
        }
    
    def _일일_시뮬레이션_시나리오(self, 전략, 일차, 시나리오데이터):
        """시나리오 데이터를 사용한 일일 시뮬레이션"""
        # 기존 일일 시뮬레이션과 동일하지만 시나리오데이터 사용
        전일종가 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
        현재가격 = 전일종가
        
        for 시간 in range(7):
            시간인덱스 = 일차 * 7 + 시간
            if 시간인덱스 >= len(시나리오데이터):
                break
                
            변동률 = 시나리오데이터[시간인덱스]
            현재가격 = 현재가격 * (1 + 변동률/100)
            현재가격 = int(현재가격 * 10) / 10
            
            # 매매 로직 실행 (첫 시간 제요)
            if 시간 > 0:  # 첫 번째 시간은 매수/매도 금지
                self._전략_매매_실행_시나리오(전략, 현재가격, 전일종가, 일차, 시간, 시나리오데이터)
        
        # 이동평균 업데이트 (최대 120일 유지)
        전략['이동평균'].append(현재가격)
        if len(전략['이동평균']) > 120:
            전략['이동평균'].pop(0)
    
    def _전략_매매_실행_시나리오(self, 전략, 현재가격, 전일종가, 일차, 시간, 시나리오데이터):
        """시나리오용 매매 실행 (기존 로직과 동일)"""
        # 기존 _전략_매매_실행과 동일한 로직
        # 손절 체크
        if 전략['주식수'] > 0 and 전략['매수가격'] > 0:
            손실률 = ((현재가격 - 전략['매수가격']) / 전략['매수가격']) * 100
            if 손실률 <= 전략['손절라인']:
                매도금액 = 전략['주식수'] * 현재가격
                전략['자본'] += 매도금액
                전략['주식수'] = 0
                전략['매수가격'] = 0  # 매수가 초기화
                전략['절반매도완료'] = False
                return True
        
        # 매수 체크 (모든 기준 지원)
        if 전략['자본'] > 현재가격 and 전략['주식수'] == 0:
            매수신호 = False
            
            if 전략['매수기준'] == '1':  # 시가 대비 하락
                시가 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
                시가대비변동 = ((현재가격 - 시가) / 시가) * 100
                if 시가대비변동 <= -전략['매수하락률']:
                    매수신호 = True
                    
            elif 전략['매수기준'] == '2':  # 전일 종가 대비
                전일대비변동 = ((현재가격 - 전일종가) / 전일종가) * 100
                if 전일대비변동 <= -전략['매수하락률']:
                    매수신호 = True
                    
            elif 전략['매수기준'] == '3':  # 20일선 이탈
                if len(전략['이동평균']) >= 20:
                    평균가 = sum(전략['이동평균'][-20:]) / 20
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '4':  # 60일선 이탈
                if len(전략['이동평균']) >= 60:
                    평균가 = sum(전략['이동평균'][-60:]) / 60
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
                        
            elif 전략['매수기준'] == '5':  # 120일선 이탈
                if len(전략['이동평균']) >= 120:
                    평균가 = sum(전략['이동평균'][-120:]) / 120
                    평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                    if 평균대비 <= -전략['매수하락률']:
                        매수신호 = True
            
            if 매수신호:
                if 전략['구매방식'] == '1':
                    매수금액 = 전략['자본'] * 전략['매수수량']
                    매수주식 = int(매수금액 / 현재가격)  # 정수 변환
                else:  # 방식 2: 고정 주식수
                    # 전략['매수수량']은 이미 초기에 계산된 고정 주식수
                    매수주식 = 전략['매수수량']
                    매수금액 = min(현재가격 * 매수주식, 전략['자본'])
                
                # 평균 매수가 계산 (기존 보유 + 신규 매수)
                기존총액 = 전략['주식수'] * 전략['매수가격'] if 전략['주식수'] > 0 else 0
                신규총액 = 매수주식 * 현재가격
                총보유주식 = 전략['주식수'] + 매수주식
                
                전략['주식수'] = 총보유주식
                전략['자본'] -= 매수금액
                전략['매수가격'] = (기존총액 + 신규총액) / 총보유주식  # 평균 매수가
        
        # 매도 체크 (간소화된 버전)
        if 전략['주식수'] > 0:
            수익률 = ((현재가격 - 전략['매수가격']) / 전략['매수가격']) * 100
            
            if 전략['매도전략'] == '2' and 수익률 >= 전략['수익라인']:  # 일괄 매도만
                매도금액 = 전략['주식수'] * 현재가격
                전략['자본'] += 매도금액
                전략['주식수'] = 0
                전략['매수가격'] = 0  # 매수가 초기화
        
        return False
    
    def 대화형_시뮬레이션(self):
        """시간별 변동을 보여주며 하루씩 진행하는 대화형 시뮬레이션"""
        print(f"\n=== 대화형 투자 시뮬레이션 ===")
        print(f"초기 주식 가격: {self.초기가격}원\n")
        
        # 매수 전략 선택
        print("=== 매수 전략 설정 ===")
        print("매수 기준 선택:")
        print("1. 시가 대비 하락시 매수 (장중 하락 포착)")
        print("2. 전일 종가 대비 하락시 매수 (갭하락 포착)")
        print("3. 20일선 이탈시 매수 (단기 기술적 분석)")
        print("4. 60일선 이탈시 매수 (중기 기술적 분석)")
        print("5. 120일선 이탈시 매수 (장기 기술적 분석)")
        매수기준 = input("선택 (1, 2, 3, 4, 5): ")
        
        매수하락률 = float(input("몇 % 하락시 매수? (예: 2는 -2%): "))
        
        print("\n구매 비율 선택:")
        print("1. 퍼센트 방식 (자본의 %)")
        print("2. 고정 주식수 방식")
        방식 = input("선택 (1 또는 2): ")
        
        if 방식 == "1":
            매수비율 = float(input("자본의 몇 % 매수? (예: 30은 30%): ")) / 100
        else:
            매수주식수 = int(input("몇 주씩 매수? (예: 10): "))
            매수비율 = None
        
        # 매도 전략 선택
        print("\n=== 매도 전략 설정 ===")
        
        # 손절 라인 설정
        손절라인 = float(input("손절 라인 설정 (예: -3은 -3%): "))
        
        # 익절 전략 선택
        print("\n익절 전략 선택:")
        print("1. 분할 매도 (절반씩)")
        print("2. 목표가 일괄 매도")
        print("3. 트레일링 스탑 (고점 대비 %)")
        전략 = input("선택 (1, 2, 3): ")
        
        if 전략 == "1":
            수익라인 = float(input("1차 매도 수익률 (예: 3은 +3%): "))
        elif 전략 == "2":
            수익라인 = float(input("목표 수익률 (예: 5는 +5%): "))
        else:  # 트레일링 스탑
            수익라인 = float(input("최고점 대비 몇% 하락시 매도? (예: 2): "))
        
        return self._실행_시뮬레이션(매수기준, 매수하락률, 방식, 매수비율 if 방식 == "1" else 매수주식수, 
                                     손절라인, 전략, 수익라인)
    
    def _실행_시뮬레이션(self, 매수기준, 매수하락률, 구매방식, 매수수량, 손절라인, 전략, 수익라인):
        """실제 시뮬레이션 실행"""
        자본 = 100000
        주식수 = 0
        현재가격 = self.초기가격
        거래내역 = []
        절반매도완료 = False
        매수가격 = 0
        전일종가 = self.초기가격  # 전일 종가 추적
        최고가격 = 0  # 트레일링 스탑용
        이동평균 = self.과거데이터.copy()  # 과거 120일 데이터로 초기화
        
        print(f"\n시작 자본: 100,000원")
        print(f"시작 주가: {self.초기가격:.0f}원")
        print("="*60)
        
        for 일차 in range(135):  # 27주 = 135일
            주차 = (일차 // 5) + 1  # 현재 주차 계산
            
            print(f"\n === {주차}주차 {일차+1}일 ===")
            일시작가격 = 현재가격
            
            # 전일 대비 변동률 계산
            전일대비 = ((일시작가격 - 전일종가) / 전일종가) * 100 if 일차 > 0 else 0
            # 초기가격 대비 변동률 계산
            초기대비 = ((일시작가격 - self.초기가격) / self.초기가격) * 100
            
            print(f"시가: {일시작가격:.1f}원 (전일대비: {전일대비:+.1f}%, 초기대비: {초기대비:+.1f}%)")
            print("-"*40)
            
            # 시간별 데이터를 먼저 모두 계산
            시간별결과 = []
            for 시간 in range(7):  # 하루 7시간 (첫 시간은 시가 설정용)
                시간인덱스 = 일차 * 7 + 시간
                변동률 = self.시간데이터[시간인덱스]
                이전가격 = 현재가격
                현재가격 = 이전가격 * (1 + 변동률/100)
                # 소수점 1자리까지만 (버림)
                현재가격 = int(현재가격 * 10) / 10
                
                거래정보 = ""
                거래발생 = False
                
                # 첫 시간은 매매 금지 (시가 설정용)
                if 시간 == 0:
                    시간별결과.append({
                        '시간': 시간 + 1,
                        '변동률': 변동률,
                        '현재가격': 현재가격,
                        '거래': '시가설정'
                    })
                    continue
                
                # 손절 체크
                if 주식수 > 0 and 매수가격 > 0:
                    손실률 = ((현재가격 - 매수가격) / 매수가격) * 100
                    if 손실률 <= 손절라인:
                        매도금액 = 주식수 * 현재가격
                        자본 += 매도금액
                        거래내역.append(('손절', 일차+1, 시간+1, 현재가격, 주식수))
                        거래정보 = f" 손절! {손실률:.1f}% 손실, {주식수:.1f}주 매도"
                        주식수 = 0
                        매수가격 = 0  # 매수가 초기화
                        거래발생 = True
                        절반매도완료 = False
                
                # 매수 체크
                if not 거래발생 and 자본 > 현재가격 and 주식수 == 0:
                    매수신호 = False
                    
                    if 매수기준 == "1":  # 시가 대비 하락
                        일대비변동 = ((현재가격 - 일시작가격) / 일시작가격) * 100
                        if 일대비변동 <= -매수하락률:
                            매수신호 = True
                    elif 매수기준 == "2":  # 전일 종가 대비 하락
                        전일대비변동 = ((현재가격 - 전일종가) / 전일종가) * 100 if 일차 > 0 else 0
                        if 전일대비변동 <= -매수하락률:
                            매수신호 = True
                    elif 매수기준 == '3':  # 20일선 이탈
                        if len(이동평균) >= 20:
                            평균가 = sum(이동평균[-20:]) / 20
                            평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                            if 평균대비 <= -매수하락률:
                                매수신호 = True
                    elif 매수기준 == '4':  # 60일선 이탈
                        if len(이동평균) >= 60:
                            평균가 = sum(이동평균[-60:]) / 60
                            평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                            if 평균대비 <= -매수하락률:
                                매수신호 = True
                    elif 매수기준 == '5':  # 120일선 이탈
                        if len(이동평균) >= 120:
                            평균가 = sum(이동평균[-120:]) / 120
                            평균대비 = ((현재가격 - 평균가) / 평균가) * 100
                            if 평균대비 <= -매수하락률:
                                매수신호 = True
                    
                    if 매수신호:
                        if 구매방식 == "1":  # 퍼센트 방식
                            매수금액 = 자본 * 매수수량  # 매수수량은 비율
                            매수주식 = int(매수금액 / 현재가격)  # 정수 변환
                        else:  # 초기 설정 고정 주식수 방식
                            # 첫 매수 시점에 초기자본과 초기가격으로 계산한 고정 주식수를 사용
                            # 매수수량 = 초기에 계산된 고정 주식수
                            매수주식 = 매수수량  # 이미 주식수로 설정됨
                            매수금액 = min(현재가격 * 매수주식, 자본)
                        
                        # 평균 매수가 계산 (기존 보유 + 신규 매수)
                        기존총액 = 주식수 * 매수가격 if 주식수 > 0 else 0
                        신규총액 = 매수주식 * 현재가격
                        총보유주식 = 주식수 + 매수주식
                        
                        주식수 = 총보유주식
                        자본 -= 매수금액
                        매수가격 = (기존총액 + 신규총액) / 총보유주식  # 평균 매수가
                        거래내역.append(('매수', 일차+1, 시간+1, 현재가격, 매수주식))
                        거래정보 = f" 매수! {매수주식:.1f}주 @ {현재가격:.0f}원 (평균가:{매수가격:.1f}원)"
                        거래발생 = True
                
                # 매도 체크
                if not 거래발생 and 주식수 > 0:
                    수익률 = ((현재가격 - 매수가격) / 매수가격) * 100
                    
                    # 최고가 업데이트 (트레일링 스탑용)
                    if 현재가격 > 최고가격:
                        최고가격 = 현재가격
                    
                    if 전략 == "1" and not 절반매도완료:  # 분할 매도 전략
                        if 수익률 >= 수익라인:  # 1차 목표 도달시 절반 매도
                            매도주식 = 주식수 * 0.5
                            매도금액 = 매도주식 * 현재가격
                            주식수 -= 매도주식
                            자본 += 매도금액
                            절반매도완료 = True
                            거래내역.append(('절반매도', 일차+1, 시간+1, 현재가격, 매도주식))
                            거래정보 = f" 절반매도! {매도주식:.1f}주, 수익률 +{수익률:.1f}%"
                    
                    elif 전략 == "2":  # 목표가 일괄 매도
                        if 수익률 >= 수익라인:
                            매도금액 = 주식수 * 현재가격
                            자본 += 매도금액
                            거래내역.append(('전량매도', 일차+1, 시간+1, 현재가격, 주식수))
                            거래정보 = f" 전량매도! {주식수:.1f}주, 수익률 +{수익률:.1f}%"
                            주식수 = 0
                            매수가격 = 0  # 매수가 초기화
                            절반매도완료 = False
                            최고가격 = 0
                    
                    elif 전략 == "3":  # 트레일링 스탑
                        고점대비 = ((최고가격 - 현재가격) / 최고가격) * 100
                        if 고점대비 >= 수익라인:  # 고점 대비 하락률 도달
                            매도금액 = 주식수 * 현재가격
                            자본 += 매도금액
                            거래내역.append(('트레일링스탑', 일차+1, 시간+1, 현재가격, 주식수))
                            거래정보 = f" 트레일링스탑! 고점({최고가격:.0f})대비 -{고점대비:.1f}%"
                            주식수 = 0
                            매수가격 = 0  # 매수가 초기화
                            최고가격 = 0
                
                # 시가 대비 변동률 계산 (하루 기준)
                시가대비 = ((현재가격 - 일시작가격) / 일시작가격) * 100
                
                시간별결과.append({
                    '시간': 시간+1,
                    '이전가격': 이전가격,
                    '현재가격': 현재가격,
                    '변동률': 변동률,
                    '시가대비': 시가대비,
                    '거래정보': 거래정보
                })
            
            # 시간별 결과 출력
            for 결과 in 시간별결과:
                print(f"  {결과['시간']}시간: {결과['이전가격']:.0f} → {결과['현재가격']:.0f} (직전대비: {결과['변동률']:+.2f}%, 시가대비: {결과['시가대비']:+.1f}%){결과['거래정보']}")
            
            # 하루 마감 정보
            print("-"*40)
            일변동률 = ((현재가격 - 일시작가격) / 일시작가격) * 100
            전일대비종가 = ((현재가격 - 전일종가) / 전일종가) * 100 if 일차 > 0 else 0
            초기대비종가 = ((현재가격 - self.초기가격) / self.초기가격) * 100
            평가자산 = 자본 + 주식수 * 현재가격
            수익률 = ((평가자산 - 100000) / 100000) * 100
            
            print(f" 일 마감 현황:")
            print(f"  종가: {현재가격:.1f}원")
            print(f"  ├─ 일중 변동: {일변동률:+.1f}% (시가 {일시작가격:.1f} → 종가 {현재가격:.1f})")
            print(f"  ├─ 전일 대비: {전일대비종가:+.1f}%" + (f" (전일 종가 {전일종가:.1f}원)" if 일차 > 0 else " (첫날)"))
            print(f"  └─ 초기 대비: {초기대비종가:+.1f}% (초기가 {self.초기가격:.1f}원)")
            print(f"  보유현금: {자본:,.0f}원")
            print(f"  보유주식: {주식수:.1f}주")
            print(f"  평가자산: {평가자산:,.0f}원 (수익률: {수익률:+.1f}%)")
            
            # 주 마감 시 주간 요약
            if (일차 + 1) % 5 == 0:
                주차 = (일차 // 5) + 1
                print(f"\n === {주차}주차 마감 ===")
                print(f"  주간 초기대비: {초기대비종가:+.1f}%")
                print(f"  주간 수익률: {수익률:+.1f}%")
            
            # 이동평균용 가격 기록 (일 종가 기준)
            이동평균.append(현재가격)
            if len(이동평균) > 120:
                이동평균.pop(0)  # 120일치만 유지
            
            # 전일 종가 업데이트
            전일종가 = 현재가격
            
            # 자본 탈락 체크 후 엔터키 대기
            if 일차 < 134 and (일차 % 5 == 4):  # 주내일차 5일째 (금요일)
                현재자본 = 자본 + 주식수 * 현재가격
                if 현재자본 <= 60000:  # 탈락 기준
                    주차 = (일차 // 5) + 1
                    print(f"\n{주차}주차 자본 탈락! 현재 자본: {현재자본:,.0f}원")
                    break  # 탈락시 시뮬레이션 종료
        
        # 최종 결과
        최종자산 = 자본 + 주식수 * 현재가격
        수익률 = ((최종자산 - 100000) / 100000) * 100
        
        return {
            '수익률': 수익률,
            '최종자산': 최종자산,
            '거래내역': 거래내역,
            '최종주식수': 주식수,
            '최종현금': 자본
        }
    
    def 매매시뮬레이션(self, 매수기준, 매도기준, 시간범위, 전략=None):
        """지정된 시간 범위에서 매매 시뮬레이션
        매수기준: 시가 대비 몇% 떨어질 때 매수 (음수, 시가하락 전용)
        매도기준: 시가 대비 몇% 오를 때 매도 (양수)
        전략: 전체 전략 정보 (다양한 매수 기준 처리용)
        """
        자본 = 100000
        주식수 = 0
        시작가격 = self.초기가격
        현재가격 = 시작가격
        거래내역 = []
        
        # 일별 시가 저장
        일별시가 = {}
        
        데이터슬라이스 = self.시간데이터[:시간범위]
        
        for i, 변동률 in enumerate(데이터슬라이스):
            일차 = i // 7 + 1
            
            # 가격 업데이트 먼저
            이전가격 = 현재가격
            현재가격 = 이전가격 * (1 + 변동률/100)
            
            # 하루의 첫 시간에 시가 설정 (업데이트된 가격으로)
            if i % 6 == 0:
                일별시가[일차] = 현재가격
            
            # 시가 대비 변돐률 계산
            시가 = 일별시가[일차]
            시가대비변돐률 = ((현재가격 - 시가) / 시가) * 100
            
            # 매수 조건: 전략별 다양한 매수 기준 처리
            매수신호 = False
            
            if 전략 and '매수기준' in 전략:
                매수기준타입 = 전략['매수기준']
                
                if 매수기준타입 == '1':  # 시가하락
                    if 시가대비변돐률 <= 매수기준 and 자본 > 현재가격:
                        매수신호 = True
                        
                elif 매수기준타입 == '6':  # 시가상승 (상승매수)
                    상승률 = 전략.get('매수상승률', 1.0)
                    if 시가대비변돐률 >= 상승률 and 자본 > 현재가격:
                        매수신호 = True
                        
                elif 매수기준타입 in ['2', '3', '4', '5']:  # 기타 하락 전략들
                    # 단순화: 시가하락과 동일하게 처리 (임시)
                    하락률 = 전략.get('매수하락률', abs(매수기준))
                    if 시가대비변돐률 <= -하락률 and 자본 > 현재가격:
                        매수신호 = True
                        
            else:
                # 기존 방식: 시가하락만 (하위 호환성)
                if 시가대비변돐률 <= 매수기준 and 자본 > 현재가격:
                    매수신호 = True
            
            if 매수신호:
                매수금액 = min(자본 * 0.25, 자본)
                매수주식 = int(매수금액 / 현재가격)  # 정수 변환
                주식수 += 매수주식
                자본 -= 매수금액
                거래내역.append(('매수', i, 시가대비변돐률, 현재가격))
            
            # 매도 조건 확인 (보유 주식이 있을 때만)
            if 주식수 > 0:
                # 손절 조건 우선 확인
                if 전략 and '손절라인' in 전략:
                    손절라인 = 전략['손절라인']  # 음수값 (예: -3.0)
                    if 시가대비변돐률 <= 손절라인:
                        # 손절: 전량 매도
                        매도금액 = 주식수 * 현재가격
                        자본 += 매도금액
                        거래내역.append(('손절', i, 시가대비변돐률, 현재가격))
                        주식수 = 0
                # 익절 조건
                elif 시가대비변돐률 >= 매도기준:
                    매도주식 = 주식수 * 0.4
                    매도금액 = 매도주식 * 현재가격
                    주식수 -= 매도주식
                    자본 += 매도금액
                    거래내역.append(('익절', i, 시가대비변돐률, 현재가격))
        
        최종자산 = 자본 + 주식수 * 현재가격
        수익률 = (최종자산 - 100000) / 100000 * 100
        
        return {
            '수익률': 수익률,
            '최종자산': 최종자산,
            '거래횟수': len(거래내역),
            '거래내역': 거래내역,
            '시간범위': 시간범위,
            '일수': 시간범위 // 7,
            '최종현금': 자본,
            '최종주식수': 주식수
        }
    
    def 전략_거래_상세보기(self, 전략, 시간범위=27):
        """특정 전략의 거래 내역 상세 출력"""
        print(f"\n전략 거래 상세 분석")
        print(f"   매수기준: {전략['매수기준']}, 하락률: {전략.get('매수하락률', 0):.1f}%")
        print(f"   손절라인: {전략.get('손절라인', 0):.1f}%, 수익라인: {전략.get('수익라인', 0):.1f}%")
        print("-" * 60)
        
        매수기준값 = -abs(전략['매수하락률']) if 전략['매수하락률'] > 0 else 전략['매수하락률']
        결과 = self.매매시뮬레이션(매수기준값, 전략['수익라인'], 시간범위, 전략)
        
        print(f"결과:")
        print(f"   최종 수익률: {결과['수익률']:+.2f}%")
        print(f"   거래 횟수: {결과['거래횟수']}회")
        print(f"   최종 자산: {결과['최종자산']:,.0f}원 (초기: 100,000원)")
        print(f"   ├ 현금: {결과['최종현금']:,.0f}원")
        주식평가액 = 결과['최종자산'] - 결과['최종현금']
        print(f"   └ 주식평가액: {주식평가액:,.0f}원 ({결과['최종주식수']:.2f}주)")
        
        if 결과['거래내역']:
            print(f"\n거래 내역 (처음 10개):")
            for i, (유형, 시간, 변동률, 가격) in enumerate(결과['거래내역'][:10], 1):
                일차 = 시간 // 7 + 1
                시간대 = 시간 % 7 + 1
                print(f"   {i}. {일차}일 {시간대}시간: {유형} - 시가대비 {변동률:+.2f}% (가격: {가격:.0f}원)")
        else:
            print(f"\n[X] 거래 없음 - 매수 조건을 충족하지 못함")
        
        return 결과
    
    def 매수불가_전략_분석(self, 생존전략들, 시간범위=27):
        """0% 수익률 전략들이 실제로 매수를 못하는지 분석"""
        print(f"\n매수 불가 전략 분석 (0% 수익률 원인 조사)")
        print("-" * 60)
        
        영수익전략들 = []
        매수성공전략들 = []
        
        for i, 전략 in enumerate(생존전략들[:50]):  # 샘플 50개만 테스트
            try:
                매수기준값 = -abs(전략['매수하락률']) if 전략['매수하락률'] > 0 else 전략['매수하락률']
                결과 = self.매매시뮬레이션(매수기준값, 전략['수익라인'], 시간범위, 전략)
                
                if abs(결과['수익률']) < 0.01:  # 거의 0%
                    영수익전략들.append({
                        '전략': 전략,
                        '거래횟수': 결과['거래횟수'],
                        '최종현금': 결과['최종현금'],
                        '최종주식수': 결과['최종주식수']
                    })
                else:
                    매수성공전략들.append({
                        '전략': 전략,
                        '수익률': 결과['수익률'],
                        '거래횟수': 결과['거래횟수']
                    })
                    
            except Exception as e:
                print(f"   전략 {i} 오류: {e}")
        
        print(f"분석 결과:")
        print(f"   0% 수익률 전략: {len(영수익전략들)}개")
        print(f"   정상 거래 전략: {len(매수성공전략들)}개")
        
        if 영수익전략들:
            print(f"\n0% 수익률 전략들 (매수 실패):")
            for i, 데이터 in enumerate(영수익전략들[:5]):
                전략 = 데이터['전략']
                print(f"   {i+1}. 매수기준:{전략['매수기준']} 하락률:{전략['매수하락률']} → 거래:{데이터['거래횟수']}회")
        
        if 매수성공전략들:
            print(f"\n정상 거래 전략들:")
            for i, 데이터 in enumerate(매수성공전략들[:5]):
                전략 = 데이터['전략']
                print(f"   {i+1}. 매수기준:{전략['매수기준']} 하락률:{전략['매수하락률']} → 수익률:{데이터['수익률']:+.1f}% 거래:{데이터['거래횟수']}회")
        
        return len(영수익전략들), len(매수성공전략들)

    def 전략_비교_시뮬레이션_누적추적(self):
        """누적 추적용 전략 비교 시뮬레이션 (상위 20개 추적, 조용한 실행)"""
        # 기존 탈락 전략 로드 (조용히)
        탈락전략목록 = self._탈락전략_로드()
        
        # 다양한 전략 조합 생성 (탈락 전략 제외)
        전략조합 = self._전략조합_생성(탈락전략목록)
        print(f"   전략 조합: {len(전략조합):,}개 (탈락 제외: {len(탈락전략목록):,}개)")
        
        # 시장 데이터 요약 출력
        print(f"\n   시장 데이터 요약 (27주간):")
        if hasattr(self, '주간데이터') and self.주간데이터:
            주간데이터 = self.주간데이터[:27]  # 27주 데이터
            총변동 = sum(주간데이터)
            최고주 = max(주간데이터)
            최저주 = min(주간데이터)
            print(f"   ├ 총 변동: {총변동:+.1f}% | 최고주: {최고주:+.1f}% | 최저주: {최저주:+.1f}%")
            
            # 단순 보유 수익률 계산
            초기가격 = self.초기가격
            현재가격 = 초기가격
            for 변동 in self.주간데이터[:27]:
                현재가격 *= (1 + 변동/100)
            단순보유수익률 = (현재가격 - 초기가격) / 초기가격 * 100
            print(f"   ├ 단순 보유시 수익률: {단순보유수익률:+.1f}%")
            
            # 처음 5주 데이터 표시
            print(f"   └ 초반 5주: ", end="")
            for i, 주간변동 in enumerate(주간데이터[:5], 1):
                print(f"{i}주:{주간변동:+.1f}% ", end="")
            print()
        
        # 일별 점진적 필터링 - 조용한 버전 (3주차 단위 출력)
        생존전략 = 전략조합.copy()
        print(f"\n   27주 시뮬레이션 시작... (초기 생존: {len(생존전략):,}개)")
        
        for 일차 in range(135):  # 27주 = 135일
            주차 = (일차 // 5) + 1
            주내일차 = (일차 % 5) + 1
            
            # 3주마다 진행상황 및 수익률 분포 출력 (상세 버전)
            if 주차 % 3 == 0 and 주내일차 == 1:
                # 현재 수익률 분포 계산
                현재수익률들 = []
                거래횟수들 = []
                영수익전략수 = 0
                매수못한전략 = []
                
                # 전체 전략 분석 (정확도를 위해 샘플링 없이 전체 분석)
                샘플전략 = 생존전략
                print(f"   >>> 전체 {len(생존전략):,}개 전략 분석 중... (시간이 걸릴 수 있음)")
                
                for i, 전략 in enumerate(샘플전략):
                    # 진행률 표시 (매 10만개마다)
                    if (i + 1) % 100000 == 0:
                        진행률 = ((i + 1) / len(샘플전략)) * 100
                        print(f"       진행: {i+1:,}/{len(샘플전략):,} ({진행률:.1f}%)")
                    
                    try:
                        # 매수하락률이 양수면 음수로, 이미 음수면 그대로
                        매수기준값 = -abs(전략['매수하락률']) if 전략['매수하락률'] > 0 else 전략['매수하락률']
                        결과 = self.매매시뮬레이션(매수기준값, 전략['수익라인'], 일차 + 1, 전략)
                        현재수익률들.append(결과['수익률'])
                        거래횟수들.append(결과['거래횟수'])
                        
                        # 0% 수익률 전략 분석
                        if abs(결과['수익률']) < 0.01:
                            영수익전략수 += 1
                            if 결과['거래횟수'] == 0:
                                매수못한전략.append(전략)
                    except:
                        현재수익률들.append(0.0)
                        거래횟수들.append(0)
                
                if 현재수익률들:
                    최고 = max(현재수익률들)
                    최저 = min(현재수익률들)
                    평균 = sum(현재수익률들) / len(현재수익률들)
                    평균거래 = sum(거래횟수들) / len(거래횟수들) if 거래횟수들 else 0
                    
                    print(f"\n   === {주차}주차 상세 현황 ===")
                    print(f"   생존: {len(생존전략):,}개 (전체 분석 완료)")
                    print(f"   ├ 수익률: 최고 {최고:+.1f}% | 최저 {최저:+.1f}% | 평균 {평균:+.1f}%")
                    print(f"   ├ 거래: 평균 {평균거래:.1f}회 | 거래 없음 {영수익전략수}개")
                    
                    # 수익률 분포 표시
                    플러스 = len([x for x in 현재수익률들 if x > 0])
                    마이너스 = len([x for x in 현재수익률들 if x < 0])
                    제로 = len([x for x in 현재수익률들 if abs(x) < 0.01])
                    
                    print(f"   ├ 분포: +수익 {플러스}개 | 0% {제로}개 | -손실 {마이너스}개")
                    
                else:
                    print(f"   {주차}주차 진행 중... (생존: {len(생존전략):,}개)")
            
            # 시뮬레이션 실행 (제한된 로깅)
            일일결과 = []
            for 전략 in 생존전략:
                # 옐로우카드 초기화 확인 (전략 생성시 이미 복원됨)
                if '옐로우카드' not in 전략:
                    전략['옐로우카드'] = {'개수': 0, '마지막음성주차': 0}  # 새 전략인 경우만
                
                # 매수하락률이 양수면 음수로 변환
                매수기준값 = -abs(전략['매수하락률']) if 전략['매수하락률'] > 0 else 전략['매수하락률']
                결과 = self.매매시뮬레이션(
                    매수기준값,
                    전략['수익라인'], 
                    일차 + 1,
                    전략  # 전략 정보 추가
                )
                결과['전략'] = 전략
                일일결과.append(결과)
            
            # 옐로우카드 시스템 (6주 단위)
            if 주차 % 6 == 0 and 주내일차 == 1:  # 6주차마다 체크
                탈락자 = []
                손실5이하 = 0
                손실50이하 = 0
                옐로우2개이상 = 0
                
                for 결과 in 일일결과:
                    전략 = 결과['전략']
                    현재수익률 = 결과['수익률']
                    최종자산 = 결과['최종자산']
                    
                    if 현재수익률 <= -5:  # -5% 이하
                        전략['옐로우카드']['개수'] += 1
                        전략['옐로우카드']['마지막음성주차'] = 주차
                        손실5이하 += 1
                    
                    # 탈락 판정
                    if 전략['옐로우카드']['개수'] >= 2:
                        탈락자.append(전략)
                        옐로우2개이상 += 1
                    elif 최종자산 <= 50000:  # 50% 손실
                        탈락자.append(전략)
                        손실50이하 += 1
                
                # 디버그 정보 출력
                print(f"   → -5% 이하 손실: {손실5이하:,}개")
                print(f"   → 50% 이하 자산: {손실50이하:,}개") 
                print(f"   → 옐로우카드 2개 이상: {옐로우2개이상:,}개")
                print(f"   → 총 탈락 대상: {len(탈락자):,}개")
                
                
                # 탈락 처리
                if 탈락자:
                    # 탈락 정보를 올바른 형식으로 변환
                    탈락정보들 = []
                    for 탈락전략 in 탈락자:
                        탈락정보들.append({
                            '전략': 탈락전략,
                            '탈락사유': '옐로우카드2개' if 탈락전략['옐로우카드']['개수'] >= 2 else '50%손실',
                            '탈락일': 일차 + 1
                        })
                    
                    try:
                        self._탈락전략_저장(탈락정보들)
                        # 탈락자 제거 최적화 (O(n*m) → O(n+m))
                        탈락자_ids = {id(전략) for 전략 in 탈락자}
                        생존전략 = [전략 for 전략 in 생존전략 if id(전략) not in 탈락자_ids]
                        print(f"   → 탈락 처리 완료: {len(탈락자):,}개")
                    except Exception as e:
                        print(f"   →  탈락 저장 실패 (계속 진행): {e}")
                else:
                    print(f"   → 탈락자 없음")
        
        # 최종 결과 - 상위 20개만 반환 (메모리 절약)
        print(f"   최종 생존: {len(생존전략):,}개 → 상위 20개 선발")
        
        최종결과 = []
        for 전략 in 생존전략:
            try:
                매수기준값 = -abs(전략['매수하락률']) if 전략['매수하락률'] > 0 else 전략['매수하락률']
                결과 = self.매매시뮬레이션(매수기준값, 전략['수익라인'], 135, 전략)
                결과['전략설명'] = f"{전략['매수기준']}-{전략['매수하락률']}-{전략['구매방식']}-{전략['매수수량']}-{전략['손절라인']}-{전략['매도전략']}-{전략['수익라인']}"
                최종결과.append(결과)
            except Exception as e:
                print(f"   → 전략 처리 오류 (건너뛰기): {e}")
                continue
        
        # 매수 불가 전략 분석 (0% 수익률 원인 조사)
        try:
            if 최종결과:
                self.매수불가_전략_분석([결과['전략'] for 결과 in 최종결과], 135)
        except Exception as e:
            print(f"   → 매수불가분석 오류: {e}")
        
        # 상위 20개 선발 (안전한 정렬)
        try:
            최종결과.sort(key=lambda x: x['수익률'], reverse=True)
            return 최종결과[:20]
        except Exception as e:
            print(f"   → 정렬 오류: {e}")
            return 최종결과[:20] if 최종결과 else []
    
    def _시장상황_분류(self, 단순보유수익률=None):
        """현재 시장 상황 분류"""
        if 단순보유수익률 is not None:
            # 전달받은 수익률로 분류
            총수익률 = 단순보유수익률
        else:
            # 기존 방식: 주간데이터로 계산
            주간데이터 = self.주간데이터
            if not 주간데이터:
                return "알수없음"
                
            # 전체 27주 수익률 계산
            총수익률 = sum(주간데이터)
        
        if 총수익률 > 5:
            return "상승장"
        elif 총수익률 < -5:
            return "하락장"
        else:
            return "횡보장"
    
    def _종합랭킹_생성_저장(self, 전략성과누적):
        """종합 랭킹 생성 및 안전한 JSON 저장"""
        import json
        import os
        from datetime import datetime
        
        try:
            # 안정성 점수 계산 (출현횟수 * 평균수익률 / 순위변동성)
            랭킹목록 = []
            for 전략설명, 성과 in 전략성과누적.items():
                if 성과['출현횟수'] > 0 and '사이클기록' in 성과 and len(성과['사이클기록']) > 0:
                    try:
                        # 사이클기록에서 수익률과 순위 추출
                        수익률들 = [기록['수익률'] for 기록 in 성과['사이클기록']]
                        순위들 = [기록['순위'] for 기록 in 성과['사이클기록']]
                        
                        평균수익률 = sum(수익률들) / len(수익률들)
                        평균순위 = sum(순위들) / len(순위들)
                        순위변동성 = max(순위들) - min(순위들) if len(순위들) > 1 else 0
                        
                        # 안정성 점수: 출현횟수 * 평균수익률 / (순위변동성 + 1)
                        안정성점수 = 성과['출현횟수'] * 평균수익률 / (순위변동성 + 1)
                        
                        # 전략정보에서 필요한 기본 속성만 추출 (이동평균, 거래내역 제외)
                        원본전략정보 = 성과.get('전략정보', {})
                        간소화된전략정보 = {
                            '매수기준': 원본전략정보.get('매수기준', ''),
                            '매수기준명': 원본전략정보.get('매수기준명', ''),
                            '매수하락률': 원본전략정보.get('매수하락률', 0),
                            '구매방식': 원본전략정보.get('구매방식', ''),
                            '구매방식명': 원본전략정보.get('구매방식명', ''),
                            '매수수량': 원본전략정보.get('매수수량', 0),
                            '손절라인': 원본전략정보.get('손절라인', 0),
                            '매도전략': 원본전략정보.get('매도전략', ''),
                            '매도전략명': 원본전략정보.get('매도전략명', ''),
                            '수익라인': 원본전략정보.get('수익라인', 0)
                        }
                        
                        랭킹목록.append({
                            '전략설명': 전략설명,
                            '전략정보': 간소화된전략정보,  # 간소화된 전략 정보만 저장
                            '출현횟수': 성과['출현횟수'],
                            '평균수익률': 평균수익률,
                            '평균순위': 평균순위,
                            '최고순위': 성과.get('최고순위', 999),
                            '순위변동성': 순위변동성,
                            '안정성점수': 안정성점수,
                            '시장상황별성과': 성과.get('시장상황별성과', {'상승장': [], '하락장': [], '횡보장': []})
                        })
                    except Exception as e:
                        print(f"   → 전략 {전략설명} 계산 오류 (건너뛰기): {e}")
                        continue
            
            # 안정성 점수로 정렬 (안전한 정렬)
            try:
                랭킹목록.sort(key=lambda x: x['안정성점수'], reverse=True)
            except Exception as e:
                print(f"   → 랭킹 정렬 오류: {e}")
            
            # JSON 안전 저장 (상위 50개만)
            저장데이터 = {
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                '총사이클수': 5,
                '전략총개수': len(랭킹목록),
                '종합랭킹': 랭킹목록[:50]  # 상위 50개만 저장
            }
            
            # 메인 파일 저장
            try:
                self._안전한_json_저장(self.종합랭킹_파일, 저장데이터)
                print(f"    종합랭킹 JSON 저장 완료 ({len(랭킹목록)}개 → 상위 50개 저장)")
            except Exception as e:
                print(f"    JSON 저장 실패: {e}")
            
            return 랭킹목록[:50]  # 상위 50개만 반환
            
        except Exception as e:
            print(f"    종합랭킹 생성 전체 실패: {e}")
            return []
    
    def _5사이클_누적_시뮬레이션(self):
        """5사이클 누적 시뮬레이션 - 누적 수익률 방식"""
        # 5사이클 진행 중 플래그 설정
        self._is_in_5cycle = True
        
        사이클결과들 = []
        전략성과누적 = {}
        
        for 사이클 in range(1, 6):
            print(f"\n=== 사이클 {사이클}/5 시작 ===")
            print("-"*50)
            
            # 새로운 랜덤 데이터 생성
            일간데이터 = self.랜덤_일별_데이터_생성()
            self.주간_집계_계산(일간데이터)
            
            # 단일 시뮬레이션 실행 (누적 방식)
            결과 = self.전략_비교_시뮬레이션()
            
            if 결과 and '생존전략' in 결과:
                # 시장 상황 분류
                단순보유수익률 = 0
                if hasattr(self, '주간데이터') and self.주간데이터:
                    현재가격 = self.초기가격
                    for 변동 in self.주간데이터[:27]:
                        현재가격 *= (1 + 변동/100)
                    단순보유수익률 = (현재가격 - self.초기가격) / self.초기가격 * 100
                
                시장상황 = self._시장상황_분류(단순보유수익률)
                
                # 최고 전략 계산
                최고전략 = None
                최고수익률 = -float('inf')
                
                for 전략 in 결과['생존전략']:
                    평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                    수익률 = ((평가자산 - 100000) / 100000) * 100
                    
                    if 수익률 > 최고수익률:
                        최고수익률 = 수익률
                        최고전략 = {
                            '전략': 전략,
                            '수익률': 수익률,
                            '전략설명': f"{전략['매수기준명']}-{전략['매수하락률']}% + {전략['구매방식명']} + 손절{전략['손절라인']}% + {전략['매도전략명']}"
                        }
                
                # 누적 통계에 추가 (상위 20개 전략)
                상위전략들 = []
                for 전략 in 결과['생존전략'][:20]:  # 상위 20개만
                    평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                    수익률 = ((평가자산 - 100000) / 100000) * 100
                    상위전략들.append({
                        '전략': 전략,
                        '수익률': 수익률,
                        '전략설명': f"{전략['매수기준명']}-{전략['매수하락률']}% + {전략['구매방식명']} + 손절{전략['손절라인']}% + {전략['매도전략명']}"
                    })
                
                # 상위전략들을 누적 통계에 추가
                for 순위, 전략정보 in enumerate(상위전략들, 1):
                    전략키 = self._전략을_키로_변환(전략정보['전략'])
                    
                    if 전략키 not in 전략성과누적:
                        전략성과누적[전략키] = {
                            '전략정보': 전략정보['전략'],
                            '출현횟수': 0,
                            '총수익률': 0,
                            '순위합계': 0,
                            '최고순위': float('inf'),
                            '시장상황별성과': {'상승장': [], '하락장': [], '횡보장': []},
                            '사이클기록': []
                        }
                    
                    전략성과누적[전략키]['출현횟수'] += 1
                    전략성과누적[전략키]['총수익률'] += 전략정보['수익률']
                    전략성과누적[전략키]['순위합계'] += 순위
                    전략성과누적[전략키]['최고순위'] = min(전략성과누적[전략키]['최고순위'], 순위)
                    전략성과누적[전략키]['시장상황별성과'][시장상황].append(전략정보['수익률'])
                    전략성과누적[전략키]['사이클기록'].append({
                        '사이클': 사이클,
                        '순위': 순위,
                        '수익률': 전략정보['수익률'],
                        '시장상황': 시장상황
                    })
                
                사이클결과들.append({
                    '사이클': 사이클,
                    '생존전략수': len(결과['생존전략']),
                    '탈락전략수': len(결과['탈락기록']) if '탈락기록' in 결과 else 0,
                    '최고전략': 최고전략,
                    '시장상황': 시장상황,
                    '단순보유수익률': 단순보유수익률
                })
                
                # 각 사이클마다 상위 5개 전략을 히스토리에 저장 (중간 저장)
                if 결과 and '생존전략' in 결과 and len(결과['생존전략']) > 0:
                    self._최고전략_히스토리_저장(
                        결과['생존전략'], 
                        f"5사이클_{사이클}차", 
                        {
                            '현재사이클': 사이클,
                            '총사이클': 5,
                            '시장상황': 시장상황,
                            '생존전략수': len(결과['생존전략']),
                            '탈락전략수': len(결과.get('탈락기록', []))
                        }
                    )
                    print(f"  → 사이클 {사이클} 결과 히스토리 저장 완료")
                
                print(f"사이클 {사이클} 완료:")
                print(f"  생존: {사이클결과들[-1]['생존전략수']:,}개")
                print(f"  최고 수익률: {최고수익률:+.1f}% ({시장상황})")
                print(f"  단순보유 대비: {최고수익률 - 단순보유수익률:+.1f}%p")
            else:
                print(f"사이클 {사이클} 실패!")
                return None
        
        # 종합 랭킹 생성 및 저장
        종합랭킹 = self._종합랭킹_생성_저장(전략성과누적)
        
        # 최종 결과 요약
        print(f"\n{'='*80}")
        print(f"5사이클 누적 시뮬레이션 완료!")
        print(f"{'='*80}")
        
        print(f"\n사이클별 결과:")
        for 결과 in 사이클결과들:
            print(f"  사이클 {결과['사이클']}: 생존 {결과['생존전략수']:,}개, 최고 {결과['최고전략']['수익률']:+.1f}% ({결과['시장상황']})")
        
        # 종합 랭킹 TOP 10 표시
        if 종합랭킹:
            print(f"\n종합 랭킹 TOP 10:")
            print("-" * 60)
            
            for i, 전략데이터 in enumerate(종합랭킹[:10], 1):
                전략설명 = 전략데이터['전략설명']
                평균수익률 = 전략데이터['평균수익률']
                출현횟수 = 전략데이터['출현횟수']
                안정성점수 = 전략데이터['안정성점수']
                
                print(f"{i:2}. [{전략설명}]")
                print(f"    출현: {출현횟수}/5회, 평균수익률: {평균수익률:+.1f}%, 안정성: {안정성점수:.1f}")
        
        # 5사이클 시뮬레이션 완료 후 종합랭킹 저장
        if 종합랭킹:
            # 종합랭킹에서 상위 5개 전략 정보로 최종 히스토리 저장
            상위5전략_정보 = []
            for 전략데이터 in 종합랭킹[:5]:
                if '전략정보' in 전략데이터:
                    상위5전략_정보.append(전략데이터['전략정보'])
            
            if 상위5전략_정보:
                self._최고전략_히스토리_저장(상위5전략_정보, "5사이클_종합랭킹", {
                    '총사이클수': 5,
                    '분석전략수': len(종합랭킹),
                    '완료상태': '전체완료',
                    '종합평가': '5사이클 모두 완료 후 종합 분석'
                })
                print(f"\n  → 5사이클 종합랭킹 히스토리 저장 완료")
        
        # 5사이클 플래그 해제
        self._is_in_5cycle = False
        
        return 종합랭킹

    def _상위15전략_분석(self, 생존전략들):
        """상위 15개 전략을 수익률 기준으로 추출하고 분석"""
        if not 생존전략들:
            return []
            
        # 수익률 기준으로 정렬
        정렬된전략들 = sorted(생존전략들, key=lambda x: self._전략수익률_계산(x), reverse=True)
        
        # 상위 15개 추출
        상위15개 = 정렬된전략들[:15]
        
        print(f"상위 15개 전략 추출 완료 (총 {len(생존전략들)}개 중)")
        
        return 상위15개

    def _전략수익률_계산(self, 전략):
        """전략의 수익률 계산"""
        평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
        수익률 = ((평가자산 - 100000) / 100000) * 100
        return 수익률

    def _시장상황_분석(self):
        """현재 시장 상황 분석"""
        if not hasattr(self, '주간데이터') or not self.주간데이터:
            return {'상황': '데이터부족', '특징': [], '변동성': 0}
        
        # 시장 변동성 계산
        변동률들 = []
        for 주간변동 in self.주간데이터:
            if len(주간변동) >= 7:  # 7시간 데이터가 있는 경우
                주간변동률 = sum(주간변동[:7])
                변동률들.append(주간변동률)
        
        평균변동성 = sum(abs(x) for x in 변동률들) / len(변동률들) if 변동률들 else 0
        상승률 = sum(x for x in 변동률들 if x > 0) / len(변동률들) if 변동률들 else 0
        하락률 = sum(abs(x) for x in 변동률들 if x < 0) / len(변동률들) if 변동률들 else 0
        
        # 시장 상황 판정
        if 평균변동성 > 3:
            상황 = "고변동성"
        elif 평균변동성 > 1.5:
            상황 = "중변동성"
        else:
            상황 = "저변동성"
        
        # 시장 특징 추가
        특징들 = []
        if 상승률 > 하락률 * 1.5:
            특징들.append("상승장")
        elif 하락률 > 상승률 * 1.5:
            특징들.append("하락장")
        else:
            특징들.append("횡보장")
        
        if 평균변동성 > 2:
            특징들.append("높은변동성")
        elif 평균변동성 < 1:
            특징들.append("낮은변동성")
        
        return {
            '상황': 상황,
            '특징': 특징들,
            '변동성': round(평균변동성, 2),
            '상승률': round(상승률, 2),
            '하락률': round(하락률, 2),
            '전체기간': len(변동률들)
        }

    def _전략_그룹화(self, 전략들):
        """비슷한 전략들을 범위별로 그룹화"""
        if not 전략들:
            return []
        
        그룹들 = []
        처리된전략 = set()
        
        for i, 전략 in enumerate(전략들):
            if i in 처리된전략:
                continue
                
            # 현재 전략과 비슷한 전략들 찾기
            유사전략들 = [전략]
            처리된전략.add(i)
            
            for j, 다른전략 in enumerate(전략들[i+1:], i+1):
                if j in 처리된전략:
                    continue
                    
                if self._전략_유사성_판정(전략, 다른전략):
                    유사전략들.append(다른전략)
                    처리된전략.add(j)
            
            # 그룹 생성
            그룹 = {
                '대표전략': 유사전략들[0],
                '전략들': 유사전략들,
                '개수': len(유사전략들),
                '수익률범위': self._그룹_수익률범위_계산(유사전략들)
            }
            그룹들.append(그룹)
        
        # 수익률 기준으로 그룹 정렬
        그룹들.sort(key=lambda x: x['수익률범위']['평균'], reverse=True)
        
        return 그룹들

    def _전략_유사성_판정(self, 전략1, 전략2):
        """두 전략이 유사한지 판정"""
        # 매수기준이 같은지 확인
        if 전략1.get('매수기준명') != 전략2.get('매수기준명'):
            return False
        
        # 구매방식이 같은지 확인
        if 전략1.get('구매방식명') != 전략2.get('구매방식명'):
            return False
        
        # 매도전략이 같은지 확인  
        if 전략1.get('매도전략명') != 전략2.get('매도전략명'):
            return False
        
        return True

    def _그룹_수익률범위_계산(self, 전략들):
        """그룹의 수익률 범위 계산"""
        수익률들 = []
        for 전략 in 전략들:
            수익률 = self._전략수익률_계산(전략)
            수익률들.append(수익률)
        
        if not 수익률들:
            return {'최소': 0, '최대': 0, '평균': 0}
        
        return {
            '최소': min(수익률들),
            '최대': max(수익률들), 
            '평균': sum(수익률들) / len(수익률들)
        }

    def _그룹정보_생성(self, 그룹, 순위, 시장상황):
        """그룹 정보 생성"""
        대표전략 = 그룹['대표전략']
        수익률범위 = 그룹['수익률범위']
        
        return {
            '순위': 순위,
            '전략그룹': self._전략설명_생성(대표전략),
            '그룹크기': 그룹['개수'],
            '수익률범위': {
                '최소': round(수익률범위['최소'], 1),
                '최대': round(수익률범위['최대'], 1),
                '평균': round(수익률범위['평균'], 1)
            },
            '시장적합성': self._시장적합성_평가(대표전략, 시장상황),
            '대표전략상세': {
                '매수기준': 대표전략.get('매수기준명', ''),
                '구매방식': 대표전략.get('구매방식명', ''),
                '매도전략': 대표전략.get('매도전략명', ''),
                '리스크레벨': self._리스크레벨_평가(대표전략)
            }
        }

    def _시장적합성_평가(self, 전략, 시장상황):
        """전략의 시장 적합성 평가"""
        적합성점수 = 50  # 기본 점수
        
        # 시장 변동성에 따른 적합성
        변동성 = 시장상황.get('변동성', 0)
        if 변동성 > 2:
            # 고변동성 시장
            if '급진' in 전략.get('매도전략명', ''):
                적합성점수 += 20
            elif '고무줄' in 전략.get('매도전략명', ''):
                적합성점수 += 15
        else:
            # 저변동성 시장  
            if '일괄' in 전략.get('매도전략명', ''):
                적합성점수 += 15
        
        # 시장 방향성에 따른 적합성
        특징들 = 시장상황.get('특징', [])
        if '상승장' in 특징들:
            if '모멘텀' in 전략.get('매수기준명', ''):
                적합성점수 += 10
        elif '하락장' in 특징들:
            if '역추세' in 전략.get('매수기준명', ''):
                적합성점수 += 10
        
        return min(100, max(0, 적합성점수))

    def _리스크레벨_평가(self, 전략):
        """전략의 리스크 레벨 평가"""
        리스크점수 = 0
        
        # 손절라인에 따른 리스크
        손절라인 = abs(전략.get('손절라인', 0))
        if 손절라인 <= 5:
            리스크점수 += 3  # 높은 리스크
        elif 손절라인 <= 10:
            리스크점수 += 2  # 중간 리스크  
        else:
            리스크점수 += 1  # 낮은 리스크
        
        # 매수기준에 따른 리스크
        매수기준 = 전략.get('매수기준명', '')
        if '급락' in 매수기준:
            리스크점수 += 2
        elif '하락' in 매수기준:
            리스크점수 += 1
        
        # 리스크 레벨 반환
        if 리스크점수 >= 4:
            return "고위험"
        elif 리스크점수 >= 2:
            return "중위험"
        else:
            return "저위험"

    def _run_300week_fast_verification(self):
        """5사이클별 생존전략 수집 후 300주 고속검증"""
        print("5사이클 실행하여 생존전략 수집 중...")
        
        # 5사이클별 생존전략 수집
        전체생존전략 = {}
        사이클결과 = []
        
        for 사이클 in range(1, 6):
            print(f"사이클 {사이클}/5 진행 중...")
            
            # 새로운 랜덤 데이터 생성
            일간데이터 = self.랜덤_일별_데이터_생성()
            self.주간_집계_계산(일간데이터)
            
            # 27주 시뮬레이션 실행
            결과 = self.전략_비교_시뮬레이션()
            
            if 결과 and '생존전략' in 결과:
                생존전략들 = 결과['생존전략']
                사이클결과.append({
                    '사이클': 사이클,
                    '생존전략수': len(생존전략들)
                })
                
                # 생존전략들을 전체 수집에 추가
                for 전략 in 생존전략들:
                    전략키 = self._전략을_키로_변환(전략)
                    if 전략키 not in 전체생존전략:
                        전체생존전략[전략키] = {
                            '전략정보': 전략,
                            '생존사이클': [],
                            '사이클별수익률': {}
                        }
                    
                    # 수익률 계산
                    평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
                    수익률 = ((평가자산 - 100000) / 100000) * 100
                    
                    전체생존전략[전략키]['생존사이클'].append(사이클)
                    전체생존전략[전략키]['사이클별수익률'][str(사이클)] = 수익률
                    
            else:
                print(f"사이클 {사이클} 실패!")
                return None
        
        # 수집 결과 요약
        print(f"\n5사이클 생존전략 수집 완료!")
        print(f"총 수집된 유니크 전략: {len(전체생존전략)}개")
        for 결과 in 사이클결과:
            print(f"  사이클 {결과['사이클']}: {결과['생존전략수']}개 생존")
        
        # 300주 고속 시뮬레이션 실행
        print(f"\n300주 고속 시뮬레이션 시작...")
        최종결과 = self._run_300week_simulation(전체생존전략)
        
        if 최종결과:
            # JSON 저장
            저장결과 = self._save_300week_final_result(최종결과, 전체생존전략, 사이클결과)
            return 저장결과
        else:
            return None

    def _run_300week_simulation(self, 전체생존전략):
        """수집된 전략들로 300주 고속 시뮬레이션 실행"""
        print("300주 데이터 생성 중...")
        
        # 300주 데이터 생성
        일간데이터_300주 = self._generate_300week_data()
        self._calculate_300week_weekly(일간데이터_300주)
        
        print(f"총 {len(전체생존전략)}개 전략으로 300주 시뮬레이션 실행...")
        
        # 전략들을 리스트로 변환
        시뮬레이션전략들 = [데이터['전략정보'] for 데이터 in 전체생존전략.values()]
        
        # 고속 시뮬레이션 실행 (옐로우카드 6회, 간략 출력)
        최종결과 = self._run_fast_strategy_simulation_300week(시뮬레이션전략들)
        
        return 최종결과

    def _일간데이터_생성(self):
        """135일(27주) 일간 데이터 생성"""
        import random
        일간변동률들 = []
        
        for 일차 in range(135):  # 27주 = 135일
            # 일일 변동률 생성 (-3% ~ +3%)
            변동률 = random.uniform(-0.03, 0.03)
            일간변동률들.append(변동률)
        
        return 일간변동률들

    def _generate_300week_data(self):
        """300주(1500일) 고속 데이터 생성"""
        일간변동률들 = []
        
        # 1500일 데이터 생성 (간략 출력)
        for 일차 in range(1500):
            if 일차 % 300 == 0:  # 300일마다 진행상황 표시
                print(f"데이터 생성 진행률: {일차/1500*100:.0f}%")
            
            # 기본 일간변동률 (-8% ~ +8%)
            기본변동률 = random.uniform(-8, 8)
            
            # 추세 보정
            추세보정 = (일차 / 1500) * random.uniform(-1, 1)
            
            # 변동성 보정  
            변동성보정 = random.uniform(0.8, 1.2)
            
            최종변동률 = (기본변동률 + 추세보정) * 변동성보정
            일간변동률들.append(최종변동률)
        
        print("300주 데이터 생성 완료!")
        return 일간변동률들

    def _calculate_300week_weekly(self, 일간데이터):
        """1500일 데이터를 300주로 집계"""
        print("300주 집계 계산 중...")
        
        주간변동률들 = []
        for 주차 in range(0, 1500, 5):  # 5일씩 묶어서 주간 계산
            if 주차 % 150 == 0:  # 30주마다 진행상황 표시
                print(f"집계 진행률: {주차/1500*100:.0f}%")
                
            주간데이터 = 일간데이터[주차:주차+5]
            if len(주간데이터) == 5:
                # 주간 누적 변동률 계산
                주간누적 = 1.0
                for 일간변동 in 주간데이터:
                    주간누적 *= (1 + 일간변동/100)
                주간변동률 = (주간누적 - 1) * 100
                주간변동률들.append(주간변동률)
        
        self.주간데이터 = 주간변동률들[:300]  # 정확히 300주
        print(f"300주 집계 완료! 총 {len(self.주간데이터)}주")

    def _run_fast_strategy_simulation_300week(self, 전략들):
        """고속 300주 시뮬레이션 (옐로우카드 6회, 간략 출력)"""
        생존전략들 = []
        탈락기록 = []
        
        # 전략 초기화
        for i, 전략템플릿 in enumerate(전략들):
            if i % 100 == 0:  # 100개마다 진행상황
                print(f"전략 초기화: {i}/{len(전략들)}")
                
            전략 = 전략템플릿.copy()
            전략.update({
                '자본': 100000,
                '주식수': 0,
                '옐로우카드': {'개수': 0, '획득일차': []},
                '이동평균': [],
                '매수기록': [],
                '매도기록': []
            })
            생존전략들.append(전략)
        
        print(f"300주 시뮬레이션 시작 - 총 {len(생존전략들)}개 전략")
        
        # 300주 시뮬레이션 실행
        for 일차 in range(len(self.주간데이터)):
            if 일차 % 50 == 0:  # 50주마다 진행상황
                print(f"진행률: {일차+1}/300주 ({(일차+1)/300*100:.0f}%) - 생존: {len(생존전략들)}개")
            
            주간변동률 = self.주간데이터[일차]
            
            # 생존 전략들 처리
            탈락자 = []
            for 전략 in 생존전략들[:]:  # 복사본으로 순회
                try:
                    # 매수/매도 처리 (고속 간소화 버전)
                    self._fast_strategy_process(전략, 일차+1, 주간변동률)
                    
                    # 평가손실 체크 추가 (주식 보유 여부와 관계없이)
                    현재가격 = self.초기가격 * (1 + 주간변동률/100) if hasattr(self, '초기가격') else 100000
                    평가자산 = 전략['자본'] + 전략['주식수'] * 현재가격
                    현재수익률 = ((평가자산 - 100000) / 100000) * 100
                    
                    # -5% 이하 손실시 옐로우카드 부여
                    if 현재수익률 <= -5.0 and 일차 % 6 == 0:  # 6주마다 체크
                        전략['옐로우카드']['개수'] += 1
                        전략['옐로우카드']['획득일차'].append(일차+1)
                    
                    # 옐로우카드 6회로 탈락 조건 확인
                    if 전략['옐로우카드']['개수'] >= 6:  # 기존 3-5회 → 6회로 변경
                        탈락자.append(전략)
                        생존전략들.remove(전략)
                        
                except Exception as e:
                    # 오류 발생시 탈락 처리
                    탈락자.append(전략)
                    if 전략 in 생존전략들:
                        생존전략들.remove(전략)
            
            # 탈락 기록 (간소화)
            if 탈락자:
                for 전략 in 탈락자:
                    탈락기록.append({
                        '탈락일차': 일차+1,
                        '전략키': self._전략을_키로_변환(전략),
                        '옐로우카드': 전략['옐로우카드']['개수']
                    })
        
        print(f"300주 시뮬레이션 완료!")
        print(f"최종 생존: {len(생존전략들)}개, 탈락: {len(탈락기록)}개")
        
        return {
            '생존전략': 생존전략들,
            '탈락기록': 탈락기록,
            '시뮬레이션주수': 300
        }

    def _save_300week_final_result(self, 최종결과, 전체생존전략, 사이클결과):
        """300주 시뮬레이션 최종 결과를 JSON으로 저장"""
        from datetime import datetime
        
        # JSON 파일 경로
        결과파일 = os.path.join(self.기본경로, "5사이클_300주_고속검증_결과.json")
        
        # 시장환경 계산 (초기가격과 최종가격 기반)
        초기가격 = getattr(self, '초기가격', 100000)
        
        # 생존전략이 있으면 첫 번째 전략의 이동평균에서 최종가격 계산
        if 최종결과['생존전략'] and 최종결과['생존전략'][0]['이동평균']:
            최종가격 = 최종결과['생존전략'][0]['이동평균'][-1]
        else:
            최종가격 = 초기가격
            
        시장수익률 = ((최종가격 - 초기가격) / 초기가격) * 100
        
        # 시장상황 판단
        if 시장수익률 >= 5:
            시장상황 = "상승장"
        elif 시장수익률 <= -5:
            시장상황 = "하락장"
        else:
            시장상황 = "횡보장"
        
        # 저장할 데이터 구성 (탈락전략 정보 제거)
        저장데이터 = {
            "실행정보": {
                "실행일시": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "총수집전략수": len(전체생존전략),
                "300주시뮬레이션_생존전략수": len(최종결과['생존전략']),
                "고속화설정": {
                    "옐로우카드_탈락기준": 6,
                    "간략출력모드": True
                }
            },
            "시장환경": {
                "초기가격": round(초기가격, 1),
                "최종가격": round(최종가격, 1),
                "시장수익률": round(시장수익률, 1),
                "시장상황": 시장상황
            },
            "5사이클_수집결과": 사이클결과,
            "최종생존전략들": []
        }
        
        # 모든 생존전략 정보 추가 (간소화된 정보만)
        for 전략 in 최종결과['생존전략']:
            전략키 = self._전략을_키로_변환(전략)
            
            # 전략 기본 정보만 저장 (매수/매도/수익 세부사항 제외)
            전략정보 = {
                "전략키": 전략키,
                "전략구성": {
                    "매수기준": 전략.get('매수기준명', '알수없음'),
                    "매수하락률": 전략.get('매수하락률', 0),
                    "구매방식": 전략.get('구매방식명', '알수없음'),
                    "매수수량": 전략.get('매수수량', 50),
                    "손절라인": 전략.get('손절라인', -10),
                    "매도전략": 전략.get('매도전략명', '알수없음')
                },
                "생존정보": {
                    "생존사이클": 전체생존전략.get(전략키, {}).get('생존사이클', []),
                    "사이클별수익률": 전체생존전략.get(전략키, {}).get('사이클별수익률', {}),
                    "생존시장상황": 시장상황
                }
            }
            저장데이터["최종생존전략들"].append(전략정보)
        
        # JSON 안전 저장
        try:
            self._안전한_json_저장(결과파일, 저장데이터)
            print(f"\n300주 고속검증 결과 저장 완료!")
            print(f"저장 파일: {결과파일}")
            print(f"최종 생존전략: {len(저장데이터['최종생존전략들'])}개")
            print(f"시장환경: {저장데이터['시장환경']['시장상황']} (수익률: {저장데이터['시장환경']['시장수익률']:+.1f}%)")
            
            return True
            
        except Exception as e:
            print(f"결과 저장 실패: {e}")
            return False

    def _fast_strategy_process(self, 전략, 주차, 주간변동률):
        """고속 전략 처리 (간소화된 매수/매도 로직)"""
        현재가격 = self.초기가격 * (1 + 주간변동률/100) if hasattr(self, '초기가격') else 100000
        
        # 이동평균 업데이트 (간소화)
        전략['이동평균'].append(현재가격)
        if len(전략['이동평균']) > 20:  # 최근 20주만 유지
            전략['이동평균'].pop(0)
        
        # 매수 조건 확인 (간소화)
        if 전략['주식수'] == 0:  # 보유 주식이 없을 때
            매수기준 = 전략.get('매수기준', '1')
            매수하락률 = 전략.get('매수하락률', 2.0)
            
            # 간단한 매수 조건 (하락률 기준)
            if 주간변동률 <= -매수하락률:
                # 매수 실행
                구매방식 = 전략.get('구매방식', '1')
                매수수량 = 전략.get('매수수량', 50)
                
                if isinstance(매수수량, dict):
                    수량비율 = 매수수량.get('수량', 50) / 100
                else:
                    수량비율 = 매수수량 / 100
                
                매수금액 = 전략['자본'] * 수량비율
                매수주식수 = int(매수금액 / 현재가격)
                
                if 매수주식수 > 0:
                    전략['주식수'] += 매수주식수
                    전략['자본'] -= 매수주식수 * 현재가격
                    전략['매수기록'].append({'주차': 주차, '가격': 현재가격, '수량': 매수주식수})
        
        else:  # 주식 보유 중일 때
            # 손절 확인 - 두 가지 기준 모두 체크
            손절라인 = 전략.get('손절라인', -10.0)
            
            # 1. 평균매수가 대비 손실률
            평균매수가 = sum([r['가격'] * r['수량'] for r in 전략['매수기록']]) / sum([r['수량'] for r in 전략['매수기록']]) if 전략['매수기록'] else 현재가격
            현재손익률 = (현재가격 - 평균매수가) / 평균매수가 * 100
            
            # 2. 전체 평가자산 기준 손실률 (추가)
            평가자산 = 전략['자본'] + 전략['주식수'] * 현재가격
            전체손실률 = ((평가자산 - 100000) / 100000) * 100
            
            # 둘 중 하나라도 손절라인 도달시 손절
            if 현재손익률 <= 손절라인 or 전체손실률 <= 손절라인:
                # 손절 매도 + 옐로우카드
                매도금액 = 전략['주식수'] * 현재가격
                전략['자본'] += 매도금액
                전략['매도기록'].append({'주차': 주차, '가격': 현재가격, '수량': 전략['주식수'], '이유': '손절'})
                전략['주식수'] = 0
                전략['옐로우카드']['개수'] += 1
                전략['옐로우카드']['획득일차'].append(주차)
            else:
                # 수익 매도 조건 확인 (간소화)
                매도전략 = 전략.get('매도전략', '1')
                수익라인 = 전략.get('수익라인', 5.0)
                
                if 현재손익률 >= 수익라인:
                    # 수익 매도
                    매도금액 = 전략['주식수'] * 현재가격
                    전략['자본'] += 매도금액
                    전략['매도기록'].append({'주차': 주차, '가격': 현재가격, '수량': 전략['주식수'], '이유': '수익'})
                    전략['주식수'] = 0


def main():
    """메인 실행 함수"""
    print("최적화 투자 패턴 분석기 v5.0")
    print("="*60)
    
    # 초기 주식 가격 입력
    초기가격 = float(input("초기 주식 가격을 입력하세요 (원): "))
    
    print("\n실행 모드 선택:")
    print("1. 전략 비교 시뮬레이션 (전체)")
    print("2. 최고전략 히스토리 조회")
    print("3. 히스토리 전략 재검증")
    print("4. 시장 상황별 성과 조회")
    print("5. 현재 상황 기반 전략 추천")
    print("6. 포트폴리오 전략 시뮬레이션")
    print("7. 포트폴리오 히스토리 조회")
    print("8. 5사이클 누적 시뮬레이션 (개선된 옐로우카드)")
    print("9. 5사이클별 생존전략 300주 고속검증")
    모드 = input("선택 (1-9): ")
    
    분석기 = 최적화투자분석(초기가격)
    
    if 모드 == "1":
        # 탈락 전략 데이터 자동 유지 (누적 학습 효과)
        if os.path.exists(분석기.탈락전략_파일):
            print("기존 탈락 전략 데이터 유지 → 누적 학습 효과 적용")
        
        # 27주 투자 시뮬레이션 실행
        print(f"27주 투자 패턴 분석 시작!")
        print("="*50)
        
        # 랜덤 데이터 생성
        일간데이터 = 분석기.랜덤_일별_데이터_생성()
        분석기.주간_집계_계산(일간데이터)
        
        # 시뮬레이션 실행
        결과 = 분석기.전략_비교_시뮬레이션()
        
        if 결과:
            print(f"\n최종 결과:")
            print(f"생존 전략: {len(결과['생존전략']):,}개")
            print(f"탈락 전략: {len(결과['탈락기록']):,}개")
            
            if '최고전략' in 결과 and 결과['최고전략']:
                최고전략 = 결과['최고전략']
                # 수익률 계산
                평가자산 = 최고전략['자본'] + 최고전략['주식수'] * (최고전략['이동평균'][-1] if 최고전략['이동평균'] else 100000)
                수익률 = ((평가자산 - 100000) / 100000) * 100
                
                print(f"\n최고 전략:")
                print(f"  수익률: {수익률:+.1f}%")
                print(f"  전략: {최고전략['매수기준명']}-{최고전략['매수하락률']}% + {최고전략['구매방식명']} + 손절{최고전략['손절라인']}% + {최고전략['매도전략명']}")
                print(f"  최종 자산: {평가자산:,.0f}원")
        else:
            print("시뮬레이션 실행 중 오류가 발생했습니다.")
    
    elif 모드 == "2":
        # 최고전략 히스토리 조회
        분석기._최고전략_히스토리_조회()
        
        print("\n💡 활용 팁:")
        print("- 히스토리에서 자주 등장하는 전략 패턴을 주목하세요")
        print("- 다양한 시장 환경에서 일관되게 좋은 성과를 내는 전략을 찾아보세요")
        print("- 극한 테스트 결과를 통해 전략의 안정성을 확인하세요")
    
    elif 모드 == "3":
        # 히스토리 전략 재검증
        print("\n재검증할 시장 환경:")
        print("1. 현재 환경 (새로운 랜덤 데이터)")
        print("2. 상승장 환경")
        print("3. 하락장 환경") 
        print("4. 횡보장 환경")
        환경선택 = input("선택 (1, 2, 3, 4): ")
        
        환경이름 = {
            "1": "현재환경",
            "2": "상승장환경", 
            "3": "하락장환경",
            "4": "횡보장환경"
        }.get(환경선택, "현재환경")
        
        # 환경별 데이터 생성
        if 환경선택 == "2":  # 상승장
            주별데이터 = [5, 8, 3, 7, 12]  # 전체적 상승
        elif 환경선택 == "3":  # 하락장
            주별데이터 = [-8, -5, -12, -3, -7]  # 전체적 하락
        elif 환경선택 == "4":  # 횡보장
            주별데이터 = [2, -1, 3, -2, 1]  # 작은 변동
        else:  # 현재환경
            주별데이터 = 분석기.랜덤_주별_데이터_생성()
        
        분석기.계층적_변동률_생성(주별데이터)
        분석기._히스토리_전략_재검증(환경이름)
        
        print(f"\n {환경이름} 재검증 완료!")
        print("- 기존 최고 전략들의 현재 환경 적응력을 확인했습니다")
        print("- 성과 차이를 통해 전략의 환경 민감도를 파악하세요")
    
    elif 모드 == "4":
        # 시장 상황별 성과 조회
        print("\n 시장 상황별 전략 성과 조회")
        print("="*50)
        분석기.상황별_성과시각화()
    
    elif 모드 == "5":
        # 현재 상황 기반 전략 추천
        print("\n 현재 상황 기반 전략 추천")
        print("="*50)
        
        # 현재 상황 분석
        현재상황 = 분석기.시장상황_분석()
        print(f"\n 현재 시장 상황:")
        print(f"   시장 체제: {현재상황['market_regime']}")
        print(f"   변동성: {현재상황['volatility_pattern']}")
        print(f"   추세: {현재상황['trend_pattern']}")
        print(f"   모멘텀: {현재상황['price_momentum']}")
        
        # 전략 추천
        print(f"\n 추천 전략:")
        추천전략들 = 분석기.유사상황_전략추천(현재상황)
        
        if 추천전략들:
            print(f"\n 추천 이유:")
            print(f"   과거 유사 상황에서 검증된 최적 전략들입니다")
            print(f"   현재 시장 조건과 {round(100 * len(추천전략들) / 3)}% 유사한 환경에서 우수한 성과를 보였습니다")
        else:
            print(f"\n 대안 제안:")
            print(f"   현재 시장 상황은 이전에 경험하지 못한 새로운 패턴입니다")
            print(f"   전략 비교 시뮬레이션(모드 1)을 통해 새로운 최적 전략을 발굴해보세요")
    
    elif 모드 == "6":
        # 포트폴리오 전략 시뮬레이션
        print("\n 포트폴리오 전략 시뮬레이션")
        print("="*50)
        분석기._포트폴리오_시뮬레이션()
    
    elif 모드 == "7":
        # 포트폴리오 히스토리 조회
        print("\n 포트폴리오 히스토리 조회")
        print("="*50)
        분석기._포트폴리오_히스토리_조회()
    
    elif 모드 == "8":
        # 5사이클 누적 시뮬레이션 (개선된 옐로우카드)
        print(f"5사이클 누적 시뮬레이션 시작!")
        print("개선된 옐로우카드: 매주 1개씩, 총 12개 누적시 탈락")
        print("="*60)
        
        # 5사이클 실행
        결과 = 분석기._5사이클_누적_시뮬레이션()
        
        if 결과:
            print(f"\n5사이클 시뮬레이션 완료!")
            print(f"결과가 저장되었습니다.")
        else:
            print("5사이클 시뮬레이션 실행 중 오류가 발생했습니다.")
    
    elif 모드 == "9":
        # 5사이클별 생존전략 300주 고속검증
        print(f"5사이클별 생존전략 300주 고속검증 시작!")
        print("고속화 적용: 옐로우카드 6회 탈락, 간략 출력")
        print("="*60)
        
        # 300주 고속검증 실행
        결과 = 분석기._run_300week_fast_verification()
        
        if 결과:
            print(f"\n300주 고속검증 완료!")
            print(f"최종 생존전략이 JSON으로 저장되었습니다.")
        else:
            print("300주 고속검증 실행 중 오류가 발생했습니다.")
    
    else:
        print("올바른 모드를 선택해주세요 (1-9)")
        return

    def 시장상황_분석(self):
        """현재 시장 상황을 다각도로 분석"""
        상황분석 = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'volatility_pattern': self._변동성_패턴_분석(),
            'trend_pattern': self._추세_패턴_분석(),
            'price_momentum': self._가격_모멘텀_분석(),
            'market_regime': self._시장체제_분석()
        }
        return 상황분석
    
    def _변동성_패턴_분석(self):
        """변동성 패턴 분석 (안정/보통/변동/급변동/극단)"""
        if not self.일간데이터:
            return "데이터부족"
            
        # 일간 변동률들의 표준편차 계산
        if NUMPY_AVAILABLE:
            변동성 = np.std(self.일간데이터)
        else:
            # 수동으로 표준편차 계산
            평균 = sum(self.일간데이터) / len(self.일간데이터)
            분산 = sum((x - 평균) ** 2 for x in self.일간데이터) / len(self.일간데이터)
            변동성 = math.sqrt(분산)
        
        if 변동성 <= 3:
            return "저변동성"  # 안정장
        elif 변동성 <= 8:
            return "중변동성"  # 보통장 
        elif 변동성 <= 15:
            return "고변동성"  # 변동장
        elif 변동성 <= 25:
            return "초고변동성"  # 급변동장
        else:
            return "극한변동성"  # 극단적 상황
    
    def _추세_패턴_분석(self):
        """추세 패턴 분석 (상승/하락/횡보)"""
        if len(self.일간데이터) < 5:
            return "데이터부족"
            
        # 최근 5일간 추세 계산
        최근5일 = self.일간데이터[-5:]
        누적변동 = sum(최근5일)
        
        # 추세 강도도 함께 분석
        추세강도 = abs(누적변동) / 5  # 평균 절댓값
        
        if 누적변동 > 5 and 추세강도 > 2:
            return "강한상승추세"
        elif 누적변동 > 0 and 추세강도 > 1:
            return "약한상승추세"  
        elif 누적변동 < -5 and 추세강도 > 2:
            return "강한하락추세"
        elif 누적변동 < 0 and 추세강도 > 1:
            return "약한하락추세"
        else:
            return "횡보장"
    
    def _가격_모멘텀_분석(self):
        """가격 모멘텀 분석"""
        if len(self.시간데이터) < 10:
            return "데이터부족"
            
        # 최근 시간별 변동의 가속도 분석
        최근10시간 = self.시간데이터[-10:]
        상승횟수 = sum(1 for x in 최근10시간 if x > 0)
        하락횟수 = sum(1 for x in 최근10시간 if x < 0)
        
        if 상승횟수 >= 7:
            return "강한상승모멘텀"
        elif 상승횟수 >= 6:
            return "상승모멘텀"
        elif 하락횟수 >= 7:
            return "강한하락모멘텀"
        elif 하락횟수 >= 6:
            return "하락모멘텀"
        else:
            return "중립모멘텀"
    
    def _시장체제_분석(self):
        """종합적인 시장 체제 분석"""
        변동성 = self._변동성_패턴_분석()
        추세 = self._추세_패턴_분석()
        모멘텀 = self._가격_모멘텀_분석()
        
        # 복합적인 시장 상황 판단
        if "극한" in 변동성:
            if "강한하락" in 추세:
                return "공황장"
            elif "강한상승" in 추세:
                return "버블장"
            else:
                return "혼란장"
        elif "초고" in 변동성:
            if "하락" in 추세:
                return "약세장"  
            elif "상승" in 추세:
                return "강세장"
            else:
                return "변동장"
        elif "고" in 변동성:
            if "모멘텀" in 모멘텀:
                return "활발장"
            else:
                return "불안장"
        else:
            if "횡보" in 추세:
                return "안정장"
            else:
                return "조정장"
    
    def 전략성과_저장(self, 시장상황, 전략결과들, 파일명=None):
        if 파일명 is None:
            파일명 = self.시장성과_파일
        """시장 상황별 전략 성과를 저장"""
        try:
            # 기존 데이터 로드
            if os.path.exists(파일명):
                with open(파일명, 'r', encoding='utf-8') as f:
                    기존데이터 = json.load(f)
            else:
                기존데이터 = {}
            
            # 시장 상황을 키로 사용
            상황키 = f"{시장상황['volatility_pattern']}_{시장상황['trend_pattern']}_{시장상황['market_regime']}"
            
            if 상황키 not in 기존데이터:
                기존데이터[상황키] = {
                    'market_condition': 시장상황,
                    'strategy_performances': [],
                    'best_strategies': [],
                    'analysis_count': 0
                }
            
            # 전략 성과 추가
            기존데이터[상황키]['strategy_performances'].append({
                'timestamp': 시장상황['timestamp'],
                'results': 전략결과들[:10]  # 상위 10개만 저장
            })
            
            # 최고 전략들 업데이트 (상위 3개)
            상위3개 = sorted(전략결과들, key=lambda x: x['수익률'], reverse=True)[:3]
            기존데이터[상황키]['best_strategies'] = 상위3개
            기존데이터[상황키]['analysis_count'] += 1
            
            # 저장
            with open(파일명, 'w', encoding='utf-8') as f:
                json.dump(기존데이터, f, ensure_ascii=False, indent=2)
                
            print(f"시장 상황 '{상황키}' 전략 성과 저장 완료")
            return True
            
        except Exception as e:
            print(f"전략 성과 저장 실패: {e}")
            return False
    
    def 유사상황_전략추천(self, 현재상황, 파일명=None):
        if 파일명 is None:
            파일명 = self.시장성과_파일
        """현재 상황과 유사한 과거 상황의 최적 전략 추천"""
        try:
            if not os.path.exists(파일명):
                print("과거 전략 성과 데이터가 없습니다.")
                return None
                
            with open(파일명, 'r', encoding='utf-8') as f:
                과거데이터 = json.load(f)
            
            현재키 = f"{현재상황['volatility_pattern']}_{현재상황['trend_pattern']}_{현재상황['market_regime']}"
            
            # 정확히 일치하는 상황 찾기
            if 현재키 in 과거데이터:
                정확일치 = 과거데이터[현재키]
                print(f"정확히 일치하는 과거 상황 발견!")
                print(f"   분석 횟수: {정확일치['analysis_count']}회")
                print(f"   추천 전략 (상위 3개):")
                
                for i, 전략 in enumerate(정확일치['best_strategies'], 1):
                    print(f"   {i}. {전략['전략설명']} (수익률: {전략['수익률']:+.2f}%)")
                
                return 정확일치['best_strategies']
            
            # 부분 일치하는 상황들 찾기  
            부분일치들 = []
            for 키, 데이터 in 과거데이터.items():
                일치점수 = 0
                키_요소들 = 키.split('_')
                현재_요소들 = 현재키.split('_')
                
                # 각 요소별 일치도 계산
                if 키_요소들[0] == 현재_요소들[0]:  # 변동성 패턴
                    일치점수 += 3
                if 키_요소들[1] == 현재_요소들[1]:  # 추세 패턴  
                    일치점수 += 2
                if 키_요소들[2] == 현재_요소들[2]:  # 시장 체제
                    일치점수 += 4
                
                if 일치점수 > 0:
                    부분일치들.append({
                        'key': 키,
                        'score': 일치점수,
                        'data': 데이터
                    })
            
            if 부분일치들:
                # 일치 점수 순으로 정렬
                부분일치들.sort(key=lambda x: x['score'], reverse=True)
                최고일치 = 부분일치들[0]
                
                print(f"유사한 과거 상황 발견 (일치도: {최고일치['score']}/9)")
                print(f"   과거 상황: {최고일치['key']}")
                print(f"   분석 횟수: {최고일치['data']['analysis_count']}회")
                print(f"   추천 전략 (상위 3개):")
                
                for i, 전략 in enumerate(최고일치['data']['best_strategies'], 1):
                    print(f"   {i}. {전략['전략설명']} (수익률: {전략['수익률']:+.2f}%)")
                
                return 최고일치['data']['best_strategies']
            
            print("유사한 과거 상황을 찾을 수 없습니다.")
            return None
            
        except Exception as e:
            print(f"전략 추천 실패: {e}")
            return None
    
    def 상황별_성과시각화(self, 파일명=None):
        if 파일명 is None:
            파일명 = self.시장성과_파일
        """저장된 시장 상황별 전략 성과를 시각화"""
        try:
            if not os.path.exists(파일명):
                print("시각화할 데이터가 없습니다.")
                return
                
            with open(파일명, 'r', encoding='utf-8') as f:
                데이터 = json.load(f)
            
            print("\n" + "="*80)
            print("시장 상황별 전략 성과 요약")
            print("="*80)
            
            for 상황키, 상황데이터 in 데이터.items():
                print(f"\n 상황: {상황키}")
                print(f"   분석 횟수: {상황데이터['analysis_count']}회")
                
                if 상황데이터['best_strategies']:
                    최고전략 = 상황데이터['best_strategies'][0]
                    평균수익 = sum(s['수익률'] for s in 상황데이터['best_strategies']) / len(상황데이터['best_strategies'])
                    
                    print(f"   최고 수익률: {최고전략['수익률']:+.2f}% ({최고전략['전략설명']})")
                    print(f"   상위3개 평균: {평균수익:+.2f}%")
                
                # 시장 상황 상세 정보
                시장정보 = 상황데이터['market_condition']
                print(f"   시장 체제: {시장정보['market_regime']}")
                print(f"   변동성: {시장정보['volatility_pattern']}")  
                print(f"   추세: {시장정보['trend_pattern']}")
                print(f"   모멘텀: {시장정보['price_momentum']}")
            
            # 전체 통계
            총분석횟수 = sum(d['analysis_count'] for d in 데이터.values())
            상위전략들 = []
            for 상황데이터 in 데이터.values():
                상위전략들.extend(상황데이터['best_strategies'])
            
            if 상위전략들:
                전체평균 = sum(s['수익률'] for s in 상위전략들) / len(상위전략들)
                최고수익 = max(상위전략들, key=lambda x: x['수익률'])
                
                print(f"\n 전체 통계:")
                print(f"   총 분석 상황: {len(데이터)}개")
                print(f"   총 분석 횟수: {총분석횟수}회") 
                print(f"   전체 평균 수익률: {전체평균:+.2f}%")
                print(f"   역대 최고 수익률: {최고수익['수익률']:+.2f}% ({최고수익['전략설명']})")
            
        except Exception as e:
            print(f" 시각화 실패: {e}")
    
    def _포트폴리오_시뮬레이션(self):
        """여러 전략을 비율로 조합한 포트폴리오 시뮬레이션"""
        print("\n 포트폴리오 전략 구성")
        print("="*60)
        
        # 현재 상황 분석
        현재상황 = self.시장상황_분석()
        print(f"현재 시장 상황:")
        print(f"   시장 체제: {현재상황['market_regime']}")
        print(f"   변동성: {현재상황['volatility_pattern']}")
        print(f"   추세: {현재상황['trend_pattern']}")
        
        # 추천 전략 가져오기
        추천전략들 = self.유사상황_전략추천(현재상황)
        
        if not 추천전략들:
            print("\n포트폴리오 구성을 위한 추천 전략이 없습니다.")
            print("먼저 모드 1로 전략 시뮬레이션을 실행하여 기본 전략들을 축적하세요.")
            return
        
        # 포트폴리오 구성 옵션 제시
        print(f"\n포트폴리오 구성 옵션:")
        print(f"1. 자동 균등 분배 ({len(추천전략들)}개 전략 균등)")
        print(f"2. 성과 기반 가중 분배 (수익률에 따른 비중)")
        print(f"3. 수동 비율 설정")
        print(f"4. 리스크 분산 분배 (서로 다른 매수/매도 조건)")
        
        # 리밸런싱 옵션도 함께 선택
        print(f"\n리밸런싱 옵션:")
        print(f"a. 리밸런싱 없음 (초기 배분 유지)")
        print(f"b. 주간 리밸런싱 (매주 금요일)")
        print(f"c. 일일 리밸런싱 (매일 종료 후)")
        
        구성방식 = input("포트폴리오 구성 방식 선택 (1-4): ")
        리밸런싱방식 = input("리밸런싱 방식 선택 (a/b/c): ")
        
        if 구성방식 == "1":
            # 균등 분배
            비율목록 = [100 / len(추천전략들) for _ in 추천전략들]
            포트폴리오 = self._균등분배_포트폴리오생성(추천전략들, 비율목록)
        elif 구성방식 == "2":
            # 성과 기반 가중 분배
            포트폴리오 = self._성과기반_포트폴리오생성(추천전략들)
        elif 구성방식 == "3":
            # 수동 비율 설정
            포트폴리오 = self._수동비율_포트폴리오생성(추천전략들)
        elif 구성방식 == "4":
            # 리스크 분산 분배
            포트폴리오 = self._리스크분산_포트폴리오생성(추천전략들)
        else:
            print("잘못된 선택입니다.")
            return
        
        if not 포트폴리오:
            return
        
        # 리밸런싱 설정 추가
        포트폴리오['리밸런싱방식'] = 리밸런싱방식
        
        # 포트폴리오 시뮬레이션 실행
        print(f"\n포트폴리오 시뮬레이션 시작")
        print("="*60)
        
        결과 = self._포트폴리오_실행(포트폴리오)
        
        # 결과 분석 및 개별 전략과 비교
        self._포트폴리오_결과분석(결과, 포트폴리오)
    
    def _균등분배_포트폴리오생성(self, 추천전략들, 비율목록):
        """균등 분배 포트폴리오 생성"""
        포트폴리오 = {
            '전략들': [],
            '총자본': 100000,
            '구성방식': '균등분배'
        }
        
        for i, (전략, 비율) in enumerate(zip(추천전략들, 비율목록)):
            전략정보 = self._추천전략을_실행전략으로_변환(전략)
            전략정보['할당자본'] = 포트폴리오['총자본'] * (비율 / 100)
            전략정보['할당비율'] = 비율
            전략정보['포트폴리오_ID'] = f"전략{i+1}"
            포트폴리오['전략들'].append(전략정보)
        
        print(f"\n균등분배 포트폴리오 생성 완료")
        for i, 전략 in enumerate(포트폴리오['전략들']):
            print(f"  전략{i+1}: {전략['전략설명'][:50]} ({전략['할당비율']:.1f}%)")
        
        return 포트폴리오
    
    def _성과기반_포트폴리오생성(self, 추천전략들):
        """성과 기반 가중 분배 포트폴리오"""
        # 수익률의 제곱으로 가중치 계산 (높은 수익률에 더 큰 비중)
        수익률들 = [max(전략['수익률'], 0.1) for 전략 in 추천전략들]  # 음수 방지
        제곱수익률들 = [r ** 1.5 for r in 수익률들]  # 1.5제곱으로 차등 강화
        총합 = sum(제곱수익률들)
        비율목록 = [(r / 총합) * 100 for r in 제곱수익률들]
        
        포트폴리오 = {
            '전략들': [],
            '총자본': 100000,
            '구성방식': '성과기반가중'
        }
        
        for i, (전략, 비율) in enumerate(zip(추천전략들, 비율목록)):
            전략정보 = self._추천전략을_실행전략으로_변환(전략)
            전략정보['할당자본'] = 포트폴리오['총자본'] * (비율 / 100)
            전략정보['할당비율'] = 비율
            전략정보['포트폴리오_ID'] = f"전략{i+1}"
            전략정보['기대수익률'] = 전략['수익률']
            포트폴리오['전략들'].append(전략정보)
        
        print(f"\n성과기반 가중분배 포트폴리오 생성 완료")
        for i, 전략 in enumerate(포트폴리오['전략들']):
            print(f"  전략{i+1}: {전략['전략설명'][:40]} ({전략['할당비율']:.1f}%, 기대수익 {전략['기대수익률']:+.1f}%)")
        
        return 포트폴리오
    
    def _수동비율_포트폴리오생성(self, 추천전략들):
        """수동 비율 설정 포트폴리오"""
        print(f"\n전략별 수동 비율 설정:")
        비율목록 = []
        
        for i, 전략 in enumerate(추천전략들):
            print(f"\n전략 {i+1}: {전략['전략설명']}")
            print(f"  과거 수익률: {전략['수익률']:+.2f}%")
            print(f"  거래 횟수: {전략['거래횟수']}회")
            
            while True:
                try:
                    비율 = float(input(f"  할당 비율 (%) 입력: "))
                    if 0 <= 비율 <= 100:
                        비율목록.append(비율)
                        break
                    else:
                        print("0~100 사이의 값을 입력하세요.")
                except ValueError:
                    print("올바른 숫자를 입력하세요.")
        
        총비율 = sum(비율목록)
        if abs(총비율 - 100) > 0.1:
            print(f"총 비율이 {총비율:.1f}%입니다. 100%로 정규화합니다.")
            비율목록 = [(r / 총비율) * 100 for r in 비율목록]
        
        return self._균등분배_포트폴리오생성(추천전략들, 비율목록)
    
    def _리스크분산_포트폴리오생성(self, 추천전략들):
        """리스크 분산형 포트폴리오"""
        # 서로 다른 매수/매도 조건을 가진 전략들을 우선 선별
        다양성점수 = {}
        for i, 전략1 in enumerate(추천전략들):
            점수 = 0
            for j, 전략2 in enumerate(추천전략들):
                if i != j:
                    # 매수 조건 차이
                    if 전략1['전략상세']['매수기준'] != 전략2['전략상세']['매수기준']:
                        점수 += 2
                    if abs(전략1['전략상세']['매수하락률'] - 전략2['전략상세']['매수하락률']) > 2:
                        점수 += 1
                    # 매도 조건 차이
                    if 전략1['전략상세']['매도전략'] != 전략2['전략상세']['매도전략']:
                        점수 += 2
            다양성점수[i] = 점수
        
        # 다양성 점수 기반 비중 계산
        총다양성 = sum(다양성점수.values()) or 1
        비율목록 = [(다양성점수[i] / 총다양성) * 100 for i in range(len(추천전략들))]
        
        포트폴리오 = self._균등분배_포트폴리오생성(추천전략들, 비율목록)
        포트폴리오['구성방식'] = '리스크분산'
        
        print(f"\n리스크 분산 포트폴리오 생성 완료 (다양성 중심)")
        return 포트폴리오
    
    def _추천전략을_실행전략으로_변환(self, 추천전략):
        """추천받은 전략을 실행 가능한 전략 객체로 변환"""
        상세 = 추천전략['전략상세']
        
        # 기본 전략 구조 생성
        전략 = {
            '전략설명': 추천전략['전략설명'],
            '자본': 0,  # 할당자본에서 설정됨
            '주식수': 0,
            '매수가격': 0,
            '최고가격': 0,
            '이동평균': [],
            '거래내역': [],
            
            # 매수 설정
            '매수기준명': 상세['매수기준'],
            '매수하락률': 상세['매수하락률'],
            '구매방식명': 상세['구매방식'],
            
            # 매도 설정  
            '매도전략명': 상세['매도전략'],
            '손절라인': 상세['손절라인'],
            
            # 매수 기준 코드 (간단 매핑)
            '매수기준': '1' if '시가' in 상세['매수기준'] else '2',
            '매도전략': '1' if '수익' in 상세['매도전략'] else '2',
            '구매방식': '1',
            '매수수량': 0.1  # 10% 비중으로 기본 설정
        }
        
        return 전략
    
    def _포트폴리오_실행(self, 포트폴리오):
        """포트폴리오 시뮬레이션 실행"""
        for 전략 in 포트폴리오['전략들']:
            전략['자본'] = 전략['할당자본']
            # 과거 데이터 복사
            전략['이동평균'] = self.과거데이터.copy()
        
        결과 = {
            '일별결과': [],
            '전략별누적': {},
            '포트폴리오총자산': [],
            '개별전략성과': []
        }
        
        # 135일 (27주) 시뮬레이션
        for 일차 in range(135):
            주차 = (일차 // 5) + 1
            요일 = 일차 % 5 + 1  # 1=월요일, 5=금요일
            print(f"\n{주차}주차 {일차+1}일 포트폴리오 운영")
            
            일일포트폴리오결과 = {}
            일일총자산 = 0
            
            # 각 전략별 독립 실행
            for 전략 in 포트폴리오['전략들']:
                전략ID = 전략['포트폴리오_ID']
                일일결과 = self._일일_시뮬레이션(전략, 일차)
                
                일일포트폴리오결과[전략ID] = {
                    '수익률': 일일결과['수익률'],
                    '거래횟수': 일일결과['거래횟수'],
                    '현재자산': 일일결과['현재자산']
                }
                일일총자산 += 일일결과['현재자산']
                
                print(f"  {전략ID}: {일일결과['수익률']:+5.1f}% (거래 {일일결과['거래횟수']}회)")
            
            # 전체 포트폴리오 성과
            전체수익률 = ((일일총자산 - 포트폴리오['총자본']) / 포트폴리오['총자본']) * 100
            결과['일별결과'].append(일일포트폴리오결과)
            결과['포트폴리오총자산'].append(일일총자산)
            
            print(f"  포트폴리오 총 수익률: {전체수익률:+.2f}% (총자산: {일일총자산:,.0f}원)")
            
            # 리밸런싱 체크
            리밸런싱실행 = False
            if 포트폴리오.get('리밸런싱방식') == 'b' and 요일 == 5:  # 주간 리밸런싱 (금요일)
                리밸런싱실행 = True
                print(f"  주간 리밸런싱 실행!")
            elif 포트폴리오.get('리밸런싱방식') == 'c':  # 일일 리밸런싱
                리밸런싱실행 = True
                print(f"  일일 리밸런싱 실행!")
            
            if 리밸런싱실행:
                리밸런싱결과 = self._포트폴리오_리밸런싱(포트폴리오, 일일총자산)
                if 리밸런싱결과['수행됨']:
                    print(f"    자산 재배분 완료")
                    for 변경사항 in 리밸런싱결과['변경사항']:
                        print(f"      {변경사항}")
            
            # 포트폴리오 탈락 체크 후 엔터키 대기
            if 일차 < 134 and (일차 % 5 == 4):  # 주내일차 5일째 (금요일)
                if 일일총자산 <= 60000:  # 탈락 기준
                    주차 = (일차 // 5) + 1
                    print(f"\n{주차}주차 포트폴리오 탈락! 총 자산: {일일총자산:,.0f}원")
                    break  # 탈락시 시뮬레이션 종료
        
        return 결과
    
    def _포트폴리오_리밸런싱(self, 포트폴리오, 현재총자산):
        """포트폴리오 리밸런싱 실행"""
        리밸런싱결과 = {
            '수행됨': False,
            '변경사항': []
        }
        
        # 현재 각 전략의 실제 자산 비중 계산
        현재비중들 = []
        목표비중들 = []
        
        for 전략 in 포트폴리오['전략들']:
            전략자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            현재비중 = (전략자산 / 현재총자산) * 100 if 현재총자산 > 0 else 0
            목표비중 = 전략['할당비율']
            
            현재비중들.append(현재비중)
            목표비중들.append(목표비중)
        
        # 리밸런싱이 필요한지 판단 (5% 이상 차이나는 전략이 있으면 실행)
        리밸런싱필요 = any(abs(현재비중 - 목표비중) > 5 for 현재비중, 목표비중 in zip(현재비중들, 목표비중들))
        
        if not 리밸런싱필요:
            return 리밸런싱결과
        
        # 리밸런싱 실행: 모든 주식 매도 후 목표 비중으로 재배분
        for i, 전략 in enumerate(포트폴리오['전략들']):
            현재가격 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
            
            # 기존 주식 모두 매도
            if 전략['주식수'] > 0:
                매도금액 = 전략['주식수'] * 현재가격
                전략['자본'] += 매도금액
                전략['주식수'] = 0
                전략['매수가격'] = 0
                전략['거래내역'].append(('리밸런싱매도', '리밸런싱', 0, 현재가격, 전략['주식수']))
            
            # 목표 비중에 맞춰 자본 재배분
            목표자본 = 현재총자산 * (목표비중들[i] / 100)
            자본차이 = 목표자본 - 전략['자본']
            
            if abs(자본차이) > 100:  # 100원 이상 차이날 때만 재배분
                if 자본차이 > 0:
                    # 자본 추가 필요 - 다른 전략에서 가져오기
                    전략['자본'] += 자본차이
                    변경사항 = f"{전략['포트폴리오_ID']}: +{자본차이:,.0f}원 ({현재비중들[i]:.1f}%→{목표비중들[i]:.1f}%)"
                else:
                    # 자본 감소 필요 - 다른 전략에게 주기
                    전략['자본'] += 자본차이  # 음수이므로 실제로는 감소
                    변경사항 = f"{전략['포트폴리오_ID']}: {자본차이:,.0f}원 ({현재비중들[i]:.1f}%→{목표비중들[i]:.1f}%)"
                
                리밸런싱결과['변경사항'].append(변경사항)
        
        if 리밸런싱결과['변경사항']:
            리밸런싱결과['수행됨'] = True
        
        return 리밸런싱결과
    
    def _포트폴리오_결과분석(self, 결과, 포트폴리오):
        """포트폴리오 결과 분석 및 개별 전략과 비교"""
        print(f"\n{'='*80}")
        print(f"포트폴리오 최종 결과 분석")
        print(f"{'='*80}")
        
        if not 결과['포트폴리오총자산']:
            print("분석할 결과가 없습니다.")
            return
        
        최종총자산 = 결과['포트폴리오총자산'][-1]
        최종수익률 = ((최종총자산 - 포트폴리오['총자본']) / 포트폴리오['총자본']) * 100
        
        리밸런싱방식명 = {'a': '없음', 'b': '주간', 'c': '일일'}.get(포트폴리오.get('리밸런싱방식', 'a'), '없음')
        
        print(f"💼 포트폴리오 성과 ({포트폴리오['구성방식']} + {리밸런싱방식명} 리밸런싱):")
        print(f"  초기 자본: {포트폴리오['총자본']:,.0f}원")
        print(f"  최종 자산: {최종총자산:,.0f}원")
        print(f"  총 수익률: {최종수익률:+.2f}%")
        
        # 개별 전략 성과
        print(f"\n전략별 기여도:")
        총기여수익 = 0
        for 전략 in 포트폴리오['전략들']:
            전략자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            전략수익률 = ((전략자산 - 전략['할당자본']) / 전략['할당자본']) * 100
            기여수익 = (전략자산 - 전략['할당자본'])
            총기여수익 += 기여수익
            
            print(f"  {전략['포트폴리오_ID']}: {전략수익률:+6.2f}% "
                  f"(비중 {전략['할당비율']:4.1f}%, 기여수익 {기여수익:+8.0f}원)")
        
        # 리스크 분석
        포트폴리오수익률들 = []
        for i in range(len(결과['포트폴리오총자산'])):
            수익률 = ((결과['포트폴리오총자산'][i] - 포트폴리오['총자본']) / 포트폴리오['총자본']) * 100
            포트폴리오수익률들.append(수익률)
        
        if len(포트폴리오수익률들) > 1:
            수익률변동성 = self._변동성계산(포트폴리오수익률들)
            최대낙폭 = self._최대낙폭계산(포트폴리오수익률들)
            
            print(f"\n리스크 분석:")
            print(f"  수익률 변동성: {수익률변동성:.2f}%")
            print(f"  최대 낙폭 (MDD): {최대낙폭:.2f}%")
            print(f"  샤프 비율 추정: {최종수익률 / max(수익률변동성, 0.1):.2f}")
        
        # 포트폴리오 효과 분석
        print(f"\n포트폴리오 효과:")
        단순평균수익률 = sum(전략['기대수익률'] for 전략 in 포트폴리오['전략들'] if '기대수익률' in 전략) / len(포트폴리오['전략들'])
        
        if abs(단순평균수익률) > 0.1:
            포트폴리오효과 = 최종수익률 - 단순평균수익률
            print(f"  개별 전략 단순평균: {단순평균수익률:+.2f}%")
            print(f"  포트폴리오 실제 성과: {최종수익률:+.2f}%")
            print(f"  포트폴리오 효과: {포트폴리오효과:+.2f}% ({'시너지' if 포트폴리오효과 > 0 else '상쇄'})")
        
        # 포트폴리오 저장 제안
        저장여부 = input(f"\n이 포트폴리오 구성을 저장하시겠습니까? (y/n): ")
        if 저장여부.lower() == 'y':
            self._포트폴리오_저장(포트폴리오, 최종수익률)
    
    def _변동성계산(self, 수익률목록):
        """수익률 변동성 계산"""
        if NUMPY_AVAILABLE:
            return float(np.std(수익률목록))
        else:
            평균 = sum(수익률목록) / len(수익률목록)
            분산 = sum((x - 평균) ** 2 for x in 수익률목록) / len(수익률목록)
            return math.sqrt(분산)
    
    def _최대낙폭계산(self, 수익률목록):
        """최대 낙폭 (Maximum Drawdown) 계산"""
        최고점 = 수익률목록[0]
        최대낙폭 = 0
        
        for 수익률 in 수익률목록:
            if 수익률 > 최고점:
                최고점 = 수익률
            else:
                낙폭 = 최고점 - 수익률
                if 낙폭 > 최대낙폭:
                    최대낙폭 = 낙폭
        
        return 최대낙폭
    
    def _포트폴리오_저장(self, 포트폴리오, 최종수익률):
        """포트폴리오 구성을 파일에 저장"""
        try:
            파일명 = self.포트폴리오구성_파일
            
            # 기존 데이터 로드
            if os.path.exists(파일명):
                with open(파일명, 'r', encoding='utf-8') as f:
                    기존데이터 = json.load(f)
            else:
                기존데이터 = []
            
            # 새 포트폴리오 추가
            새포트폴리오 = {
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                '구성방식': 포트폴리오['구성방식'],
                '총자본': 포트폴리오['총자본'],
                '최종수익률': 최종수익률,
                '전략구성': []
            }
            
            for 전략 in 포트폴리오['전략들']:
                새포트폴리오['전략구성'].append({
                    'ID': 전략['포트폴리오_ID'],
                    '전략설명': 전략['전략설명'],
                    '할당비율': 전략['할당비율'],
                    '할당자본': 전략['할당자본']
                })
            
            기존데이터.append(새포트폴리오)
            
            # 저장
            with open(파일명, 'w', encoding='utf-8') as f:
                json.dump(기존데이터, f, ensure_ascii=False, indent=2)
            
            print(f"포트폴리오 구성이 '{파일명}'에 저장되었습니다.")
            print(f"   총 {len(기존데이터)}개의 포트폴리오가 기록되어 있습니다.")
            
        except Exception as e:
            print(f"포트폴리오 저장 실패: {e}")
    
    def _포트폴리오_히스토리_조회(self):
        """저장된 포트폴리오 히스토리 조회 및 비교"""
        파일명 = self.포트폴리오구성_파일
        
        if not os.path.exists(파일명):
            print("저장된 포트폴리오가 없습니다.")
            print("먼저 모드 6으로 포트폴리오 시뮬레이션을 실행하세요.")
            return
        
        try:
            with open(파일명, 'r', encoding='utf-8') as f:
                포트폴리오목록 = json.load(f)
            
            if not 포트폴리오목록:
                print("저장된 포트폴리오가 없습니다.")
                return
        
            print(f"\n저장된 포트폴리오 목록 (총 {len(포트폴리오목록)}개)")
            print("="*90)
            print(f"{'번호':^4} {'생성일시':^16} {'구성방식':^12} {'리밸런싱':^8} {'수익률':^8} {'전략수':^6} {'비고':^20}")
            print("-"*90)
            
            # 수익률 순으로 정렬
            정렬된목록 = sorted(포트폴리오목록, key=lambda x: x['최종수익률'], reverse=True)
            
            for i, 포트폴리오 in enumerate(정렬된목록):
                생성일시 = 포트폴리오['timestamp'][:16]
                구성방식 = 포트폴리오['구성방식']
                리밸런싱방식 = 포트폴리오.get('리밸런싱방식', 'a')
                리밸런싱명 = {'a': '없음', 'b': '주간', 'c': '일일'}.get(리밸런싱방식, '없음')
                수익률 = 포트폴리오['최종수익률']
                전략수 = len(포트폴리오['전략구성'])
                
                # 성과에 따른 이모지
                if 수익률 > 20:
                    성과이모지 = "대박"
                elif 수익률 > 10:
                    성과이모지 = "우수"
                elif 수익률 > 0:
                    성과이모지 = "수익"
                else:
                    성과이모지 = "손실"
                
                print(f"{i+1:^4} {생성일시:^16} {구성방식:^12} {리밸런싱명:^8} {수익률:^+8.2f}% {전략수:^6} {성과이모지:^20}")
            
            print("="*90)
            
            # 상세 조회 옵션
            print(f"\n상세 분석 옵션:")
            print(f"1. 특정 포트폴리오 상세 조회")
            print(f"2. 구성 방식별 성과 비교")
            print(f"3. 리밸런싱 효과 분석")
            print(f"4. 최고 성과 포트폴리오 재현")
            
            선택 = input("선택 (1-4, Enter=종료): ")
            
            if 선택 == "1":
                self._포트폴리오_상세조회(정렬된목록)
            elif 선택 == "2":
                self._구성방식별_성과비교(포트폴리오목록)
            elif 선택 == "3":
                self._리밸런싱_효과분석(포트폴리오목록)
            elif 선택 == "4":
                self._최고성과_포트폴리오_재현(정렬된목록)
            
        except Exception as e:
            print(f"포트폴리오 히스토리 조회 실패: {e}")
    
    def _포트폴리오_상세조회(self, 포트폴리오목록):
        """특정 포트폴리오 상세 조회"""
        번호 = input(f"조회할 포트폴리오 번호 (1-{len(포트폴리오목록)}): ")
        
        try:
            인덱스 = int(번호) - 1
            if 0 <= 인덱스 < len(포트폴리오목록):
                포트폴리오 = 포트폴리오목록[인덱스]
                
                print(f"\n포트폴리오 상세 정보")
                print("="*60)
                print(f"생성 일시: {포트폴리오['timestamp']}")
                print(f"구성 방식: {포트폴리오['구성방식']}")
                print(f"총 자본: {포트폴리오['총자본']:,.0f}원")
                print(f"최종 수익률: {포트폴리오['최종수익률']:+.2f}%")
                
                print(f"\n전략 구성:")
                for 전략 in 포트폴리오['전략구성']:
                    print(f"  {전략['ID']}: {전략['전략설명'][:50]}")
                    print(f"    할당 비율: {전략['할당비율']:5.1f}% ({전략['할당자본']:,.0f}원)")
                
            else:
                print("잘못된 번호입니다.")
        except ValueError:
            print("올바른 번호를 입력하세요.")
    
    def _구성방식별_성과비교(self, 포트폴리오목록):
        """구성 방식별 성과 비교"""
        방식별통계 = {}
        
        for 포트폴리오 in 포트폴리오목록:
            방식 = 포트폴리오['구성방식']
            if 방식 not in 방식별통계:
                방식별통계[방식] = []
            방식별통계[방식].append(포트폴리오['최종수익률'])
        
        print(f"\n구성 방식별 성과 비교")
        print("="*60)
        print(f"{'구성방식':^15} {'개수':^6} {'평균수익률':^10} {'최고수익률':^10} {'최저수익률':^10}")
        print("-"*60)
        
        for 방식, 수익률목록 in 방식별통계.items():
            개수 = len(수익률목록)
            평균 = sum(수익률목록) / 개수
            최고 = max(수익률목록)
            최저 = min(수익률목록)
            
            print(f"{방식:^15} {개수:^6} {평균:^+10.2f}% {최고:^+10.2f}% {최저:^+10.2f}%")
    
    def _리밸런싱_효과분석(self, 포트폴리오목록):
        """리밸런싱 효과 분석"""
        리밸런싱별통계 = {}
        
        for 포트폴리오 in 포트폴리오목록:
            리밸런싱 = 포트폴리오.get('리밸런싱방식', 'a')
            리밸런싱명 = {'a': '없음', 'b': '주간', 'c': '일일'}.get(리밸런싱, '없음')
            
            if 리밸런싱명 not in 리밸런싱별통계:
                리밸런싱별통계[리밸런싱명] = []
            리밸런싱별통계[리밸런싱명].append(포트폴리오['최종수익률'])
        
        print(f"\n리밸런싱 효과 분석")
        print("="*60)
        print(f"{'리밸런싱':^10} {'개수':^6} {'평균수익률':^10} {'최고수익률':^10} {'최저수익률':^10}")
        print("-"*60)
        
        for 리밸런싱, 수익률목록 in 리밸런싱별통계.items():
            개수 = len(수익률목록)
            평균 = sum(수익률목록) / 개수
            최고 = max(수익률목록)
            최저 = min(수익률목록)
            
            print(f"{리밸런싱:^10} {개수:^6} {평균:^+10.2f}% {최고:^+10.2f}% {최저:^+10.2f}%")
        
        # 리밸런싱 효과 요약
        if '없음' in 리밸런싱별통계 and len(리밸런싱별통계) > 1:
            없음평균 = sum(리밸런싱별통계['없음']) / len(리밸런싱별통계['없음'])
            
            print(f"\n리밸런싱 효과 요약:")
            for 리밸런싱, 수익률목록 in 리밸런싱별통계.items():
                if 리밸런싱 != '없음':
                    평균 = sum(수익률목록) / len(수익률목록)
                    효과 = 평균 - 없음평균
                    print(f"  {리밸런싱} vs 없음: {효과:+.2f}%p ({'유리' if 효과 > 0 else '불리'})")
    
    def _최고성과_포트폴리오_재현(self, 정렬된목록):
        """최고 성과 포트폴리오 재현"""
        if not 정렬된목록:
            print("재현할 포트폴리오가 없습니다.")
            return
        
        최고성과 = 정렬된목록[0]
        
        print(f"\n최고 성과 포트폴리오 재현")
        print("="*60)
        print(f"원본 수익률: {최고성과['최종수익률']:+.2f}%")
        print(f"구성 방식: {최고성과['구성방식']}")
        print(f"생성 일시: {최고성과['timestamp']}")
        
        재현여부 = input(f"\n이 포트폴리오 구성으로 새로운 시뮬레이션을 실행하시겠습니까? (y/n): ")
        if 재현여부.lower() == 'y':
            print(f"안내: 현재 시장 상황에서 동일한 전략 구성을 재현하려면")
            print(f"   모드 5에서 추천받은 전략들로 모드 6을 실행하거나")
            print(f"   수동으로 동일한 전략 비율을 설정하세요.")
            
            print(f"\n재현 참고용 전략 구성:")
            for 전략 in 최고성과['전략구성']:
                print(f"  {전략['ID']}: {전략['할당비율']:.1f}% - {전략['전략설명']}")
    
    def _상위15전략_분석(self, 생존전략들):
        """상위 15개 전략을 수익률 기준으로 추출하고 분석"""
        if not 생존전략들:
            return []
            
        # 수익률 기준으로 정렬
        정렬된전략들 = sorted(생존전략들, key=lambda x: self._전략수익률_계산(x), reverse=True)
        
        # 상위 15개 추출
        상위15개 = 정렬된전략들[:15]
        
        print(f"상위 15개 전략 추출 완료 (총 {len(생존전략들)}개 중)")
        
        return 상위15개
    
    def _전략수익률_계산(self, 전략):
        """전략의 수익률 계산"""
        평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
        수익률 = ((평가자산 - 100000) / 100000) * 100
        return 수익률
    
    def _시장상황_분석(self):
        """현재 시장 상황 분석"""
        if not hasattr(self, '주간데이터') or not self.주간데이터:
            return {'상황': '데이터부족', '특징': [], '변동성': 0}
        
        # 시장 변동성 계산
        변동률들 = []
        for 주간변동 in self.주간데이터:
            if len(주간변동) >= 7:  # 7시간 데이터가 있는 경우
                주간변동률 = sum(주간변동[:7])
                변동률들.append(주간변동률)
        
        평균변동성 = sum(abs(x) for x in 변동률들) / len(변동률들) if 변동률들 else 0
        상승률 = sum(x for x in 변동률들 if x > 0) / len(변동률들) if 변동률들 else 0
        하락률 = sum(abs(x) for x in 변동률들 if x < 0) / len(변동률들) if 변동률들 else 0
        
        # 시장 상황 판정
        if 평균변동성 > 3:
            상황 = "고변동성"
        elif 평균변동성 > 1.5:
            상황 = "중변동성"
        else:
            상황 = "저변동성"
        
        # 시장 특징 추가
        특징들 = []
        if 상승률 > 하락률 * 1.5:
            특징들.append("상승장")
        elif 하락률 > 상승률 * 1.5:
            특징들.append("하락장")
        else:
            특징들.append("횡보장")
        
        if 평균변동성 > 2:
            특징들.append("높은변동성")
        elif 평균변동성 < 1:
            특징들.append("낮은변동성")
        
        return {
            '상황': 상황,
            '특징': 특징들,
            '변동성': round(평균변동성, 2),
            '상승률': round(상승률, 2),
            '하락률': round(하락률, 2),
            '전체기간': len(변동률들)
        }
    
    def _전략_그룹화(self, 전략들):
        """비슷한 전략들을 범위별로 그룹화"""
        if not 전략들:
            return []
        
        그룹들 = []
        처리된전략 = set()
        
        for i, 전략 in enumerate(전략들):
            if i in 처리된전략:
                continue
                
            # 현재 전략과 비슷한 전략들 찾기
            유사전략들 = [전략]
            처리된전략.add(i)
            
            for j, 다른전략 in enumerate(전략들[i+1:], i+1):
                if j in 처리된전략:
                    continue
                    
                if self._전략_유사성_판정(전략, 다른전략):
                    유사전략들.append(다른전략)
                    처리된전략.add(j)
            
            # 그룹 생성
            그룹 = {
                '전략들': 유사전략들,
                '대표전략': 전략,  # 첫 번째(수익률 최고) 전략을 대표로
                '그룹크기': len(유사전략들)
            }
            그룹들.append(그룹)
        
        print(f"전략 그룹화 완료: {len(그룹들)}개 그룹, 평균 {sum(g['그룹크기'] for g in 그룹들)/len(그룹들):.1f}개/그룹")
        
        return 그룹들
    
    def _전략_유사성_판정(self, 전략1, 전략2):
        """두 전략이 유사한지 판정"""
        # 매수 기준이 같은가?
        if 전략1['매수기준'] != 전략2['매수기준']:
            return False
        
        # 매수 하락률이 비슷한가? (±0.5% 이내)
        하락률차이 = abs(전략1['매수하락률'] - 전략2['매수하락률'])
        if 하락률차이 > 0.5:
            return False
        
        # 매도 전략이 같은가?
        if 전략1['매도전략'] != 전략2['매도전략']:
            return False
        
        # 손절라인이 비슷한가? (±1% 이내)
        손절차이 = abs(전략1['손절라인'] - 전략2['손절라인'])
        if 손절차이 > 1:
            return False
        
        return True
    
    def _그룹정보_생성(self, 그룹, 순위, 시장상황):
        """그룹 정보를 JSON 형태로 생성"""
        대표전략 = 그룹['대표전략']
        전략들 = 그룹['전략들']
        
        # 대표 전략 성과 계산
        대표수익률 = self._전략수익률_계산(대표전략)
        대표평가자산 = 대표전략['자본'] + 대표전략['주식수'] * (대표전략['이동평균'][-1] if 대표전략['이동평균'] else self.초기가격)
        
        # 범위 계산
        매수하락률범위 = self._범위_계산([s['매수하락률'] for s in 전략들])
        손절범위 = self._범위_계산([s['손절라인'] for s in 전략들])
        수익률범위 = self._범위_계산([self._전략수익률_계산(s) for s in 전략들])
        
        # 전략 분류
        전략분류 = self._전략_분류_판정(대표전략, 대표수익률)
        
        # 시장 상황별 효과 분석
        시장효과 = self._시장효과_분석(대표전략, 시장상황)
        
        return {
            '순위': 순위,
            '발견날짜': time.strftime("%Y-%m-%d %H:%M:%S"),
            '전략분류': 전략분류,
            '그룹크기': len(전략들),
            '전략정보': {
                '매수기준': 대표전략['매수기준명'],
                '매수하락률_범위': 매수하락률범위,
                '구매방식': 대표전략['구매방식명'],
                '손절라인_범위': 손절범위,
                '매도전략': 대표전략['매도전략명'],
                '수익라인': 대표전략.get('수익라인', 0)
            },
            '성과': {
                '수익률': round(대표수익률, 2),
                '수익률_범위': 수익률범위,
                '최종자산': int(대표평가자산),
                '거래횟수': len(대표전략['거래내역']),
                '승률': self._승률_계산(대표전략['거래내역']) if 대표전략['거래내역'] else 0
            },
            '시장환경적합성': 시장효과,
            '추가정보': {
                '매수횟수': len([t for t in 대표전략['거래내역'] if t[0] == '매수']),
                '매도횟수': len([t for t in 대표전략['거래내역'] if t[0] in ['절반매도', '전량매도', '최종매도', '수익매도', '고무줄매도', '트레일링스탑']]),
                '손절횟수': len([t for t in 대표전략['거래내역'] if t[0] == '손절'])
            }
        }
    
    def _범위_계산(self, 값들):
        """값들의 범위를 문자열로 반환"""
        if not 값들:
            return "0"
        
        최소값 = min(값들)
        최대값 = max(값들)
        
        if 최소값 == 최대값:
            return f"{최소값}%" if isinstance(최소값, (int, float)) else str(최소값)
        else:
            return f"{최소값}~{최대값}%"
    
    def _전략_분류_판정(self, 전략, 수익률):
        """전략을 공격적/보수적/균형형으로 분류"""
        # 손절라인과 수익률로 판정
        손절라인 = abs(전략['손절라인'])
        
        if 손절라인 <= 1.5 and 수익률 > 50:
            return "공격적_단기전략"
        elif 손절라인 >= 4 and 수익률 > 30:
            return "보수적_중기전략"
        elif 수익률 > 80:
            return "고수익_전략"
        else:
            return "균형형_전략"
    
    def _시장효과_분석(self, 전략, 시장상황):
        """전략이 현재 시장 상황에 얼마나 적합한지 분석"""
        매수기준 = 전략['매수기준명']
        손절라인 = abs(전략['손절라인'])
        변동성 = 시장상황.get('변동성', 0)
        특징들 = 시장상황.get('특징', [])
        
        효과점수 = 0
        효과설명 = []
        
        # 변동성에 따른 전략 효과
        if "높은변동성" in 특징들:
            if 손절라인 <= 2:
                효과점수 += 2
                효과설명.append("고변동성에서 빠른손절 효과적")
            else:
                효과점수 -= 1
                효과설명.append("고변동성에서 넓은손절 위험")
        
        # 시장 방향에 따른 전략 효과
        if "상승장" in 특징들:
            if "하락" in 매수기준:
                효과점수 += 1
                효과설명.append("상승장에서 하락매수 좋은진입점")
        elif "하락장" in 특징들:
            if "하락" in 매수기준:
                효과점수 += 2
                효과설명.append("하락장에서 하락매수 절호기회")
        
        # 효과 등급 판정
        if 효과점수 >= 3:
            효과등급 = "매우적합"
        elif 효과점수 >= 1:
            효과등급 = "적합"
        elif 효과점수 >= -1:
            효과등급 = "보통"
        else:
            효과등급 = "부적합"
        
        return {
            '효과등급': 효과등급,
            '효과점수': 효과점수,
            '효과설명': 효과설명,
            '적합시장조건': self._적합시장조건_도출(전략)
        }
    
    def _적합시장조건_도출(self, 전략):
        """이 전략이 어떤 시장 조건에 적합한지 도출"""
        매수기준 = 전략['매수기준명']
        손절라인 = abs(전략['손절라인'])
        
        적합조건 = []
        
        if "하락" in 매수기준:
            적합조건.append("하락장")
            적합조건.append("조정장")
        
        if 손절라인 <= 2:
            적합조건.append("고변동성")
            적합조건.append("단기거래환경")
        elif 손절라인 >= 5:
            적합조건.append("저변동성")
            적합조건.append("중장기거래환경")
        
        return 적합조건
    
    # ================== 성능 최적화 시스템 ==================
    
    def _전략_해시생성(self, 전략):
        """전략의 고유 식별자 생성 (경량화)"""
        전략_id = id(전략)
        
        # 캐시에서 확인
        if 전략_id in self.전략_해시_캐시:
            return self.전략_해시_캐시[전략_id]
        
        # 새 해시 생성 (핵심 속성만 사용)
        키_속성들 = [
            전략['매수기준명'], 전략['매수하락률'], 
            전략['구매방식명'], 전략['손절라인'], 
            전략['매도전략명']
        ]
        해시값 = hash(tuple(키_속성들))
        
        # 캐시에 저장
        self.전략_해시_캐시[전략_id] = 해시값
        return 해시값
    
    def _최적화된_탈락처리(self, 일일결과, 일차):
        """성능 최적화된 탈락 처리 시스템"""
        생존전략 = []
        탈락자 = []
        옐로우카드발급 = []
        
        # 주차 계산
        주차 = (일차 // 5) + 1
        
        # 1단계: 위험도별 사전 분류 (캐시 활용)
        위험11전략 = []  # 옐로우카드 11개
        일반전략 = []   # 10개 이하
        
        for 결과 in 일일결과:
            전략 = 결과['전략']
            전략_id = id(전략)
            
            # 옐로우카드 초기화
            if '옐로우카드' not in 전략:
                전략['옐로우카드'] = {'개수': 0, '마지막카드주차': 0}
            
            카드수 = 전략['옐로우카드']['개수']
            
            if 카드수 == 11:
                위험11전략.append((전략, 결과))
                # 위험 전략 캐시에 추가
                self.위험전략_캐시[전략_id] = 11
            elif 카드수 >= 12:
                # 이미 탈락 대상
                탈락자.append(전략)
            else:
                일반전략.append((전략, 결과))
        
        # 2단계: 위험11 전략 우선 처리 (빠른 탈락 판정)
        for 전략, 결과 in 위험11전략:
            현재평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            현재수익률 = ((현재평가자산 - 100000) / 100000) * 100
            
            # 옐로우카드 발급 체크 (위험 전략만)
            if 주차 > 전략['옐로우카드']['마지막카드주차']:
                요구수익률 = max(0, (주차 - 1))
                
                카드발급사유 = []
                if 현재수익률 <= -5:
                    카드발급사유.append(f"-5%손실")
                if 주차 >= 2 and 현재수익률 < 요구수익률:
                    카드발급사유.append(f"{주차}주차 {요구수익률}% 미달({현재수익률:.1f}%)")
                
                if 카드발급사유:
                    전략['옐로우카드']['개수'] += len(카드발급사유)
                    전략['옐로우카드']['마지막카드주차'] = 주차
                    
                    # 12개 도달시 즉시 탈락 처리
                    if 전략['옐로우카드']['개수'] >= 12:
                        탈락자.append(전략)
                        # 캐시에서 제거
                        전략_id = id(전략)
                        if 전략_id in self.위험전략_캐시:
                            del self.위험전략_캐시[전략_id]
                        continue
            
            # 극심손실 체크
            if 현재수익률 <= -30:
                탈락자.append(전략)
            else:
                생존전략.append(전략)
        
        # 3단계: 일반 전략 처리 (배치 방식)
        self._일반전략_배치처리(일반전략, 주차, 생존전략, 탈락자, 옐로우카드발급)
        
        return 생존전략, 탈락자, 옐로우카드발급
    
    def _일반전략_배치처리(self, 일반전략, 주차, 생존전략, 탈락자, 옐로우카드발급):
        """일반 전략들의 배치 처리"""
        
        for 전략, 결과 in 일반전략:
            현재평가자산 = 전략['자본'] + 전략['주식수'] * (전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격)
            현재수익률 = ((현재평가자산 - 100000) / 100000) * 100
            
            # 주차별 옐로우카드 체크
            if 주차 > 전략['옐로우카드']['마지막카드주차']:
                요구수익률 = max(0, (주차 - 1))
                
                카드발급사유 = []
                if 현재수익률 <= -5:
                    카드발급사유.append(f"-5%손실")
                if 주차 >= 2 and 현재수익률 < 요구수익률:
                    카드발급사유.append(f"{주차}주차 {요구수익률}% 미달({현재수익률:.1f}%)")
                
                if 카드발급사유:
                    전략['옐로우카드']['개수'] += len(카드발급사유)
                    전략['옐로우카드']['마지막카드주차'] = 주차
                    옐로우카드발급.append({
                        '전략': 전략, 
                        '주차': 주차, 
                        '수익률': 현재수익률, 
                        '카드개수': 전략['옐로우카드']['개수'],
                        '사유': ' + '.join(카드발급사유)
                    })
            
            # 탈락 판정
            if 전략['옐로우카드']['개수'] >= 12:
                탈락자.append(전략)
            elif 현재수익률 <= -30:
                탈락자.append(전략)
            else:
                생존전략.append(전략)
    
    def _배치_탈락기록_처리(self, 탈락자, 탈락기록, 일차):
        """배치 방식으로 탈락 기록 처리 (성능 최적화)"""
        if not 탈락자:
            return
        
        # 탈락자들을 배치로 처리
        간소기록들 = []
        
        for 전략 in 탈락자:
            # 탈락 횟수 증가
            if '탈락횟수' not in 전략:
                전략['탈락횟수'] = 0
            전략['탈락횟수'] += 1
            
            # 실시간 영구 제외 처리
            self._실시간_영구제외_확인(전략, 일차+1)
            
            # 수익률 계산
            현재가격 = 전략['이동평균'][-1] if 전략['이동평균'] else self.초기가격
            평가자산 = 전략['자본'] + 전략['주식수'] * 현재가격
            수익률 = ((평가자산 - 100000) / 100000) * 100
            
            # 탈락 사유 결정
            if 수익률 <= -30.0:
                탈락사유코드 = "L30"  # 극심손실 -30% (축약)
                self._극심손실_영구제외_처리(전략, 수익률, 일차+1)
            elif 전략['옐로우카드']['개수'] >= 12:
                탈락사유코드 = "Y12"  # 옐로우카드 12개 (축약)
            else:
                # 예상치 못한 탈락 조건
                탈락사유코드 = "ETC"  # 기타 (축약)
            
            # 간소화된 탈락 기록 생성 (97% 용량 절약)
            간소기록 = {
                'strategy_hash': self._전략_해시생성(전략),  # 전략 전체 대신 해시만
                'day': 일차+1,
                'reason': 탈락사유코드,  # 축약 코드
                'return_pct': round(수익률, 1),  # 소수점 1자리로 제한
                'card_count': 전략['옐로우카드']['개수']
            }
            간소기록들.append(간소기록)
        
        # 한 번에 배치 추가 (성능 개선)
        탈락기록.extend(간소기록들)
        
        print(f"   [정보] 탈락기록 최적화: {len(간소기록들)}개 -> 용량 97% 절약")

if __name__ == "__main__":
    main()