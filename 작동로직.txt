유튜브노트 타임스탬프 시스템 작동로직
==========================================

목차:
1. 시스템 개요 및 6단계 파이프라인
2. 타임스탬프 형식 및 정규식
3. 우선순위 시스템 및 순차 실행
4. 더블클릭 작동 방식 (시작/종료시간 구분)
5. 타임스탬프 액션 (일반/정지/자동점프)
6. 편집 모드 vs 도장버튼 차이점
7. 자동 파싱 및 실시간 업데이트
8. 커스텀바 하이라이트 및 챕터바
9. 설정값 적용 및 복원 시스템
10. 디버깅 및 로그 시스템
11. 댓글 시스템 작동 로직
12. 화면 텍스트 오버레이 시스템
13. 검색 시스템 및 영상 로딩 로직
14. 전체화면 및 고급 위치 제어 시스템 (TestOverlayPage)

==========================================

1. 시스템 개요 및 6단계 파이프라인
==========================================

타임스탬프 자동 실행 시스템은 다음 6단계로 작동합니다:

[단계 1: 파싱 (Parsing)]
- noteText 변경 감지시 parseTimestamps() 함수 실행
- 정규식으로 타임스탬프 패턴 추출
- 시작/종료시간, 볼륨, 속도, 액션 정보 파싱
- 노트 순서(index) 기준으로 정렬 (시간순 아님)

[단계 2: 감지 (Detection)]
- 0.5초마다 현재 재생 시간 체크 (player.getCurrentTime())
- 타임스탬프 구간 내 위치 확인 (± 0.001초 허용 오차)
- 우선순위 기반 타임스탬프 검색 (lastActiveIndex + 1 이후만)
- 수동 이동 감지 (2초 이상 점프시 상태 초기화)

[단계 3: 진입 (Entry)]
- 조건: currentStamp && !activeTimestamp
- originalSettings 백업 (현재 볼륨/속도 저장)
- 타임스탬프 설정 적용 (볼륨/속도 변경)
- 액션 실행 (일반재생/정지/자동점프)
- processingEntryRef로 중복 실행 방지

[단계 4: 이탈 (Exit)]
- 조건: !currentStamp && activeTimestamp
- originalSettings로 복원 또는 재생 기본값 적용
- activeTimestamp 초기화
- processingExitRef로 중복 실행 방지

[단계 5: 자동점프 (Auto Jump)]
- -> 액션이 있는 타임스탬프에서 구간 종료시 실행
- 다음 타임스탬프 검색 (노트 순서 기준)
- autoJumpTimeoutRef로 타이밍 관리
- originalUserSettingsRef 백업으로 contamination 방지

[단계 6: 사용자설정관리 (User Settings Management)]
- 타임스탬프 구간 외에서만 userSettings 업데이트
- 동기화 로직으로 UI와 플레이어 상태 일치
- 0.05 단위 속도 반올림 적용

==========================================

2. 타임스탬프 형식 및 정규식
==========================================

[기본 형식]
[시작시간-종료시간, 볼륨%, 속도x, 액션]

[예시]
[00:01:23.450-00:01:28.450, 80%, 1.25x] - 일반 재생
[00:02:10.330-00:02:15.633, 65%, 1.00x, |3] - 3초 정지
[00:03:00.000-00:03:05.000, 100%, 1.50x, ->] - 자동점프

[시간 형식]
- 도장버튼: HH:MM:SS (정수 초, formatTimeWithoutMilliseconds 사용)
- 편집모드: HH:MM:SS.sss (소수점 3자리, formatTime 사용)
- 파싱: 둘 다 지원 (\d{1,2}(?:\.\d{1,3})? 패턴)

[정규식 패턴]
/\[(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?)-(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?),\s*(\d+)%,\s*([\d.]+)x(?:,\s*(->|\|\d+))?\]/g

[그룹 분석]
- 그룹 1-3: 시작시간 (시, 분, 초.밀리초)
- 그룹 4-6: 종료시간 (시, 분, 초.밀리초)
- 그룹 7: 볼륨 (0-100)
- 그룹 8: 속도 (0.25-2.0, 소수점 가능)
- 그룹 9: 액션 (선택적, -> 또는 |숫자)

==========================================

3. 우선순위 시스템 및 순차 실행
==========================================

[우선순위 원칙]
- 노트 작성 순서 우선 (시간 순서가 아님)
- 위에서 아래, 왼쪽에서 오른쪽 순서
- parseTimestamps()에서 index 기준 정렬 (a.index - b.index)

[lastActiveIndex 시스템]
- 마지막 활성화된 타임스탬프 인덱스 추적
- 해당 인덱스 + 1 이후의 타임스탬프만 활성화 가능
- 이전 순서 타임스탬프는 자동으로 건너뜀

[수동 이동시 우선순위 재설정]
1. 가장 가까운 타임스탬프 찾기 (시작시간 기준 거리 계산)
2. 해당 타임스탬프의 이전 인덱스로 lastActiveIndex 설정
3. 가장 가까운 타임스탬프부터 순차 활성화 가능

[예시]
텍스트 순서:
[00:02:29.401-00:02:34.401, 100%, 1.10x] (인덱스 0)
[00:02:10.330-00:02:15.633, 65%, 1.00x, |3] (인덱스 1)

2:07초 수동이동 → 가장 가까운: 인덱스 1(2:10) → lastActiveIndex = 0
2:10초 도달 → 인덱스 1 활성화 → lastActiveIndex = 1
2:29초 도달 → 인덱스 0은 이전 순서이므로 무시됨

==========================================

4. 더블클릭 작동 방식 (시작/종료시간 구분)
==========================================

[클릭 위치 감지]
- handleTimestampClick 함수에서 더블클릭(e.detail === 2) 감지
- textarea.selectionStart로 클릭 위치 파악
- 타임스탬프 텍스트 내에서 대시(-) 위치 기준으로 시작/종료시간 구분

[시작시간 클릭]
- activeTimestamp 설정 (중복 실행 방지용)
- 시작시간으로 이동
- 타임스탬프 설정 즉시 적용 (볼륨/속도 변경)
- 정지 액션(|숫자)이 있으면 즉시 실행 (딜레이 없이)
- 그 외 액션은 필요에 따라 실행
- 자동 감지 시스템과 중복 방지

[종료시간 클릭]
- activeTimestamp 설정하지 않음 (자동 이탈 로직 작동 위해)
- 종료시간으로 이동
- 타임스탬프 구간 밖이므로 자동으로 이탈 로직 실행
- 재생 기본값으로 복원되어 영상 계속 재생

[중복 실행 방지]
- 더블클릭으로 activeTimestamp 설정시 자동 감지에서 중복 진입 차단
- isDifferentTimestamp 조건으로 동일 타임스탬프 재실행 방지
- speed 값 정확히 일치시켜 인식 오류 방지

==========================================

5. 타임스탬프 액션 (일반/정지/자동점프)
==========================================

[일반 타임스탬프]
- 형식: [시작-종료, 볼륨%, 속도x]
- 동작: 해당 시간으로 이동 후 계속 재생
- 구간 종료시: 자동 이탈하여 설정 복원

[정지 타임스탬프 |숫자]
- 형식: [시작-종료, 볼륨%, 속도x, |3]
- 진입시: 즉시 정지 (player.pauseVideo())
- 타이머: setTimeout으로 지정 시간 후 재생 (pauseSeconds * 1000)
- 알림: "N초간 정지 - 이후 자동 재생" → "N초 정지 후 재생 재개"

[자동점프 타임스탬프 ->]
- 형식: [시작-종료, 볼륨%, 속도x, ->]
- 구간 종료시: 다음 타임스탬프로 자동 이동
- 타이밍: (duration / speed) * 1000으로 정확한 계산
- 연쇄 점프: 다음 타임스탬프도 -> 액션이면 재귀 실행
- 다음 없으면: 정지 및 "다음 타임스탬프가 없어 정지" 알림

[액션 우선순위]
1. 더블클릭 액션: 즉시 실행 (200ms 딜레이)
2. 자동 감지 액션: activeTimestamp 없을 때만 실행
3. 중복 방지: processingEntry/Exit 플래그로 제어

==========================================

6. 편집 모드 vs 도장버튼 차이점
==========================================

[도장버튼 (addTimestamp)]
- 정밀도: 정수 초 (HH:MM:SS)
- 포맷: formatTimeWithoutMilliseconds() 사용
- 동작: 영상 일시정지 → 타임스탬프 생성
- 현재값: 플레이어의 실제 볼륨/속도 읽어서 적용
- 기본구간: 5초 (현재시간 ~ 현재시간+5초)
- 자동연결: 이전 타임스탬프와 연결되면 -> 액션 자동 추가

[편집모드 (TimestampEditModal)]
- 정밀도: 소수점 3자리 (HH:MM:SS.sss)
- 포맷: formatTime() 사용
- 동작: 모달에서 세밀한 시간 입력 가능
- 설정값: 수동으로 볼륨/속도/액션 조정 가능
- 구간설정: 시작/종료시간 직접 입력
- 삽입위치: 현재 커서 위치 또는 선택 영역에 삽입

[타임스탬프 추가/삽입 규칙]
1. 새 타임스탬프 시작시간이 이전 타임스탬프 종료시간보다 이전이면:
   - 자동으로 이전 타임스탬프에 -> 액션 추가
   - 연속 재생 구간 형성
2. 편집시 누르면 이전 타임스탬프에 -> 추가:
   - 현재 위치의 이전 타임스탬프 찾기
   - 해당 타임스탬프에 -> 액션 자동 추가
3. 삽입 위치: 노트 텍스트에서 커서 위치에 삽입

==========================================

7. 자동 파싱 및 실시간 업데이트
==========================================

[자동 파싱 시스템]
- noteText 변경 감지: useEffect([noteText], ...)
- parseTimestamps() 함수 실행
- 파싱된 데이터를 YouTubePlayer 형식으로 변환
- setTimestamps()로 커스텀바 업데이트

[파싱 과정]
1. TIMESTAMP_REGEX로 모든 타임스탬프 매칭
2. 시간을 초 단위로 변환 (시*3600 + 분*60 + 초)
3. 볼륨/속도 숫자로 변환
4. 액션 파싱 (-> 또는 |숫자)
5. index 기준 정렬로 노트 순서 유지

[데이터 변환]
NoteArea 파싱 결과:
{startTime, endTime, volume, speed, action, raw, index}

YouTubePlayer 형식으로 변환:
{timeInSeconds, duration, volume, playbackRate, timeFormatted}

[실시간 감지]
- setInterval(500ms)로 주기적 체크
- 재생 중(playerState === 1)일 때만 감지 활성
- 수동 이동시 즉시 상태 업데이트

==========================================

8. 커스텀바 하이라이트 및 챕터바
==========================================

[커스텀 진행바 시스템]
- NoteArea.tsx: 타임스탬프 파싱 및 데이터 변환
- YouTubePlayer.tsx: 하이라이트 렌더링
- 바설정.커스텀바 토글로 표시/숨김 제어

[하이라이트 색상 구분]
- 볼륨만 변경: 초록색
- 속도만 변경: 주황색
- 볼륨+속도 모두: 보라색
- 기본값(100%, 1.0x): 기본 진행바 색상

[범례 시스템]
- 화면 하단에 색상별 설명 표시
- 사용자 가이드 제공
- 타임스탬프별 설정값 시각화

[챕터바 형식]
- YouTube 기본 챕터 정보 활용
- 페이지네이션으로 챕터 이동
- ChapterBar.tsx에서 구현
- 타임스탬프와 독립적으로 작동

==========================================

9. 설정값 적용 및 복원 시스템
==========================================

[3단계 설정 관리]
1. userSettings: 사용자 직접 설정 (복원 대상)
2. 재생기본값: 새 영상 로드시 자동 적용 (우측 패널 설정)
3. 타임스탬프 설정: 구간에서만 임시 적용

[복원 우선순위]
1. 타임스탬프 종료 → 재생 기본값으로 복원 (변경된 부분)
2. 새 영상 로드 → 재생기본값 자동 적용 후 userSettings 초기화
3. 사용자 수동 변경 → userSettings 업데이트

[설정 백업/복원 체계]
- originalSettings: 타임스탬프 진입시 현재 설정 백업
- originalUserSettingsRef: 자동점프 contamination 방지 백업
- 복원시 항상 재생 기본값 사용 (최신 변경사항 반영)

[0.05 단위 반올림]
- 모든 속도값은 roundToNearestStep() 함수로 0.05 단위 반올림
- YouTube API 호환성 보장
- UI 일관성 유지

==========================================

10. 디버깅 및 로그 시스템
==========================================

[로그 카테고리]
- timestamp: 타임스탬프 진입/이탈/전환
- userSettings: 사용자 설정 변경
- sync: UI와 플레이어 동기화
- manual: 수동 조작 감지
- error: 오류 상황
- warn: 경고 사항

[디버그 정보]
- 현재 영상 시간 정보
- activeTimestamp 상태
- lastActiveIndex 값
- 설정 백업/복원 상태
- 타이머 동작 상태

[모바일 디버그 패널]
- DebugLogPanel.tsx로 구현
- 카테고리별 필터링
- 시간스탬프 포함
- 로그 복사/삭제 기능
- 자동 스크롤 및 1000개 제한

[상태 모니터링]
- processingEntry/Exit 플래그 상태
- autoJumpTimeoutRef 타이머 ID
- 현재 감지된 타임스탬프 정보
- 우선순위 시스템 동작 상태

==========================================

핵심 주의사항:
==========================================

[절대 변경 금지]
- TIMESTAMP_REGEX 정규식
- activeTimestamp 상태 관리 로직
- processingEntry/Exit 플래그 시스템
- parseTimestamps() 내부 로직

[수정시 주의사항]
- 상태 업데이트 순서 준수
- 타이머 관리 (클리어 후 설정)
- 중복 실행 방지 시스템
- 우선순위 로직 무결성 유지

[디버깅 체크포인트]
- 반복 실행: processingEntry/Exit 플래그 확인
- 설정 미복원: originalSettings 백업 확인
- 자동점프 미작동: 타이머 상태 및 다음 타임스탬프 존재 확인
- 수동 이동 오작동: 2초 점프 감지 로직 및 상태 초기화 확인

==========================================

11. 댓글 시스템 작동 로직
==========================================

댓글 시스템은 주인과 사용자 간의 평가 및 소통을 위한 시스템입니다.

[시스템 구조]
- CommentModal: 댓글 조회, 필터링, 정렬
- CommentInputModal: 댓글 작성, 별점 선택
- TestSharePage: 테스트 환경

[댓글 데이터 구조]
```
Comment {
  id: string;           // 댓글 고유 ID
  userId: string;       // 사용자 ID
  userName: string;     // 사용자 닉네임
  rating: number;       // 별점 (1.0-5.0, 0.1 단위)
  comment: string;      // 댓글 내용
  timestamp: Date;      // 작성 시간
}
```

[버전 관리 시스템]
- 첫 작성: 버전 표시 없음
- 재편집: v1부터 시작
- CommentInputModal에서 commentVersion으로 관리

[별점 선택 시스템]
1. 기본 별점 선택 (1-5점)
2. 소수점 선택 (0-9, 0.1 단위)
3. 5점 선택시 소수점 자동 숨김
4. 실시간 결과 표시

[필터링 시스템]
- 전체 댓글 보기
- 별점 범위별 필터링 (1점대, 2점대 등)
- 각 범위의 실제 평균 점수 표시
- 댓글 개수 표시

[정렬 시스템]
- 높은 평점순 (기본)
- 낮은 평점순
- 별점 기준 정렬

[감정 치유 색상 시스템]
- 5점: rgba(16, 216, 118, 0.9) - 에메랄드 그린 (안정감)
- 4점: rgba(6, 182, 212, 0.9) - 스카이 블루 (편안함)
- 3점: rgba(168, 85, 247, 0.9) - 퍼플 (중성적 신비감)
- 2점: rgba(249, 115, 22, 0.9) - 오렌지 (따뜻한 위로감)
- 1점: rgba(236, 72, 153, 0.9) - 핑크 (포용감)

[주인장 구분 시스템]
- isOwner prop으로 주인/사용자 구분
- 주인 댓글: 오렌지 배경, 하트 아이콘, "주인장" 표시
- 사용자 댓글: 회색 배경

[UI 레이아웃 원칙]
- 별점 선택: 가로 배치 (선택 → 소수점 → 화살표 → 결과)
- 모달 확장: 상단 고정, 하단 확장
- 높이 통일: flex 구조로 모든 요소 같은 높이 맞춤

[연결 상태]
현재 상태: 미연결 (App.tsx에 import 안됨)
필요 작업:
1. App.tsx에 CommentModal import
2. 댓글 버튼 추가
3. isOwner 로직 연결
4. 댓글 데이터 상태 관리

[주의사항]
- 댓글 시스템은 독립적으로 작동
- 타임스탬프 시스템과 별도 관리
- 메인 앱 연결 전까지는 TestSharePage에서만 테스트 가능

==========================================

12. 오버레이 입력 패널 시스템
==========================================

[시스템 구조]
- NoteOverlayPanel.tsx: 독립 오버레이 패널 컴포넌트
- SimpleNoteArea.tsx: 오버레이 모드 props 연동
- TestTimestampPage.tsx: 토글 상태 관리

[작동 방식]
1. 오버레이 모드 OFF (기본):
   - 노트 영역 직접 편집 가능
   - 가상 키보드가 영상을 밀어올림

2. 오버레이 모드 ON:
   - 노트 영역 읽기 전용 (readOnly)
   - 노트 영역 클릭 → 오버레이 패널 열림
   - 영상 위치 고정, 패널만 하단 오버레이
   - 가상 키보드가 영상에 영향 없음

[컴포넌트 간 데이터 흐름]
TestTimestampPage (상태 관리)
  ├─ overlayMode → SimpleNoteArea (읽기 전용 제어)
  ├─ isOverlayOpen → NoteOverlayPanel (패널 표시/숨김)
  └─ noteText ⟷ 양방향 데이터 동기화

[모바일 최적화]
- fontSize: 16px (모바일 확대 방지)
- WebkitTextSizeAdjust: none
- 하단 고정 패널 (bottom: 0)
- 배경 반투명 오버레이 (bg-black/50)

[장점]
- 기능 완전 분리 (유지보수 용이)
- 기존 코드 영향 최소화
- 영상 시청과 노트 작성 동시 가능
- 모바일 UX 개선

==========================================

12. 화면 텍스트 오버레이 시스템
==========================================

화면 텍스트 오버레이 시스템은 영상 위에 텍스트를 표시하는 기능으로,
타임스탬프에서 시간과 설명 텍스트를 자동으로 추출하여 활용합니다.

[시스템 구성]
- OverlayInput.tsx: 오버레이 입력 및 설정 컴포넌트 (회전 기능 포함)
- TextOverlay.tsx: 실제 화면 오버레이 표시 컴포넌트 (회전 변환 처리)
- SettingsPanel.tsx: 오버레이 관련 설정 UI
- rotation: -180~180도 회전 각도 지원 (5도 단위)

[타임스탬프+텍스트 추출 작동 원리]

1단계: 타임스탬프 파싱 (parseTimestamps)
- 정규식으로 노트 텍스트에서 타임스탬프 패턴 추출
- 패턴: [시:분:초-시:분:초,볼륨%,속도x,액션] 형태
- 각 타임스탬프의 시작/종료 시간, 설정값 파싱

2단계: 설명 텍스트 추출
- 타임스탬프 종료 위치부터 다음 라인까지 텍스트 추출
- 정규식: /\\n|\\r|\\[\\d/ 패턴으로 경계 분석
- 줄바꿈 또는 다음 타임스탬프 전까지의 텍스트 수집
- 공백 제거 및 정리 (trim() 적용)

3단계: 타임스탬프 선택 모달
- availableTimestamps 배열에 {text, start, end, description} 저장
- 모달에서 타임스탬프 목록과 설명 텍스트 미리보기 표시
- 사용자가 원하는 타임스탬프 선택 가능

4단계: 자동 입력 처리 (selectTimestamp)
- 선택된 타임스탬프의 시작/종료 시간 설정
- 실제 지속시간 계산 (소수점 포함): realDuration = end - start
- 슬라이더용 정수값 설정: Math.round(realDuration)
- 설명 텍스트가 있으면 오버레이 텍스트로 자동 입력

[지속시간 이중 표시 시스템]

정수/소수점 병행 표시:
- 슬라이더: 1초 단위 조정 (step={1})
- 표시 라벨: "4초 (4.23초)" 형태
- actualDuration 상태로 실제 지속시간 별도 저장
- 수동 조정시 actualDuration 초기화 (소수점 표시 제거)

작동 흐름:
1. 타임스탬프 선택 → 실제 지속시간 계산 및 저장
2. 라벨에 정수값과 소수점값 함께 표시
3. 슬라이더 조정시 → actualDuration null 처리
4. 소수점 표시 조건: actualDuration !== null && actualDuration !== duration

[설정 연동]

SettingsPanel 연동:
- 화면텍스트 → 스타일설정 → 지속시간 토글
- 토글 위치: 스타일설정 섹션 맨 아래 (783-790줄)
- 기존 순서: 글자크기여백 → 색상설정 → 배경투명도 → 지속시간
- UI 설정값에 따른 표시/숨김 처리

워크플로우 개선:
- 지속시간 설정을 타임스탬프+텍스트 가져오기 버튼 바로 위에 배치
- 시간 확인과 텍스트 가져오기의 연속적인 작업 흐름 지원
- 우측 패널과 오버레이 입력 패널의 설정 일관성 유지

[회전 기능 구현]

회전 시스템:
- rotation 상태: -180~180도 범위의 회전 각도
- 각도 슬라이더: 5도 단위 조정 UI (OverlayInput.tsx:468-478)
- CSS transform: 회전, 위치, 스케일 변환 통합 처리
- 실시간 반영: 슬라이더 조정 시 즉시 화면에 회전 적용

CSS 변환 통합 (TextOverlay.tsx:125-177):
- rotationTransform: rotate(각도deg)
- alignTransform: translateX(-50%) 등 정렬 변환
- scaleTransform: scale(1.05) 드래그시 확대
- transform 속성에 모든 변환 조합하여 적용

[편집 모드 시간 보존]

실시간 업데이트 시스템 (OverlayInput.tsx:77-110):
- updateExistingOverlay() 함수에서 기존 오버레이의 startTime, duration 보존
- 편집 중에도 텍스트가 화면에서 사라지지 않음
- 시간 정보만 원본 값으로 유지하고 나머지는 사용자 입력값 적용
- overlays.find()로 기존 오버레이 검색 후 시간 정보 추출

시간 보존 로직:
const existingOverlay = overlays.find(overlay => overlay.id === editingId);
startTime: existingOverlay.startTime,  // 원본 시간 보존
duration: existingOverlay.duration,    // 원본 지속시간 보존

[핵심 주의사항]

1. 시간 정보 보존:
- 편집 모드에서 updateExistingOverlay 함수는 반드시 기존 startTime, duration 보존
- startTime: startTime || 0 형태 사용 금지 (편집시 시간 손실 발생)
- 기존 오버레이를 찾지 못하면 함수 중단 필요

2. CSS transform 순서:
- 위치 변환 → 회전 변환 → 스케일 변환 순서로 조합
- transform 속성에 여러 변환을 공백으로 구분하여 나열
- 잘못된 순서시 예상과 다른 결과 발생 가능

3. 실시간 업데이트 최적화:
- 과도한 디버그 로그 출력 금지 (useEffect 실행시마다 로그 생성)
- console.log는 개발 단계에서만 사용하고 완료 후 제거
- 실시간 반영과 성능 최적화 균형 유지

4. 정규식 매칭 정확성:
- 타임스탬프 패턴이 변경되면 parseTimestamps 함수도 업데이트 필요
- 설명 텍스트 경계 분석시 줄바꿈 처리 주의

5. 상태 동기화:
- duration (정수) vs actualDuration (소수점) 분리 관리
- 슬라이더 변경시 actualDuration 초기화 필수

6. UI 설정 의존성:
- 화면텍스트.스타일설정과 화면텍스트.지속시간 토글에 의존
- 토글 비활성화시 관련 기능 숨김 처리

[확장 가능성]
- 다양한 타임스탬프 형식 지원 확장
- 자동 번역 기능과의 연동 가능
- 오버레이 애니메이션 효과 추가 가능
- 3D 회전 효과 (rotateX, rotateY) 확장

==========================================

13. 검색 시스템 및 영상 로딩 로직
==========================================

[검색 시스템 아키텍처]

3계층 구조:
1. HomePage.tsx: 검색 UI 표시/숨김 제어 및 설정 전달
2. VideoLoader.tsx: 검색 실행, 결과 처리, 영상 선택
3. YouTubePlayer.tsx: 실제 영상 로딩 및 재생

[검색창 유지 설정]

설정 계층 구조:
- 검색창.유지: 검색 입력창을 계속 표시할지 여부
  └─ 검색창.목록유지: 영상 선택 후 검색 목록을 유지할지 여부 (하위 설정)

동작 모드:
1. 검색창 유지 OFF → 팝업 모드 (상단 검색 아이콘)
2. 검색창 유지 ON + 목록유지 OFF → 영상 선택시 검색 결과 닫힘
3. 검색창 유지 ON + 목록유지 ON → 영상 선택해도 검색 결과 유지

[영상 선택 및 로딩 프로세스]

5단계 프로세스:
1. 시청 기록 업데이트 (새 영상: watchCount=1, 기존: +1)
2. 영상 정보 설정 (title, channelName, thumbnailUrl)
3. currentVideoId 설정 → YouTubePlayer useEffect 트리거
4. 검색 결과 처리 (keepSearchResults 설정에 따라)
5. UI 정리 (autoHide, 팝업 닫기 등)

[데이터 무결성 검증]

videoId 필터링:
- 서버에서 받은 검색 결과 중 videoId가 undefined인 영상 제거
- 유효한 영상만 목록에 표시하여 재생 오류 방지
- 필터링된 개수만큼 알림 메시지에 반영

핵심 코드 위치:
- VideoLoader.tsx:114-120 videoId 필터링
- VideoLoader.tsx:283-329 handleVideoSelect() 전체 프로세스
- VideoLoader.tsx:310-320 keepSearchResults 조건부 처리

[검색 결과 상태 관리]

2개 상태 배열:
- searchResults: 원본 검색 결과 (필터링 전)
- filteredResults: 필터링된 결과 (실제 표시용)

상태 변경 시점:
- 검색 실행시: 둘 다 업데이트
- 영상 선택시: keepSearchResults에 따라 처리
  * false: 둘 다 빈 배열로 초기화
  * true: applyFilter()로 시청 상태 재반영

[시청 기록 시스템]

localStorage 기반 관리:
- 키: 'watchHistory'
- 구조: { [videoId]: { watchCount, firstWatchedAt, lastWatchedAt, ... } }
- 영상 선택시 자동 업데이트
- 시청 표시 (체크 마크) 및 정렬에 활용

필터 모드:
- watched: 시청한 영상만 표시
- unwatched: 미시청 영상만 표시
- blacklisted: 차단된 영상 표시 (미구현)

[설정 연동 체계]

UI 설정 흐름:
1. SettingsPanel에서 설정 변경
2. HomePage의 uiSettings 상태 업데이트
3. localStorage에 저장
4. VideoLoader에 keepSearchResults prop 전달
5. 영상 선택시 해당 설정값에 따라 동작

기본값 설정:
- 검색창.유지: true (검색창 표시)
- 검색창.목록유지: false (영상 선택시 목록 닫힘)

[핵심 주의사항]

1. 상태 일관성:
- searchResults와 filteredResults 동기화 중요
- keepSearchResults 설정과 실제 동작 일치 필수

2. 데이터 무결성:
- videoId 검증으로 재생 오류 방지
- 시청 기록 중복 방지 및 정확성 유지

3. 설정 연동:
- UI 설정 변경시 즉시 반영
- 프리셋 모드에서도 개별 설정 유지

4. 성능 최적화:
- 불필요한 재필터링 방지
- 메모리 누수 방지 (큰 검색 결과 배열 관리)

==========================================

==========================================

14. 전체화면 및 고급 위치 제어 시스템 (TestOverlayPage)
==========================================

[시스템 구성 요소]

TestOverlayPage는 텍스트 오버레이의 고급 제어 기능을 테스트하는 전용 페이지입니다:

1. 고급 위치 제어:
   - 9개 위치 그리드 (기존 기능)
   - 좌표 직접 입력 (X, Y 숫자 입력, 0-100 범위)
   - 텍스트 정렬 선택 (좌측/중앙/우측)

2. 전체화면 시청 환경:
   - 브라우저 Fullscreen API 사용
   - 영상 우측 하단 전체화면 버튼
   - 16:9 비율 유지 (maxWidth: 177.77vh)

3. 커스텀 UI 요소:
   - 빨간색 커스텀 진행바 (클릭 탐색 가능)
   - 탭 기반 설정 UI
   - 탭 커스터마이징 모달 (임시 비활성화)

[전체화면 작동 메커니즘]

1단계: 진입
- 영상 우측 하단 Maximize 버튼 클릭
- playerContainerRef.current.requestFullscreen() 실행
- fullscreenchange 이벤트로 상태 동기화

2단계: 레이아웃 조정
- 컨테이너: width: 100vw, height: 100vh
- 중앙 정렬: display: flex, alignItems: center, justifyContent: center
- 비율 유지: maxWidth: 177.77vh, aspectRatio: 16/9
- 하단 패널 숨김: !isFullscreen 조건

3단계: 종료
- Minimize 버튼 클릭 또는 ESC 키
- document.exitFullscreen() 실행
- 원래 레이아웃으로 복원

[좌표 제어 시스템]

기존 9개 그리드 + 정밀 좌표 입력:
- coordinates 상태: { x: number, y: number } (0-100 범위)
- 실시간 업데이트: onChange에서 setCoordinates 호출
- 백분율 계산: 입력값을 % 단위로 화면 위치 변환
- 정렬 조합: textAlign과 coordinates 독립적 적용

[커스텀 진행바 시스템]

YouTube 기본 컨트롤 대체:
- 위치: absolute bottom-0 (영상 컨테이너 내부)
- 스타일: h-1 bg-gray-600/30 (얇고 반투명)
- 진행도: (currentTime / duration) * 100%
- 클릭 탐색: e.clientX 좌표로 percentage 계산 후 player.seekTo()
- 바설정 prop: {{ 커스텀바: false, 챕터바: false }}로 기본 UI 비활성화

[탭 커스터마이징 시스템]

TabLayoutSettings 컴포넌트:
- 기능 재배치: 화살표 버튼으로 순서 변경
- 탭간 이동: 우측 화살표로 기능을 다음 탭으로 이동
- 탭명 변경: 실시간 input으로 탭 이름 수정
- 표시/숨김: 체크박스로 탭 활성화 제어
- localStorage 저장: overlayTabConfig 키로 설정 보존

[핵심 설계 원칙]

1. 실시간 반영: 모든 설정 변경이 즉시 오버레이에 반영
2. 상태 보존: 편집 중 기존 오버레이의 시간 정보 유지
3. 안정성 우선: 문제 발생 시 모달 비활성화로 크래시 방지
4. 브라우저 호환: webkit 이벤트까지 지원하는 전체화면 감지
5. 비율 유지: 전체화면에서도 16:9 비율 강제 유지

==========================================

이 문서는 타임스탬프 시스템, 댓글 시스템, 오버레이 패널 시스템,
화면 텍스트 오버레이 시스템, 검색 시스템, 전체화면 및 고급 위치 제어 시스템의 완전한 작동 원리를 담고 있으며,
새로운 기능 추가나 버그 수정시 필수 참고 자료입니다.