유튜브노트 타임스탬프 시스템 작동로직
==========================================

목차:
1. 시스템 개요 및 6단계 파이프라인
2. 타임스탬프 형식 및 정규식
3. 우선순위 시스템 및 순차 실행
4. 더블클릭 작동 방식 (시작/종료시간 구분)
5. 타임스탬프 액션 (일반/정지/자동점프)
6. 편집 모드 vs 도장버튼 차이점
7. 자동 파싱 및 실시간 업데이트
8. 커스텀바 하이라이트 및 챕터바
9. 설정값 적용 및 복원 시스템
10. 디버깅 및 로그 시스템
11. 댓글 시스템 작동 로직
12. 화면 텍스트 오버레이 시스템
13. 검색 시스템 및 영상 로딩 로직
14. 구독 채널 시스템
15. 전체화면 및 고급 위치 제어 시스템 (TestOverlayPage)
16. 화면 확대 시스템 (TestZoomPage)
17. 신규 타임스탬프 시스템 (TimestampProcessor + useTimestampSystem)

==========================================

1. 시스템 개요 및 6단계 파이프라인
==========================================

타임스탬프 자동 실행 시스템은 다음 6단계로 작동합니다:

[단계 1: 파싱 (Parsing)]
- noteText 변경 감지시 parseTimestamps() 함수 실행
- 정규식으로 타임스탬프 패턴 추출
- 시작/종료시간, 볼륨, 속도, 액션 정보 파싱
- 노트 순서(index) 기준으로 정렬 (시간순 아님)

[단계 2: 감지 (Detection)]
- 0.5초마다 현재 재생 시간 체크 (player.getCurrentTime())
- 타임스탬프 구간 내 위치 확인 (± 0.001초 허용 오차)
- 우선순위 기반 타임스탬프 검색 (lastActiveIndex + 1 이후만)
- 수동 이동 감지 (2초 이상 점프시 상태 초기화)

[단계 3: 진입 (Entry)]
- 조건: currentStamp && !activeTimestamp
- originalSettings 백업 (현재 볼륨/속도 저장)
- 타임스탬프 설정 적용 (볼륨/속도 변경)
- 액션 실행 (일반재생/정지/자동점프)
- processingEntryRef로 중복 실행 방지

[단계 4: 이탈 (Exit)]
- 조건: !currentStamp && activeTimestamp
- originalSettings로 복원 또는 재생 기본값 적용
- activeTimestamp 초기화
- processingExitRef로 중복 실행 방지

[단계 5: 자동점프 (Auto Jump)]
- -> 액션이 있는 타임스탬프에서 구간 종료시 실행
- 다음 타임스탬프 검색 (노트 순서 기준)
- autoJumpTimeoutRef로 타이밍 관리
- originalUserSettingsRef 백업으로 contamination 방지

[단계 6: 사용자설정관리 (User Settings Management)]
- 타임스탬프 구간 외에서만 userSettings 업데이트
- 동기화 로직으로 UI와 플레이어 상태 일치
- 0.05 단위 속도 반올림 적용

==========================================

2. 타임스탬프 형식 및 정규식
==========================================

[기본 형식]
[시작시간-종료시간, 볼륨%, 속도x, 액션]

[예시]
[00:01:23.450-00:01:28.450, 80%, 1.25x] - 일반 재생
[00:02:10.330-00:02:15.633, 65%, 1.00x, |3] - 3초 정지
[00:03:00.000-00:03:05.000, 100%, 1.50x, ->] - 자동점프

[시간 형식]
- 도장버튼: HH:MM:SS (정수 초, formatTimeWithoutMilliseconds 사용)
- 편집모드: HH:MM:SS.sss (소수점 3자리, formatTime 사용)
- 파싱: 둘 다 지원 (\d{1,2}(?:\.\d{1,3})? 패턴)

[정규식 패턴]
/\[(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?)-(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?),\s*(\d+)%,\s*([\d.]+)x(?:,\s*(->|\|\d+))?\]/g

[그룹 분석]
- 그룹 1-3: 시작시간 (시, 분, 초.밀리초)
- 그룹 4-6: 종료시간 (시, 분, 초.밀리초)
- 그룹 7: 볼륨 (0-100)
- 그룹 8: 속도 (0.25-2.0, 소수점 가능)
- 그룹 9: 액션 (선택적, -> 또는 |숫자)

==========================================

3. 우선순위 시스템 및 순차 실행
==========================================

[우선순위 원칙]
- 노트 작성 순서 우선 (시간 순서가 아님)
- 위에서 아래, 왼쪽에서 오른쪽 순서
- parseTimestamps()에서 index 기준 정렬 (a.index - b.index)

[lastActiveIndex 시스템]
- 마지막 활성화된 타임스탬프 인덱스 추적
- 해당 인덱스 + 1 이후의 타임스탬프만 활성화 가능
- 이전 순서 타임스탬프는 자동으로 건너뜀

[수동 이동시 우선순위 재설정]
1. 가장 가까운 타임스탬프 찾기 (시작시간 기준 거리 계산)
2. 해당 타임스탬프의 이전 인덱스로 lastActiveIndex 설정
3. 가장 가까운 타임스탬프부터 순차 활성화 가능

[예시]
텍스트 순서:
[00:02:29.401-00:02:34.401, 100%, 1.10x] (인덱스 0)
[00:02:10.330-00:02:15.633, 65%, 1.00x, |3] (인덱스 1)

2:07초 수동이동 → 가장 가까운: 인덱스 1(2:10) → lastActiveIndex = 0
2:10초 도달 → 인덱스 1 활성화 → lastActiveIndex = 1
2:29초 도달 → 인덱스 0은 이전 순서이므로 무시됨

==========================================

4. 더블클릭 작동 방식 (시작/종료시간 구분)
==========================================

[클릭 위치 감지]
- handleTimestampClick 함수에서 더블클릭(e.detail === 2) 감지
- textarea.selectionStart로 클릭 위치 파악
- 타임스탬프 텍스트 내에서 대시(-) 위치 기준으로 시작/종료시간 구분

[시작시간 클릭]
- activeTimestamp 설정 (중복 실행 방지용)
- 시작시간으로 이동
- 타임스탬프 설정 즉시 적용 (볼륨/속도 변경)
- 정지 액션(|숫자)이 있으면 즉시 실행 (딜레이 없이)
- 그 외 액션은 필요에 따라 실행
- 자동 감지 시스템과 중복 방지

[종료시간 클릭]
- activeTimestamp 설정하지 않음 (자동 이탈 로직 작동 위해)
- 종료시간으로 이동
- 타임스탬프 구간 밖이므로 자동으로 이탈 로직 실행
- 재생 기본값으로 복원되어 영상 계속 재생

[중복 실행 방지]
- 더블클릭으로 activeTimestamp 설정시 자동 감지에서 중복 진입 차단
- isDifferentTimestamp 조건으로 동일 타임스탬프 재실행 방지
- speed 값 정확히 일치시켜 인식 오류 방지

==========================================

5. 타임스탬프 액션 (일반/정지/자동점프)
==========================================

[일반 타임스탬프]
- 형식: [시작-종료, 볼륨%, 속도x]
- 동작: 해당 시간으로 이동 후 계속 재생
- 구간 종료시: 자동 이탈하여 설정 복원

[정지 타임스탬프 |숫자]
- 형식: [시작-종료, 볼륨%, 속도x, |3]
- 진입시: 즉시 정지 (player.pauseVideo())
- 타이머: setTimeout으로 지정 시간 후 재생 (pauseSeconds * 1000)
- 알림: "N초간 정지 - 이후 자동 재생" → "N초 정지 후 재생 재개"

[자동점프 타임스탬프 ->]
- 형식: [시작-종료, 볼륨%, 속도x, ->]
- 구간 종료시: 다음 타임스탬프로 자동 이동
- 타이밍: (duration / speed) * 1000으로 정확한 계산
- 연쇄 점프: 다음 타임스탬프도 -> 액션이면 재귀 실행
- 다음 없으면: 정지 및 "다음 타임스탬프가 없어 정지" 알림

[액션 우선순위]
1. 더블클릭 액션: 즉시 실행 (200ms 딜레이)
2. 자동 감지 액션: activeTimestamp 없을 때만 실행
3. 중복 방지: processingEntry/Exit 플래그로 제어

==========================================

6. 편집 모드 vs 도장버튼 차이점
==========================================

[도장버튼 (addTimestamp)]
- 정밀도: 정수 초 (HH:MM:SS)
- 포맷: formatTimeWithoutMilliseconds() 사용
- 동작: 영상 일시정지 → 타임스탬프 생성
- 현재값: 플레이어의 실제 볼륨/속도 읽어서 적용
- 기본구간: 5초 (현재시간 ~ 현재시간+5초)
- 자동연결: 이전 타임스탬프와 연결되면 -> 액션 자동 추가

[편집모드 (TimestampEditModal)]
- 정밀도: 소수점 3자리 (HH:MM:SS.sss)
- 포맷: formatTime() 사용
- 동작: 모달에서 세밀한 시간 입력 가능
- 설정값: 수동으로 볼륨/속도/액션 조정 가능
- 구간설정: 시작/종료시간 직접 입력
- 삽입위치: 현재 커서 위치 또는 선택 영역에 삽입

[타임스탬프 추가/삽입 규칙]
1. 새 타임스탬프 시작시간이 이전 타임스탬프 종료시간보다 이전이면:
   - 자동으로 이전 타임스탬프에 -> 액션 추가
   - 연속 재생 구간 형성
2. 편집시 누르면 이전 타임스탬프에 -> 추가:
   - 현재 위치의 이전 타임스탬프 찾기
   - 해당 타임스탬프에 -> 액션 자동 추가
3. 삽입 위치: 노트 텍스트에서 커서 위치에 삽입

==========================================

7. 자동 파싱 및 실시간 업데이트
==========================================

[자동 파싱 시스템]
- noteText 변경 감지: useEffect([noteText], ...)
- parseTimestamps() 함수 실행
- 파싱된 데이터를 YouTubePlayer 형식으로 변환
- setTimestamps()로 커스텀바 업데이트

[파싱 과정]
1. TIMESTAMP_REGEX로 모든 타임스탬프 매칭
2. 시간을 초 단위로 변환 (시*3600 + 분*60 + 초)
3. 볼륨/속도 숫자로 변환
4. 액션 파싱 (-> 또는 |숫자)
5. index 기준 정렬로 노트 순서 유지

[데이터 변환]
NoteArea 파싱 결과:
{startTime, endTime, volume, speed, action, raw, index}

YouTubePlayer 형식으로 변환:
{timeInSeconds, duration, volume, playbackRate, timeFormatted}

[실시간 감지]
- setInterval(500ms)로 주기적 체크
- 재생 중(playerState === 1)일 때만 감지 활성
- 수동 이동시 즉시 상태 업데이트

==========================================

8. 커스텀바 하이라이트 및 챕터바
==========================================

[커스텀 진행바 시스템]
- NoteArea.tsx: 타임스탬프 파싱 및 데이터 변환
- YouTubePlayer.tsx: 하이라이트 렌더링
- 바설정.커스텀바 토글로 표시/숨김 제어

[하이라이트 색상 구분]
- 볼륨만 변경: 초록색
- 속도만 변경: 주황색
- 볼륨+속도 모두: 보라색
- 기본값(100%, 1.0x): 기본 진행바 색상

[범례 시스템]
- 화면 하단에 색상별 설명 표시
- 사용자 가이드 제공
- 타임스탬프별 설정값 시각화

[챕터바 형식]
- YouTube 기본 챕터 정보 활용
- 페이지네이션으로 챕터 이동
- ChapterBar.tsx에서 구현
- 타임스탬프와 독립적으로 작동

==========================================

9. 설정값 적용 및 복원 시스템
==========================================

[3단계 설정 관리]
1. userSettings: 사용자 직접 설정 (복원 대상)
2. 재생기본값: 새 영상 로드시 자동 적용 (우측 패널 설정)
3. 타임스탬프 설정: 구간에서만 임시 적용

[복원 우선순위]
1. 타임스탬프 종료 → 재생 기본값으로 복원 (변경된 부분)
2. 새 영상 로드 → 재생기본값 자동 적용 후 userSettings 초기화
3. 사용자 수동 변경 → userSettings 업데이트

[설정 백업/복원 체계]
- originalSettings: 타임스탬프 진입시 현재 설정 백업
- originalUserSettingsRef: 자동점프 contamination 방지 백업
- 복원시 항상 재생 기본값 사용 (최신 변경사항 반영)

[0.05 단위 반올림]
- 모든 속도값은 roundToNearestStep() 함수로 0.05 단위 반올림
- YouTube API 호환성 보장
- UI 일관성 유지

==========================================

10. 디버깅 및 로그 시스템
==========================================

[로그 카테고리]
- timestamp: 타임스탬프 진입/이탈/전환
- userSettings: 사용자 설정 변경
- sync: UI와 플레이어 동기화
- manual: 수동 조작 감지
- error: 오류 상황
- warn: 경고 사항

[디버그 정보]
- 현재 영상 시간 정보
- activeTimestamp 상태
- lastActiveIndex 값
- 설정 백업/복원 상태
- 타이머 동작 상태

[모바일 디버그 패널]
- DebugLogPanel.tsx로 구현
- 카테고리별 필터링
- 시간스탬프 포함
- 로그 복사/삭제 기능
- 자동 스크롤 및 1000개 제한

[상태 모니터링]
- processingEntry/Exit 플래그 상태
- autoJumpTimeoutRef 타이머 ID
- 현재 감지된 타임스탬프 정보
- 우선순위 시스템 동작 상태

==========================================

핵심 주의사항:
==========================================

[절대 변경 금지]
- TIMESTAMP_REGEX 정규식
- activeTimestamp 상태 관리 로직
- processingEntry/Exit 플래그 시스템
- parseTimestamps() 내부 로직

[수정시 주의사항]
- 상태 업데이트 순서 준수
- 타이머 관리 (클리어 후 설정)
- 중복 실행 방지 시스템
- 우선순위 로직 무결성 유지

[디버깅 체크포인트]
- 반복 실행: processingEntry/Exit 플래그 확인
- 설정 미복원: originalSettings 백업 확인
- 자동점프 미작동: 타이머 상태 및 다음 타임스탬프 존재 확인
- 수동 이동 오작동: 2초 점프 감지 로직 및 상태 초기화 확인

==========================================

11. 댓글 시스템 작동 로직
==========================================

댓글 시스템은 주인과 사용자 간의 평가 및 소통을 위한 시스템입니다.

[시스템 구조]
- CommentModal: 댓글 조회, 필터링, 정렬
- CommentInputModal: 댓글 작성, 별점 선택
- TestSharePage: 테스트 환경

[댓글 데이터 구조]
```
Comment {
  id: string;           // 댓글 고유 ID
  userId: string;       // 사용자 ID
  userName: string;     // 사용자 닉네임
  rating: number;       // 별점 (1.0-5.0, 0.1 단위)
  comment: string;      // 댓글 내용
  timestamp: Date;      // 작성 시간
}
```

[버전 관리 시스템]
- 첫 작성: 버전 표시 없음
- 재편집: v1부터 시작
- CommentInputModal에서 commentVersion으로 관리

[별점 선택 시스템]
1. 기본 별점 선택 (1-5점)
2. 소수점 선택 (0-9, 0.1 단위)
3. 5점 선택시 소수점 자동 숨김
4. 실시간 결과 표시

[필터링 시스템]
- 전체 댓글 보기
- 별점 범위별 필터링 (1점대, 2점대 등)
- 각 범위의 실제 평균 점수 표시
- 댓글 개수 표시

[정렬 시스템]
- 높은 평점순 (기본)
- 낮은 평점순
- 별점 기준 정렬

[감정 치유 색상 시스템]
- 5점: rgba(16, 216, 118, 0.9) - 에메랄드 그린 (안정감)
- 4점: rgba(6, 182, 212, 0.9) - 스카이 블루 (편안함)
- 3점: rgba(168, 85, 247, 0.9) - 퍼플 (중성적 신비감)
- 2점: rgba(249, 115, 22, 0.9) - 오렌지 (따뜻한 위로감)
- 1점: rgba(236, 72, 153, 0.9) - 핑크 (포용감)

[주인장 구분 시스템]
- isOwner prop으로 주인/사용자 구분
- 주인 댓글: 오렌지 배경, 하트 아이콘, "주인장" 표시
- 사용자 댓글: 회색 배경

[UI 레이아웃 원칙]
- 별점 선택: 가로 배치 (선택 → 소수점 → 화살표 → 결과)
- 모달 확장: 상단 고정, 하단 확장
- 높이 통일: flex 구조로 모든 요소 같은 높이 맞춤

[연결 상태]
현재 상태: 미연결 (App.tsx에 import 안됨)
필요 작업:
1. App.tsx에 CommentModal import
2. 댓글 버튼 추가
3. isOwner 로직 연결
4. 댓글 데이터 상태 관리

[주의사항]
- 댓글 시스템은 독립적으로 작동
- 타임스탬프 시스템과 별도 관리
- 메인 앱 연결 전까지는 TestSharePage에서만 테스트 가능

==========================================

12. 오버레이 입력 패널 시스템
==========================================

[시스템 구조]
- NoteOverlayPanel.tsx: 독립 오버레이 패널 컴포넌트
- SimpleNoteArea.tsx: 오버레이 모드 props 연동
- TestTimestampPage.tsx: 토글 상태 관리

[작동 방식]
1. 오버레이 모드 OFF (기본):
   - 노트 영역 직접 편집 가능
   - 가상 키보드가 영상을 밀어올림

2. 오버레이 모드 ON:
   - 노트 영역 읽기 전용 (readOnly)
   - 노트 영역 클릭 → 오버레이 패널 열림
   - 영상 위치 고정, 패널만 하단 오버레이
   - 가상 키보드가 영상에 영향 없음

[컴포넌트 간 데이터 흐름]
TestTimestampPage (상태 관리)
  ├─ overlayMode → SimpleNoteArea (읽기 전용 제어)
  ├─ isOverlayOpen → NoteOverlayPanel (패널 표시/숨김)
  └─ noteText ⟷ 양방향 데이터 동기화

[모바일 최적화]
- fontSize: 16px (모바일 확대 방지)
- WebkitTextSizeAdjust: none
- 하단 고정 패널 (bottom: 0)
- 배경 반투명 오버레이 (bg-black/50)

[장점]
- 기능 완전 분리 (유지보수 용이)
- 기존 코드 영향 최소화
- 영상 시청과 노트 작성 동시 가능
- 모바일 UX 개선

==========================================

12. 화면 텍스트 오버레이 시스템
==========================================

화면 텍스트 오버레이 시스템은 영상 위에 텍스트를 표시하는 기능으로,
타임스탬프에서 시간과 설명 텍스트를 자동으로 추출하여 활용합니다.

[시스템 구성]
- OverlayInput.tsx: 오버레이 입력 및 설정 컴포넌트 (회전 기능 포함)
- TextOverlay.tsx: 실제 화면 오버레이 표시 컴포넌트 (회전 변환 처리)
- SettingsPanel.tsx: 오버레이 관련 설정 UI
- rotation: -180~180도 회전 각도 지원 (5도 단위)

[타임스탬프+텍스트 추출 작동 원리]

1단계: 타임스탬프 파싱 (parseTimestamps)
- 정규식으로 노트 텍스트에서 타임스탬프 패턴 추출
- 패턴: [시:분:초-시:분:초,볼륨%,속도x,액션] 형태
- 각 타임스탬프의 시작/종료 시간, 설정값 파싱

2단계: 설명 텍스트 추출
- 타임스탬프 종료 위치부터 다음 라인까지 텍스트 추출
- 정규식: /\\n|\\r|\\[\\d/ 패턴으로 경계 분석
- 줄바꿈 또는 다음 타임스탬프 전까지의 텍스트 수집
- 공백 제거 및 정리 (trim() 적용)

3단계: 타임스탬프 선택 모달
- availableTimestamps 배열에 {text, start, end, description} 저장
- 모달에서 타임스탬프 목록과 설명 텍스트 미리보기 표시
- 사용자가 원하는 타임스탬프 선택 가능

4단계: 자동 입력 처리 (selectTimestamp)
- 선택된 타임스탬프의 시작/종료 시간 설정
- 실제 지속시간 계산 (소수점 포함): realDuration = end - start
- 슬라이더용 정수값 설정: Math.round(realDuration)
- 설명 텍스트가 있으면 오버레이 텍스트로 자동 입력

[지속시간 이중 표시 시스템]

정수/소수점 병행 표시:
- 슬라이더: 1초 단위 조정 (step={1})
- 표시 라벨: "4초 (4.23초)" 형태
- actualDuration 상태로 실제 지속시간 별도 저장
- 수동 조정시 actualDuration 초기화 (소수점 표시 제거)

작동 흐름:
1. 타임스탬프 선택 → 실제 지속시간 계산 및 저장
2. 라벨에 정수값과 소수점값 함께 표시
3. 슬라이더 조정시 → actualDuration null 처리
4. 소수점 표시 조건: actualDuration !== null && actualDuration !== duration

[설정 연동]

SettingsPanel 연동:
- 화면텍스트 → 스타일설정 → 지속시간 토글
- 토글 위치: 스타일설정 섹션 맨 아래 (783-790줄)
- 기존 순서: 글자크기여백 → 색상설정 → 배경투명도 → 지속시간
- UI 설정값에 따른 표시/숨김 처리

워크플로우 개선:
- 지속시간 설정을 타임스탬프+텍스트 가져오기 버튼 바로 위에 배치
- 시간 확인과 텍스트 가져오기의 연속적인 작업 흐름 지원
- 우측 패널과 오버레이 입력 패널의 설정 일관성 유지

[회전 기능 구현]

회전 시스템:
- rotation 상태: -180~180도 범위의 회전 각도
- 각도 슬라이더: 5도 단위 조정 UI (OverlayInput.tsx:468-478)
- CSS transform: 회전, 위치, 스케일 변환 통합 처리
- 실시간 반영: 슬라이더 조정 시 즉시 화면에 회전 적용

CSS 변환 통합 (TextOverlay.tsx:125-177):
- rotationTransform: rotate(각도deg)
- alignTransform: translateX(-50%) 등 정렬 변환
- scaleTransform: scale(1.05) 드래그시 확대
- transform 속성에 모든 변환 조합하여 적용

[편집 모드 시간 보존]

실시간 업데이트 시스템 (OverlayInput.tsx:77-110):
- updateExistingOverlay() 함수에서 기존 오버레이의 startTime, duration 보존
- 편집 중에도 텍스트가 화면에서 사라지지 않음
- 시간 정보만 원본 값으로 유지하고 나머지는 사용자 입력값 적용
- overlays.find()로 기존 오버레이 검색 후 시간 정보 추출

시간 보존 로직:
const existingOverlay = overlays.find(overlay => overlay.id === editingId);
startTime: existingOverlay.startTime,  // 원본 시간 보존
duration: existingOverlay.duration,    // 원본 지속시간 보존

[핵심 주의사항]

1. 시간 정보 보존:
- 편집 모드에서 updateExistingOverlay 함수는 반드시 기존 startTime, duration 보존
- startTime: startTime || 0 형태 사용 금지 (편집시 시간 손실 발생)
- 기존 오버레이를 찾지 못하면 함수 중단 필요

2. CSS transform 순서:
- 위치 변환 → 회전 변환 → 스케일 변환 순서로 조합
- transform 속성에 여러 변환을 공백으로 구분하여 나열
- 잘못된 순서시 예상과 다른 결과 발생 가능

3. 실시간 업데이트 최적화:
- 과도한 디버그 로그 출력 금지 (useEffect 실행시마다 로그 생성)
- console.log는 개발 단계에서만 사용하고 완료 후 제거
- 실시간 반영과 성능 최적화 균형 유지

4. 정규식 매칭 정확성:
- 타임스탬프 패턴이 변경되면 parseTimestamps 함수도 업데이트 필요
- 설명 텍스트 경계 분석시 줄바꿈 처리 주의

5. 상태 동기화:
- duration (정수) vs actualDuration (소수점) 분리 관리
- 슬라이더 변경시 actualDuration 초기화 필수

6. UI 설정 의존성:
- 화면텍스트.스타일설정과 화면텍스트.지속시간 토글에 의존
- 토글 비활성화시 관련 기능 숨김 처리

[확장 가능성]
- 다양한 타임스탬프 형식 지원 확장
- 자동 번역 기능과의 연동 가능
- 오버레이 애니메이션 효과 추가 가능
- 3D 회전 효과 (rotateX, rotateY) 확장

==========================================

13. 검색 시스템 및 영상 로딩 로직
==========================================

[검색 시스템 아키텍처]

3계층 구조:
1. HomePage.tsx: 검색 UI 표시/숨김 제어 및 설정 전달
2. VideoLoader.tsx: 검색 실행, 결과 처리, 영상 선택
3. YouTubePlayer.tsx: 실제 영상 로딩 및 재생

[검색창 유지 설정]

설정 계층 구조:
- 검색창.유지: 검색 입력창을 계속 표시할지 여부
  └─ 검색창.목록유지: 영상 선택 후 검색 목록을 유지할지 여부 (하위 설정)

동작 모드:
1. 검색창 유지 OFF → 팝업 모드 (상단 검색 아이콘)
2. 검색창 유지 ON + 목록유지 OFF → 영상 선택시 검색 결과 닫힘
3. 검색창 유지 ON + 목록유지 ON → 영상 선택해도 검색 결과 유지

[영상 선택 및 로딩 프로세스]

5단계 프로세스:
1. 시청 기록 업데이트 (새 영상: watchCount=1, 기존: +1)
2. 영상 정보 설정 (title, channelName, thumbnailUrl)
3. currentVideoId 설정 → YouTubePlayer useEffect 트리거
4. 검색 결과 처리 (keepSearchResults 설정에 따라)
5. UI 정리 (autoHide, 팝업 닫기 등)

[데이터 무결성 검증]

videoId 필터링:
- 서버에서 받은 검색 결과 중 videoId가 undefined인 영상 제거
- 유효한 영상만 목록에 표시하여 재생 오류 방지
- 필터링된 개수만큼 알림 메시지에 반영

핵심 코드 위치:
- VideoLoader.tsx:114-120 videoId 필터링
- VideoLoader.tsx:283-329 handleVideoSelect() 전체 프로세스
- VideoLoader.tsx:310-320 keepSearchResults 조건부 처리

[검색 결과 상태 관리]

2개 상태 배열:
- searchResults: 원본 검색 결과 (필터링 전)
- filteredResults: 필터링된 결과 (실제 표시용)

상태 변경 시점:
- 검색 실행시: 둘 다 업데이트
- 영상 선택시: keepSearchResults에 따라 처리
  * false: 둘 다 빈 배열로 초기화
  * true: applyFilter()로 시청 상태 재반영

[시청 기록 시스템]

localStorage 기반 관리:
- 키: 'watchHistory'
- 구조: { [videoId]: { watchCount, firstWatchedAt, lastWatchedAt, ... } }
- 영상 선택시 자동 업데이트
- 시청 표시 (체크 마크) 및 정렬에 활용

필터 모드:
- watched: 시청한 영상만 표시
- unwatched: 미시청 영상만 표시
- blacklisted: 차단된 영상 표시 (미구현)

[설정 연동 체계]

UI 설정 흐름:
1. SettingsPanel에서 설정 변경
2. HomePage의 uiSettings 상태 업데이트
3. localStorage에 저장
4. VideoLoader에 keepSearchResults prop 전달
5. 영상 선택시 해당 설정값에 따라 동작

기본값 설정:
- 검색창.유지: true (검색창 표시)
- 검색창.목록유지: false (영상 선택시 목록 닫힘)

[핵심 주의사항]

1. 상태 일관성:
- searchResults와 filteredResults 동기화 중요
- keepSearchResults 설정과 실제 동작 일치 필수

2. 데이터 무결성:
- videoId 검증으로 재생 오류 방지
- 시청 기록 중복 방지 및 정확성 유지

3. 설정 연동:
- UI 설정 변경시 즉시 반영
- 프리셋 모드에서도 개별 설정 유지

4. 성능 최적화:
- 불필요한 재필터링 방지
- 메모리 누수 방지 (큰 검색 결과 배열 관리)

==========================================

14. 구독 채널 시스템
==========================================

구독 채널 시스템은 사용자가 자주 보는 YouTube 채널을 저장하고,
해당 채널의 최신 영상 25개를 실시간으로 가져와 표시하는 기능입니다.

[시스템 개요]

localStorage 기반 채널 관리:
- 채널명을 로컬스토리지에 저장
- OAuth 인증 없이 간단한 채널 구독 기능 제공
- 채널 클릭시 실시간으로 영상 목록 로딩
- 즐겨찾기 탭에서 "구독 채널" 탭으로 접근

[데이터 구조]

FavoriteChannel 인터페이스 (FavoriteManager.tsx:44-48):
interface FavoriteChannel {
  id: string;           // 고유 ID (Date.now() 기반)
  name: string;         // 채널명
  addedAt: string;      // 추가 날짜
}

FavoriteVideo 확장 (publishedAt 필드 추가):
interface FavoriteVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  thumbnail: string;
  folderId: string | null;
  addedAt: string;
  publishedAt?: string;  // 영상 게시일 (서버에서 받아옴)
}

localStorage 구조:
- 키: 'favoriteChannels'
- 값: FavoriteChannel[] 배열 (JSON 문자열)
- 저장 시점: 채널 추가/삭제시 즉시 저장

[채널 관리 기능]

1. 채널 추가 (addChannel 함수, FavoriteManager.tsx:246-272):
   - 채널명 입력 (공백 제거)
   - 중복 검사: 이미 존재하면 알림 후 중단
   - 새 채널 생성: id는 현재 시간 기반 (Date.now().toString())
   - localStorage 저장 및 상태 업데이트
   - 입력창 초기화 및 추가 모드 종료

2. 채널 삭제 (deleteChannel 함수, FavoriteManager.tsx:275-281):
   - 채널 ID로 필터링하여 제거
   - localStorage 업데이트
   - 삭제된 채널이 선택 중이면 선택 해제 및 영상 목록 초기화

3. 채널 목록 로드 (loadData 함수 내, FavoriteManager.tsx:79-81):
   - 컴포넌트 마운트시 localStorage에서 채널 목록 불러오기
   - 파싱 실패시 빈 배열로 초기화

[영상 로딩 시스템]

loadChannelVideos 함수 (FavoriteManager.tsx:288-339):

단계별 프로세스:
1. 로딩 상태 시작 (setLoadingChannelVideos(true))
2. YouTube API 호출: maxResults=50으로 50개 영상 검색
3. 필터링: channelTitle이 입력 채널명을 포함하는지 확인
4. 정렬: publishedAt 기준 최신순 정렬 (내림차순)
5. 상위 25개 선택: slice(0, 25)로 필터링된 결과 중 25개만 선택
6. 상태 업데이트: setChannelVideos()로 영상 목록 설정
7. 로딩 종료

핵심 필터링 로직 (FavoriteManager.tsx:318-320):
const filteredVideos = allVideos.filter((video) =>
  video.channelTitle.toLowerCase().includes(channelName.toLowerCase())
);

정렬 로직 (FavoriteManager.tsx:323-325):
filteredVideos.sort((a, b) => {
  return new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime();
});

왜 50개를 검색하고 25개만 표시하는가:
- YouTube API 검색은 키워드 기반이므로 다른 채널 영상도 포함될 수 있음
- 클라이언트 측에서 channelTitle로 필터링하여 정확한 채널 영상만 추출
- 필터링 후에도 충분한 개수를 확보하기 위해 50개 검색 → 25개 선택

[서버 API 연동]

routes.ts 수정사항:

1. maxResults 파라미터 지원 (routes.ts:30):
const maxResults = req.query.maxResults ? parseInt(req.query.maxResults as string) : 50;

2. publishedAt 필드 추가 (routes.ts:101-107):
const videos = data.items.map((item: any) => ({
  videoId: item.id.videoId,
  title: item.snippet.title,
  thumbnail: item.snippet.thumbnails.medium.url,
  channelTitle: item.snippet.channelTitle,
  publishedAt: item.snippet.publishedAt
}));

3. 목업 데이터에도 publishedAt 추가 (routes.ts:44-55):
- 랜덤 날짜 생성: 현재 날짜에서 0-30일 전 무작위 선택
- ISO 형식으로 변환하여 반환

[UI 구조 및 흐름]

탭 시스템 (FavoriteManager.tsx:420-544):
- "구독 채널" 탭 선택시 채널 목록 표시
- 채널 클릭시 해당 채널의 영상 목록 표시
- 뒤로가기 버튼으로 채널 목록으로 복귀

1. 채널 목록 화면 (selectedChannel === null):
   - 채널 추가 버튼 (상단 우측)
   - 채널 목록 표시 (채널명, 추가 날짜, 삭제 버튼)
   - 채널 클릭시 loadChannelVideos() 실행

2. 채널 추가 화면 (isAddingChannel === true):
   - 채널명 입력 폼
   - 저장/취소 버튼

3. 영상 목록 화면 (selectedChannel !== null):
   - 뒤로가기 버튼
   - 채널명 표시
   - 영상 카드 목록 (썸네일, 제목, 채널명, 게시일)
   - 로딩 중 표시

영상 카드 표시 (FavoriteManager.tsx:461-469):
<div className="flex items-center gap-2 text-xs text-gray-500">
  <span>{video.channelTitle}</span>
  {video.publishedAt && (
    <>
      <span>•</span>
      <span>{formatDate(video.publishedAt)}</span>
    </>
  )}
</div>

[핵심 제약사항 및 해결책]

문제: YouTube API는 채널 ID로 검색하는 channels.list API가 있지만
      채널명만으로는 정확한 채널 ID를 알 수 없음

해결책 1 (채택됨): 키워드 검색 + 클라이언트 필터링
- search API로 채널명을 키워드로 검색
- 결과를 channelTitle로 필터링
- 간단하고 OAuth 불필요

해결책 2 (미채택): 채널 ID 조회 후 검색
- 먼저 채널명으로 채널 ID 검색
- 채널 ID로 영상 목록 조회
- 정확하지만 API 호출 2배

[설정 의존성]

UI 설정 연동:
- 즐겨찾기.구독채널 토글: 구독 채널 탭 표시/숨김 제어
- 기본값: true (표시)

createTabsList 함수 (FavoriteManager.tsx:214):
if (uiSettings.즐겨찾기?.구독채널) {
  tabsList.push("구독 채널");
}

[성능 최적화]

1. 로컬스토리지 사용:
   - 채널 목록은 로컬에 저장하여 빠른 로드
   - 영상 목록은 필요시에만 서버에서 가져옴

2. 필터링 및 정렬:
   - 클라이언트 측에서 처리하여 서버 부담 감소
   - Array.filter()와 Array.sort() 사용

3. 로딩 상태 관리:
   - loadingChannelVideos 상태로 로딩 표시
   - 사용자에게 진행 상황 피드백

[에러 처리]

loadChannelVideos 함수의 에러 처리:
- try-catch로 API 오류 포착
- 에러 발생시 alert() 메시지 표시
- 로딩 상태 항상 종료 (finally 블록 권장)

[향후 확장 가능성]

1. 채널 ID 기반 검색:
   - 채널 추가시 채널 ID 함께 저장
   - 더 정확한 영상 목록 조회 가능

2. 구독 채널 정렬:
   - 이름순, 추가 날짜순 정렬 기능
   - 드래그 앤 드롭으로 순서 변경

3. 채널 썸네일 표시:
   - 채널 로고/프로필 이미지 표시
   - /api/youtube/channel-info 엔드포인트 추가

4. 영상 필터링:
   - 기간별 필터 (최근 1주일, 1개월)
   - 재생 시간별 필터

5. 채널 폴더 관리:
   - 채널을 카테고리별로 그룹화
   - 폴더 구조 도입

[주의사항]

1. 필터링 정확도:
   - channelTitle.includes()는 부분 일치이므로 완벽하진 않음
   - 예: "채널A"로 검색시 "채널A 클립스"도 포함될 수 있음

2. API 할당량:
   - YouTube API는 일일 할당량 제한 있음
   - 채널 클릭마다 API 호출하므로 과도한 사용 주의

3. 실시간 업데이트:
   - 영상 목록은 캐싱되지 않음
   - 채널 클릭시마다 최신 영상 가져옴

4. publishedAt 의존성:
   - 정렬에 publishedAt 필드 필수
   - API 응답에서 누락되면 정렬 오류 가능

==========================================

15. 전체화면 및 고급 위치 제어 시스템 (TestOverlayPage)
==========================================

[시스템 구성 요소]

TestOverlayPage는 텍스트 오버레이의 고급 제어 기능을 테스트하는 전용 페이지입니다:

1. 고급 위치 제어:
   - 9개 위치 그리드 (기존 기능)
   - 좌표 직접 입력 (X, Y 숫자 입력, 0-100 범위)
   - 텍스트 정렬 선택 (좌측/중앙/우측)

2. 전체화면 시청 환경:
   - 브라우저 Fullscreen API 사용
   - 영상 우측 하단 전체화면 버튼
   - 16:9 비율 유지 (maxWidth: 177.77vh)

3. 커스텀 UI 요소:
   - 빨간색 커스텀 진행바 (클릭 탐색 가능)
   - 탭 기반 설정 UI
   - 탭 커스터마이징 모달 (임시 비활성화)

[전체화면 작동 메커니즘]

1단계: 진입
- 영상 우측 하단 Maximize 버튼 클릭
- playerContainerRef.current.requestFullscreen() 실행
- fullscreenchange 이벤트로 상태 동기화

2단계: 레이아웃 조정
- 컨테이너: width: 100vw, height: 100vh
- 중앙 정렬: display: flex, alignItems: center, justifyContent: center
- 비율 유지: maxWidth: 177.77vh, aspectRatio: 16/9
- 하단 패널 숨김: !isFullscreen 조건

3단계: 종료
- Minimize 버튼 클릭 또는 ESC 키
- document.exitFullscreen() 실행
- 원래 레이아웃으로 복원
- 전체화면 시 버튼 확대: p-1.6, bottom-2으로 YouTube 버튼을 가려 실수 클릭 방지

[좌표 제어 시스템]

기존 9개 그리드 + 정밀 좌표 입력:
- coordinates 상태: { x: number, y: number } (0-100 범위)
- 실시간 업데이트: onChange에서 setCoordinates 호출
- 백분율 계산: 입력값을 % 단위로 화면 위치 변환
- 정렬 조합: textAlign과 coordinates 독립적 적용

[커스텀 진행바 시스템]

YouTube 기본 컨트롤 대체:
- 위치: absolute bottom-0 (영상 컨테이너 내부)
- 스타일: h-1 bg-gray-600/30 (얇고 반투명)
- 진행도: (currentTime / duration) * 100%
- 클릭 탐색: e.clientX 좌표로 percentage 계산 후 player.seekTo()
- 바설정 prop: {{ 커스텀바: false, 챕터바: false }}로 기본 UI 비활성화

[탭 커스터마이징 시스템]

TabLayoutSettings 컴포넌트:
- 기능 재배치: 화살표 버튼으로 순서 변경
- 탭간 이동: 우측 화살표로 기능을 다음 탭으로 이동
- 탭명 변경: 실시간 input으로 탭 이름 수정
- 표시/숨김: 체크박스로 탭 활성화 제어
- localStorage 저장: overlayTabConfig 키로 설정 보존

[핵심 설계 원칙]

1. 실시간 반영: 모든 설정 변경이 즉시 오버레이에 반영
2. 상태 보존: 편집 중 기존 오버레이의 시간 정보 유지
3. 안정성 우선: 문제 발생 시 모달 비활성화로 크래시 방지
4. 브라우저 호환: webkit 이벤트까지 지원하는 전체화면 감지
5. 비율 유지: 전체화면에서도 16:9 비율 강제 유지
6. 사용자 실수 방지: 전체화면 종료 버튼 크기 확대로 YouTube 컨트롤과 겹침 방지
7. 텍스트 크기 일관성: 전체화면에서 screenScale 무시하여 화면 비율 변경과 무관하게 일정한 크기 유지
8. 글자 크기 범위: 6-96px 확장으로 다양한 크기 텍스트 지원
9. 텍스트 레이아웃 최적화: width: max-content로 의도하지 않은 자동 줄바꿈 방지

==========================================

15. 화면 확대 시스템 (TestZoomPage)
==========================================

[핵심 개념]
CSS transform을 사용한 YouTube iframe 확대/축소 시스템

[확대 원리]
1. transform: scale() - 영상 확대 배율
2. transform-origin - 확대 중심점 (좌상단 기준)
3. overflow: hidden - 컨테이너 밖 영역 숨김

[패널 동작]
1. 패널 열기 (왼쪽 하단 버튼)
   - 현재 재생 시간 → 시작 시간 자동 설정
   - 현재 시간 + 1초 → 종료 시간 자동 설정
   - 영상 자동 일시정지

2. 실시간 미리보기 (화면 확대 체크박스)
   - 체크: 현재 설정으로 즉시 확대
   - 체크 해제: 원래 크기로 복귀
   - 좌표/배율 변경시 체크되어 있으면 실시간 반영

[좌표 시스템]
- X: 0-800px (영상 너비)
- Y: 0-450px (영상 높이)
- 좌상단 (0,0) 기준
- 화면 밖 좌표도 설정 가능

[자동 확대 시스템]
1. 저장된 설정 관리
   - 시간 범위별 확대 설정 저장
   - 중복 시간대는 덮어쓰기
   - 활성/비활성 토글

2. 자동 실행
   - 0.1초마다 현재 시간 체크
   - 시간 범위 진입시 자동 확대
   - 시간 범위 이탈시 자동 해제
   - 패널 열려있으면 자동 확대 비활성화
   - 수동 확대(체크박스)는 패널과 무관하게 유지

[컴포넌트 구조]
1. TimeArrowControl
   - 분/초 단위 화살표 입력
   - 시작/종료 시간 설정

2. CoordinateArrowControl
   - X/Y 좌표 화살표 입력
   - 100/10/1 자리수별 조정

3. ZoomConfig 인터페이스
   - centerPoint: 확대 중심점
   - scale: 확대 배율
   - startTime/endTime: 적용 시간
   - border: 테두리 설정 (항상 활성)

[주의사항]
1. iframe 직접 확대 (컨테이너는 원래 크기 유지)
2. 패널 열 때마다 현재 시간 기준 자동 설정
3. 수동 확대는 자동 확대와 독립적으로 작동
4. CSS transition으로 부드러운 확대/축소

16. 신규 타임스탬프 시스템 (TimestampProcessor + useTimestampSystem)
==========================================

[시스템 개요]
TimestampProcessor는 기존 NoteArea 타임스탬프 로직을 순수 TypeScript 클래스로 분리하여
재사용성과 테스트 용이성을 높인 새로운 타임스탬프 자동 실행 시스템입니다.

[아키텍처 구성]

1. 핵심 클래스: TimestampProcessor.ts
   - 순수 TypeScript 클래스 (React 의존성 없음)
   - 6단계 파이프라인 완전 구현
   - PlayerInterface를 통한 플레이어 추상화
   - 상태와 로직의 완전 분리

2. React 연결: useTimestampSystem.ts
   - React Hook 형태로 TimestampProcessor 래핑
   - 컴포넌트 상태와 TimestampProcessor 동기화
   - useEffect 기반 자동 감지 시스템
   - 수명 주기 관리 및 정리

3. 테스트 환경: TestTimestampPage.tsx
   - TimestampProcessor 독립 테스트 환경
   - SimpleNoteArea와 YouTubePlayer 통합 테스트
   - 실시간 디버깅 정보 표시

[TimestampProcessor 6단계 파이프라인]

단계 1: 파싱 (parseTimestamps)
- 정규식: /\[(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?)-(\d{1,2}):(\d{2}):(\d{1,2}(?:\.\d{1,3})?),\s*(\d+)%,\s*([\d.]+)x(?:,\s*(->|\|\d+))?\]/g
- 노트 순서(index) 기준 정렬 (시간순 아님)
- ParsedTimestamp 인터페이스로 구조화
- 시간을 초 단위로 변환 (시*3600 + 분*60 + 초)

단계 2: 감지 (detectActiveTimestamp)
- 현재 재생 시간에서 활성화될 타임스탬프 찾기
- 노트 순서 우선순위 시스템 (lastActiveIndex + 1 이후만)
- 0.01초 허용 오차 (TIME_MARGIN = 0.01)
- activeTimestamp가 있으면 해당 구간 내 위치만 확인

단계 3: 진입 (processEntry)
- 조건: detectedTimestamp && !activeTimestamp
- isProcessingEntry 플래그로 중복 실행 방지
- originalSettings 백업 (현재 볼륨/속도 저장)
- 정지 액션(|숫자)은 진입과 동시에 즉시 실행
- 타임스탬프 설정 적용 후 executeAction 호출

단계 4: 이탈 (processExit)
- 조건: !detectedTimestamp && activeTimestamp
- isProcessingExit 플래그로 중복 실행 방지
- 자동점프(->)가 있으면 타이머 유지, 없으면 타이머 취소
- originalSettings로 설정 복원
- 자동점프가 없는 경우에만 activeTimestamp 초기화

단계 5: 자동점프 (executeAutoJump)
- -> 액션 타임스탬프에서 구간 종료시 실행
- 속도 보정 계산: (timeToEnd / speed) * 1000
- setTimeout으로 정확한 타이밍 제어
- 다음 타임스탬프 검색 (노트 순서 기준)
- 다음이 없으면 정지 및 알림

단계 6: 정지 액션 처리
- |숫자 액션: 진입시 즉시 pauseVideo()
- setTimeout으로 지정 시간 후 자동 재생
- 알림 시스템과 연동하여 상태 안내

[액션별 상세 동작]

정지 액션 (|3):
1. processEntry에서 즉시 player.pauseVideo() 실행
2. setTimeout(pauseSeconds * 1000)로 지연 재생
3. 디버깅 로그: "[즉시정지]", "[정지대기]", "[재생]"

자동점프 액션 (->):
1. 현재 시간에서 구간 종료까지 시간 계산
2. 속도 보정 적용 (실제 재생 속도 고려)
3. autoJumpInfo 상태 설정 (isWaiting, targetIndex, remainingSeconds)
4. 타이머 종료시 executeAutoJump 호출
5. 다음 타임스탬프로 player.seekTo() 실행

[useTimestampSystem Hook 동작]

상태 관리:
- timestamps: ParsedTimestamp[]
- activeTimestamp: ParsedTimestamp | null
- lastActiveIndex: number
- isProcessing: boolean
- autoJumpInfo: 자동점프 상태 정보

useEffect 자동 감지:
- 재생 중(playerState === 1)일 때만 500ms 간격 실행
- 수동 이동 감지: 2초 이상 점프시 handleManualSeek 호출
- TimestampProcessor.process() 메인 루프 실행
- 상태 동기화: React 상태 ← TimestampProcessor 상태

더블클릭 처리:
- findTimestampAtPosition()으로 클릭 위치 타임스탬프 찾기
- 대시(-) 위치 기준으로 시작/종료시간 구분
- TimestampProcessor.handleDoubleClick() 위임

[수동 이동 처리]

handleManualSeek 로직:
1. 기존 자동점프 타이머와 상태 초기화
2. 가장 가까운 타임스탬프 찾기 (시작시간 기준)
3. closestTimestamp.index - 1로 lastActiveIndex 설정
4. 우선순위 재설정으로 정상적인 순차 실행 보장

[TestTimestampPage 테스트 환경]

테스트 비디오:
- 'dQw4w9WgXcQ': Rick Astley - Never Gonna Give You Up
- 'kJQP7kiw5Fk': Luis Fonsi - Despacito ft. Daddy Yankee
- '9bZkp7q19f0': PSY - GANGNAM STYLE(강남스타일) M/V

파싱 및 변환:
- noteText 변경시 parseTimestamps() 실행
- YouTubePlayer 형식으로 변환: {timeInSeconds, duration, volume, playbackRate, timeFormatted}
- 커스텀바 하이라이트 연동

디버깅 정보:
- 타임스탬프 개수 실시간 표시
- 플레이어 상태 정보 (준비됨/재생/일시정지/버퍼링)
- 현재 시간과 총 길이 표시
- 타임스탬프 분석 버튼으로 정규식 매칭 확인

[핵심 차이점: 기존 vs 신규 시스템]

기존 (NoteArea 내장):
- React 컴포넌트와 강결합
- 상태와 로직이 혼재
- 테스트와 재사용이 어려움
- requestAnimationFrame 사용

신규 (TimestampProcessor 분리):
- 순수 TypeScript 클래스
- 상태와 로직 완전 분리
- 독립적 테스트 가능
- setInterval 기반 (500ms)

[주의사항]

1. 노트 순서 우선순위 시스템:
   - lastActiveIndex + 1 체크 로직 절대 변경 금지
   - 시간 순서가 아닌 노트 작성 순서 기준

2. 정지 액션 즉시 실행:
   - processEntry에서 즉시 pauseVideo() 실행
   - 지연 없이 정지해야 정확한 타이밍 보장

3. 자동점프 속도 보정:
   - 실제 재생 속도를 고려한 타이밍 계산
   - (timeToEnd / speed) * 1000 공식 사용

4. 상태 동기화:
   - React 상태와 TimestampProcessor 상태 일치 필수
   - useEffect에서 매 루프마다 동기화

5. 메모리 관리:
   - useEffect cleanup에서 interval 정리
   - 컴포넌트 언마운트시 TimestampProcessor.reset() 호출

[확장성]

모듈화된 설계로 다음 확장 가능:
- 다른 플레이어 시스템 연동 (PlayerInterface 구현)
- 웹 워커에서 실행 (UI 블로킹 방지)
- 타임스탬프 형식 확장 (정규식과 파싱 로직만 수정)
- 다양한 React Hook 형태로 래핑

==========================================

이 문서는 타임스탬프 시스템, 댓글 시스템, 오버레이 패널 시스템,
화면 텍스트 오버레이 시스템, 검색 시스템, 구독 채널 시스템,
전체화면 및 고급 위치 제어 시스템, 화면 확대 시스템,
신규 타임스탬프 시스템(TimestampProcessor)의 완전한 작동 원리를 담고 있으며,
새로운 기능 추가나 버그 수정시 필수 참고 자료입니다.