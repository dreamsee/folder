# 노트 정비소 프로토타입 제작 가이드

## 🎯 시험용 미니 버전 구성

### Phase 1: 기본 채팅 + 파일 수정 시스템

---

## 🛠️ 기술 스택

### 프론트엔드
- **React + TypeScript**: UI 구성
- **Monaco Editor**: 코드 편집기 (VS Code와 같은 엔진)
- **Socket.io**: 실시간 통신
- **Iframe**: 실시간 미리보기

### 백엔드  
- **Node.js + Express**: 서버
- **Anthropic API**: Claude 통합
- **fs (파일시스템)**: 파일 읽기/쓰기
- **Chokidar**: 파일 변경 감지

---

## 📁 프로젝트 구조

```
note-garage-prototype/
├── client/                 # React 프론트엔드
│   ├── src/
│   │   ├── components/
│   │   │   ├── ChatPanel.tsx      # Claude 채팅
│   │   │   ├── FileEditor.tsx     # 파일 편집기
│   │   │   ├── PreviewPanel.tsx   # 실시간 미리보기
│   │   │   └── GarageInterface.tsx # 메인 UI
│   │   ├── services/
│   │   │   ├── claudeAPI.ts       # Claude API 통신
│   │   │   └── fileSystem.ts      # 파일 작업
│   │   └── App.tsx
│   └── package.json
│
├── server/                 # Node.js 백엔드
│   ├── routes/
│   │   ├── claude.js              # Claude API 프록시
│   │   ├── files.js               # 파일 시스템 API
│   │   └── preview.js             # 미리보기 서버
│   ├── services/
│   │   ├── claudeService.js       # Claude 통합 로직
│   │   └── fileWatcher.js         # 파일 변경 감지
│   ├── public/                    # 정적 파일 서빙
│   └── server.js
│
└── workspace/              # 작업 공간 (사용자 파일들)
    ├── current-note/
    │   ├── index.html
    │   ├── style.css
    │   └── script.js
    └── backups/
```

---

## 🔧 핵심 구현 코드

### 1. Claude API 통합 (서버)
```javascript
// server/services/claudeService.js
const Anthropic = require('@anthropic-ai/sdk');

class ClaudeService {
  constructor() {
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });
  }

  async processUserRequest(message, currentFiles) {
    // 현재 파일들을 Claude에게 보여줌
    const context = this.buildFileContext(currentFiles);
    
    const response = await this.anthropic.messages.create({
      model: 'claude-3-sonnet-20240229',
      max_tokens: 4000,
      system: `당신은 노트 정비소의 전문 AI입니다. 
               현재 파일들을 분석하고 사용자 요청에 따라 수정해주세요.
               
               응답 형식:
               1. 설명: 무엇을 할지 설명
               2. 파일 변경사항: JSON 형태로 반환
               
               현재 파일 상태:
               ${context}`,
      messages: [{
        role: 'user',
        content: message
      }]
    });

    return this.parseClaudeResponse(response.content[0].text);
  }

  buildFileContext(files) {
    return files.map(file => 
      `파일: ${file.path}\n내용:\n${file.content}\n---`
    ).join('\n');
  }

  parseClaudeResponse(response) {
    // Claude의 응답을 파싱해서 실제 파일 변경사항 추출
    const lines = response.split('\n');
    let explanation = '';
    let fileChanges = [];
    
    // 간단한 파싱 로직 (실제로는 더 정교해야 함)
    let inFileChange = false;
    let currentFileChange = {};
    
    for (const line of lines) {
      if (line.startsWith('파일:')) {
        if (inFileChange && currentFileChange.path) {
          fileChanges.push(currentFileChange);
        }
        inFileChange = true;
        currentFileChange = {
          path: line.replace('파일:', '').trim(),
          content: ''
        };
      } else if (inFileChange) {
        currentFileChange.content += line + '\n';
      } else {
        explanation += line + '\n';
      }
    }
    
    if (inFileChange && currentFileChange.path) {
      fileChanges.push(currentFileChange);
    }
    
    return {
      explanation: explanation.trim(),
      fileChanges
    };
  }
}

module.exports = ClaudeService;
```

### 2. 실시간 파일 시스템 (서버)
```javascript
// server/routes/files.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');

const router = express.Router();
const WORKSPACE_DIR = path.join(__dirname, '../workspace/current-note');

// 파일 읽기
router.get('/read/:filename', async (req, res) => {
  try {
    const filepath = path.join(WORKSPACE_DIR, req.params.filename);
    const content = await fs.readFile(filepath, 'utf-8');
    res.json({ success: true, content, filename: req.params.filename });
  } catch (error) {
    res.status(404).json({ success: false, error: error.message });
  }
});

// 파일 쓰기
router.post('/write/:filename', async (req, res) => {
  try {
    const filepath = path.join(WORKSPACE_DIR, req.params.filename);
    await fs.writeFile(filepath, req.body.content, 'utf-8');
    res.json({ success: true, message: 'File updated' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// 모든 파일 목록
router.get('/list', async (req, res) => {
  try {
    const files = await fs.readdir(WORKSPACE_DIR);
    const fileContents = await Promise.all(
      files.map(async (filename) => {
        const filepath = path.join(WORKSPACE_DIR, filename);
        const content = await fs.readFile(filepath, 'utf-8');
        return { path: filename, content };
      })
    );
    res.json({ success: true, files: fileContents });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
```

### 3. 채팅 인터페이스 (프론트엔드)
```typescript
// client/src/components/ChatPanel.tsx
import React, { useState, useEffect } from 'react';
import { sendToClaude, getFiles, updateFile } from '../services/claudeAPI';

interface Message {
  role: 'user' | 'claude';
  content: string;
  timestamp: Date;
}

const ChatPanel: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim()) return;
    
    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    try {
      // 현재 파일들 가져오기
      const filesResponse = await getFiles();
      
      // Claude에게 요청 보내기
      const claudeResponse = await sendToCloud(input, filesResponse.data.files);
      
      const claudeMessage: Message = {
        role: 'claude',
        content: claudeResponse.explanation,
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, claudeMessage]);
      
      // 파일 변경사항 적용
      for (const change of claudeResponse.fileChanges) {
        await updateFile(change.path, change.content);
      }
      
    } catch (error) {
      console.error('Error:', error);
      const errorMessage: Message = {
        role: 'claude',
        content: '죄송합니다. 오류가 발생했습니다.',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    }
    
    setLoading(false);
  };

  return (
    <div className="chat-panel">
      <div className="messages">
        {messages.map((message, index) => (
          <div key={index} className={`message ${message.role}`}>
            <div className="message-content">{message.content}</div>
            <div className="message-time">
              {message.timestamp.toLocaleTimeString()}
            </div>
          </div>
        ))}
        {loading && (
          <div className="message claude loading">
            <div className="message-content">Claude가 작업 중입니다...</div>
          </div>
        )}
      </div>
      
      <div className="input-area">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
          placeholder="Claude에게 노트 수정 요청을 해보세요..."
          disabled={loading}
        />
        <button onClick={sendMessage} disabled={loading}>
          전송
        </button>
      </div>
    </div>
  );
};

export default ChatPanel;
```

### 4. 실시간 미리보기 (프론트엔드)
```typescript
// client/src/components/PreviewPanel.tsx
import React, { useEffect, useRef, useState } from 'react';
import { getFiles } from '../services/claudeAPI';

const PreviewPanel: React.FC = () => {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const [previewUrl, setPreviewUrl] = useState('');

  useEffect(() => {
    // 파일 변경 감지 및 미리보기 업데이트
    const interval = setInterval(async () => {
      try {
        const response = await getFiles();
        updatePreview(response.data.files);
      } catch (error) {
        console.error('Preview update error:', error);
      }
    }, 1000); // 1초마다 체크

    return () => clearInterval(interval);
  }, []);

  const updatePreview = (files: any[]) => {
    // HTML 파일 찾기
    const htmlFile = files.find(f => f.path.endsWith('.html'));
    if (htmlFile && iframeRef.current) {
      // Blob URL 생성해서 iframe에 로드
      const blob = new Blob([htmlFile.content], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl);
      }
      
      setPreviewUrl(url);
      iframeRef.current.src = url;
    }
  };

  return (
    <div className="preview-panel">
      <div className="preview-header">
        <h3>실시간 미리보기</h3>
        <button onClick={() => iframeRef.current?.contentWindow?.location.reload()}>
          새로고침
        </button>
      </div>
      
      <iframe
        ref={iframeRef}
        className="preview-iframe"
        title="Live Preview"
        sandbox="allow-scripts allow-same-origin"
      />
    </div>
  );
};

export default PreviewPanel;
```

---

## 🚀 실행 방법

### 1. 환경 설정
```bash
# 프로젝트 생성
mkdir note-garage-prototype
cd note-garage-prototype

# 서버 설정
mkdir server && cd server
npm init -y
npm install express anthropic @anthropic-ai/sdk chokidar cors dotenv
touch .env

# .env 파일에 API 키 추가
echo "ANTHROPIC_API_KEY=your_claude_api_key_here" >> .env

# 클라이언트 설정  
cd .. && npx create-react-app client --template typescript
cd client
npm install axios socket.io-client monaco-editor @monaco-editor/react
```

### 2. 테스트 파일 준비
```bash
# 작업공간 생성
mkdir -p workspace/current-note

# 간단한 HTML 파일 생성
cat > workspace/current-note/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>My Note</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>내 노트</h1>
        <p>여기는 내용이 들어가는 곳입니다.</p>
        <button onclick="alert('안녕!')">클릭해보세요</button>
    </div>
    <script src="script.js"></script>
</body>
</html>
EOF

cat > workspace/current-note/style.css << 'EOF'
body {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
}

.container {
    background: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

h1 {
    color: #333;
    text-align: center;
}

button {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
}
EOF

touch workspace/current-note/script.js
```

### 3. 서버 실행
```bash
# 서버 디렉토리에서
node server.js
```

### 4. 클라이언트 실행  
```bash
# 클라이언트 디렉토리에서
npm start
```

---

## 🧪 테스트 시나리오

### 시나리오 1: 색상 변경
```
사용자: "배경색을 파란색으로 바꿔줘"
Claude: "배경색을 파란색으로 변경했습니다"
→ style.css의 background-color가 자동 변경
→ 미리보기에서 즉시 확인 가능
```

### 시나리오 2: 텍스트 수정
```
사용자: "제목을 '멋진 노트'로 바꿔줘"  
Claude: "제목을 '멋진 노트'로 변경했습니다"
→ index.html의 h1 태그 내용 변경
→ 실시간 미리보기 업데이트
```

### 시나리오 3: 버튼 추가
```
사용자: "새로운 버튼을 하나 더 추가해줘"
Claude: "새 버튼을 추가했습니다"  
→ HTML에 새 버튼 요소 추가
→ CSS에 스타일 추가
→ 미리보기에서 즉시 확인
```

---

## ⚡ 발전 방향

### Phase 2: 고급 기능
- **드래그 앤 드롭**: 요소 위치 조정
- **레이어 관리**: Z-index 시각적 관리  
- **아이콘 라이브러리**: 검색 가능한 아이콘들

### Phase 3: AI 고도화
- **이미지 인식**: 스크린샷 기반 수정 요청
- **디자인 제안**: "더 예쁘게 해줘" 같은 추상적 요청
- **성능 최적화**: 자동 코드 최적화

---

## 💡 핵심 포인트

1. **시작은 간단하게**: 채팅 + 파일 수정 + 미리보기
2. **점진적 개선**: 기능을 하나씩 추가
3. **실제 테스트**: 간단한 HTML/CSS로 시작
4. **사용자 피드백**: 실제 사용해보면서 개선

이 프로토타입으로 **"AI와 함께하는 실시간 편집"**의 가능성을 확인할 수 있습니다! 🚀